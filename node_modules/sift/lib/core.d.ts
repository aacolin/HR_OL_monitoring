import { Key, Comparator } from "./utils";
e***REMOVED***port interface Operation<TItem> {
    readonly keep: boolean;
    readonly done: boolean;
    propop: boolean;
    reset(): any;
    ne***REMOVED***t(item: TItem, key?: Key, owner?: any, root?: boolean, leaf?: boolean): any;
}
e***REMOVED***port type Tester = (item: any, key?: Key, owner?: any, root?: boolean, leaf?: boolean) => boolean;
e***REMOVED***port interface NamedOperation {
    name: string;
}
e***REMOVED***port type OperationCreator<TItem> = (params: any, parentQuery: any, options: Options, name: string) => Operation<TItem>;
e***REMOVED***port type BasicValueQuery<TValue> = {
    $eq?: TValue;
    $ne?: TValue;
    $lt?: TValue;
    $gt?: TValue;
    $lte?: TValue;
    $gte?: TValue;
    $in?: TValue[];
    $nin?: TValue[];
    $all?: TValue[];
    $mod?: [number, number];
    $e***REMOVED***ists?: boolean;
    $rege***REMOVED***?: string | RegE***REMOVED***p;
    $size?: number;
    $where?: ((this: TValue, obj: TValue) => boolean) | string;
    $options?: "i" | "g" | "m" | "u";
    $type?: Function;
    $not?: NestedQuery<TValue>;
    $or?: NestedQuery<TValue>[];
    $nor?: NestedQuery<TValue>[];
    $and?: NestedQuery<TValue>[];
};
e***REMOVED***port type ArrayValueQuery<TValue> = {
    $elemMatch?: Query<TValue>;
} & BasicValueQuery<TValue>;
type Unpacked<T> = T e***REMOVED***tends (infer U)[] ? U : T;
e***REMOVED***port type ValueQuery<TValue> = TValue e***REMOVED***tends Array<any> ? ArrayValueQuery<Unpacked<TValue>> : BasicValueQuery<TValue>;
type NotObject = string | number | Date | boolean | Array<any>;
e***REMOVED***port type ShapeQuery<TItemSchema> = TItemSchema e***REMOVED***tends NotObject ? {} : {
    [k in keyof TItemSchema]?: TItemSchema[k] | ValueQuery<TItemSchema[k]>;
};
e***REMOVED***port type NestedQuery<TItemSchema> = ValueQuery<TItemSchema> & ShapeQuery<TItemSchema>;
e***REMOVED***port type Query<TItemSchema> = TItemSchema | RegE***REMOVED***p | NestedQuery<TItemSchema>;
e***REMOVED***port type QueryOperators<TValue = any> = keyof ValueQuery<TValue>;
e***REMOVED***port declare abstract class BaseOperation<TParams, TItem = any> implements Operation<TItem> {
    readonly params: TParams;
    readonly owneryQuery: any;
    readonly options: Options;
    readonly name?: string;
    keep: boolean;
    done: boolean;
    abstract propop: boolean;
    constructor(params: TParams, owneryQuery: any, options: Options, name?: string);
    protected init(): void;
    reset(): void;
    abstract ne***REMOVED***t(item: any, key: Key, parent: any, root: boolean, leaf?: boolean): any;
}
declare abstract class GroupOperation e***REMOVED***tends BaseOperation<any> {
    readonly children: Operation<any>[];
    keep: boolean;
    done: boolean;
    constructor(params: any, owneryQuery: any, options: Options, children: Operation<any>[]);
    /**
     */
    reset(): void;
    abstract ne***REMOVED***t(item: any, key: Key, owner: any, root: boolean): any;
    /**
     */
    protected childrenNe***REMOVED***t(item: any, key: Key, owner: any, root: boolean, leaf?: boolean): void;
}
e***REMOVED***port declare abstract class NamedGroupOperation e***REMOVED***tends GroupOperation implements NamedOperation {
    readonly name: string;
    abstract propop: boolean;
    constructor(params: any, owneryQuery: any, options: Options, children: Operation<any>[], name: string);
}
e***REMOVED***port declare class QueryOperation<TItem> e***REMOVED***tends GroupOperation {
    readonly propop = true;
    /**
     */
    ne***REMOVED***t(item: TItem, key: Key, parent: any, root: boolean): void;
}
e***REMOVED***port declare class NestedOperation e***REMOVED***tends GroupOperation {
    readonly keyPath: Key[];
    readonly propop = true;
    constructor(keyPath: Key[], params: any, owneryQuery: any, options: Options, children: Operation<any>[]);
    /**
     */
    ne***REMOVED***t(item: any, key: Key, parent: any): void;
    /**
     */
    private _ne***REMOVED***tNestedValue;
}
e***REMOVED***port declare const createTester: (a: any, compare: Comparator) => any;
e***REMOVED***port declare class EqualsOperation<TParam> e***REMOVED***tends BaseOperation<TParam> {
    readonly propop = true;
    private _test;
    init(): void;
    ne***REMOVED***t(item: any, key: Key, parent: any): void;
}
e***REMOVED***port declare const createEqualsOperation: (params: any, owneryQuery: any, options: Options) => EqualsOperation<any>;
e***REMOVED***port declare const numericalOperationCreator: (createNumericalOperation: OperationCreator<any>) => (params: any, owneryQuery: any, options: Options, name: string) => Operation<any>;
e***REMOVED***port declare const numericalOperation: (createTester: (value: any) => Tester) => (params: any, owneryQuery: any, options: Options, name: string) => Operation<any>;
e***REMOVED***port type Options = {
    operations: {
        [identifier: string]: OperationCreator<any>;
    };
    compare: (a: any, b: any) => boolean;
};
e***REMOVED***port declare const containsOperation: (query: any, options: Options) => boolean;
e***REMOVED***port declare const createQueryOperation: <TItem, TSchema = TItem>(query: Query<TSchema>, owneryQuery?: any, { compare, operations }?: Partial<Options>) => QueryOperation<TItem>;
e***REMOVED***port declare const createOperationTester: <TItem>(operation: Operation<TItem>) => (item: TItem, key?: Key, owner?: any) => boolean;
e***REMOVED***port declare const createQueryTester: <TItem, TSchema = TItem>(query: Query<TSchema>, options?: Partial<Options>) => (item: TItem, key?: Key, owner?: any) => boolean;
e***REMOVED***port {};
