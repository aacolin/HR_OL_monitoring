'use strict';

var assert = require('assert');
var TokenStream = require('token-stream');
var error = require('pug-error');
var inlineTags = require('./lib/inline-tags');

module.e***REMOVED***ports = parse;
module.e***REMOVED***ports.Parser = Parser;
function parse(tokens, options) {
  var parser = new Parser(tokens, options);
  var ast = parser.parse();
  return JSON.parse(JSON.stringify(ast));
}

/**
 * Initialize `Parser` with the given input `str` and `filename`.
 *
 * @param {String} str
 * @param {String} filename
 * @param {Object} options
 * @api public
 */

function Parser(tokens, options) {
  options = options || {};
  if (!Array.isArray(tokens)) {
    throw new Error(
      'E***REMOVED***pected tokens to be an Array but got "' + typeof tokens + '"'
    );
  }
  if (typeof options !== 'object') {
    throw new Error(
      'E***REMOVED***pected "options" to be an object but got "' + typeof options + '"'
    );
  }
  this.tokens = new TokenStream(tokens);
  this.filename = options.filename;
  this.src = options.src;
  this.inMi***REMOVED***in = 0;
  this.plugins = options.plugins || [];
}

/**
 * Parser prototype.
 */

Parser.prototype = {
  /**
   * Save original constructor
   */

  constructor: Parser,

  error: function(code, message, token) {
    var err = error(code, message, {
      line: token.loc.start.line,
      column: token.loc.start.column,
      filename: this.filename,
      src: this.src,
    });
    throw err;
  },

  /**
   * Return the ne***REMOVED***t token object.
   *
   * @return {Object}
   * @api private
   */

  advance: function() {
    return this.tokens.advance();
  },

  /**
   * Single token lookahead.
   *
   * @return {Object}
   * @api private
   */

  peek: function() {
    return this.tokens.peek();
  },

  /**
   * `n` token lookahead.
   *
   * @param {Number} n
   * @return {Object}
   * @api private
   */

  lookahead: function(n) {
    return this.tokens.lookahead(n);
  },

  /**
   * Parse input returning a string of js for evaluation.
   *
   * @return {String}
   * @api public
   */

  parse: function() {
    var block = this.emptyBlock(0);

    while ('eos' != this.peek().type) {
      if ('newline' == this.peek().type) {
        this.advance();
      } else if ('te***REMOVED***t-html' == this.peek().type) {
        block.nodes = block.nodes.concat(this.parseTe***REMOVED***tHtml());
      } else {
        var e***REMOVED***pr = this.parseE***REMOVED***pr();
        if (e***REMOVED***pr) {
          if (e***REMOVED***pr.type === 'Block') {
            block.nodes = block.nodes.concat(e***REMOVED***pr.nodes);
          } else {
            block.nodes.push(e***REMOVED***pr);
          }
        }
      }
    }

    return block;
  },

  /**
   * E***REMOVED***pect the given type, or throw an e***REMOVED***ception.
   *
   * @param {String} type
   * @api private
   */

  e***REMOVED***pect: function(type) {
    if (this.peek().type === type) {
      return this.advance();
    } else {
      this.error(
        'INVALID_TOKEN',
        'e***REMOVED***pected "' + type + '", but got "' + this.peek().type + '"',
        this.peek()
      );
    }
  },

  /**
   * Accept the given `type`.
   *
   * @param {String} type
   * @api private
   */

  accept: function(type) {
    if (this.peek().type === type) {
      return this.advance();
    }
  },

  initBlock: function(line, nodes) {
    /* istanbul ignore if */
    if ((line | 0) !== line) throw new Error('`line` is not an integer');
    /* istanbul ignore if */
    if (!Array.isArray(nodes)) throw new Error('`nodes` is not an array');
    return {
      type: 'Block',
      nodes: nodes,
      line: line,
      filename: this.filename,
    };
  },

  emptyBlock: function(line) {
    return this.initBlock(line, []);
  },

  runPlugin: function(conte***REMOVED***t, tok) {
    var rest = [this];
    for (var i = 2; i < arguments.length; i++) {
      rest.push(arguments[i]);
    }
    var pluginConte***REMOVED***t;
    for (var i = 0; i < this.plugins.length; i++) {
      var plugin = this.plugins[i];
      if (plugin[conte***REMOVED***t] && plugin[conte***REMOVED***t][tok.type]) {
        if (pluginConte***REMOVED***t)
          throw new Error(
            'Multiple plugin handlers found for conte***REMOVED***t ' +
              JSON.stringify(conte***REMOVED***t) +
              ', token type ' +
              JSON.stringify(tok.type)
          );
        pluginConte***REMOVED***t = plugin[conte***REMOVED***t];
      }
    }
    if (pluginConte***REMOVED***t)
      return pluginConte***REMOVED***t[tok.type].apply(pluginConte***REMOVED***t, rest);
  },

  /**
   *   tag
   * | doctype
   * | mi***REMOVED***in
   * | include
   * | filter
   * | comment
   * | te***REMOVED***t
   * | te***REMOVED***t-html
   * | dot
   * | each
   * | code
   * | yield
   * | id
   * | class
   * | interpolation
   */

  parseE***REMOVED***pr: function() {
    switch (this.peek().type) {
      case 'tag':
        return this.parseTag();
      case 'mi***REMOVED***in':
        return this.parseMi***REMOVED***in();
      case 'block':
        return this.parseBlock();
      case 'mi***REMOVED***in-block':
        return this.parseMi***REMOVED***inBlock();
      case 'case':
        return this.parseCase();
      case 'e***REMOVED***tends':
        return this.parseE***REMOVED***tends();
      case 'include':
        return this.parseInclude();
      case 'doctype':
        return this.parseDoctype();
      case 'filter':
        return this.parseFilter();
      case 'comment':
        return this.parseComment();
      case 'te***REMOVED***t':
      case 'interpolated-code':
      case 'start-pug-interpolation':
        return this.parseTe***REMOVED***t({block: true});
      case 'te***REMOVED***t-html':
        return this.initBlock(this.peek().loc.start.line, this.parseTe***REMOVED***tHtml());
      case 'dot':
        return this.parseDot();
      case 'each':
        return this.parseEach();
      case 'eachOf':
        return this.parseEachOf();
      case 'code':
        return this.parseCode();
      case 'blockcode':
        return this.parseBlockCode();
      case 'if':
        return this.parseConditional();
      case 'while':
        return this.parseWhile();
      case 'call':
        return this.parseCall();
      case 'interpolation':
        return this.parseInterpolation();
      case 'yield':
        return this.parseYield();
      case 'id':
      case 'class':
        if (!this.peek().loc.start) debugger;
        this.tokens.defer({
          type: 'tag',
          val: 'div',
          loc: this.peek().loc,
          filename: this.filename,
        });
        return this.parseE***REMOVED***pr();
      default:
        var pluginResult = this.runPlugin('e***REMOVED***pressionTokens', this.peek());
        if (pluginResult) return pluginResult;
        this.error(
          'INVALID_TOKEN',
          'une***REMOVED***pected token "' + this.peek().type + '"',
          this.peek()
        );
    }
  },

  parseDot: function() {
    this.advance();
    return this.parseTe***REMOVED***tBlock();
  },

  /**
   * Te***REMOVED***t
   */

  parseTe***REMOVED***t: function(options) {
    var tags = [];
    var lineno = this.peek().loc.start.line;
    var ne***REMOVED***tTok = this.peek();
    loop: while (true) {
      switch (ne***REMOVED***tTok.type) {
        case 'te***REMOVED***t':
          var tok = this.advance();
          tags.push({
            type: 'Te***REMOVED***t',
            val: tok.val,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename,
          });
          break;
        case 'interpolated-code':
          var tok = this.advance();
          tags.push({
            type: 'Code',
            val: tok.val,
            buffer: tok.buffer,
            mustEscape: tok.mustEscape !== false,
            isInline: true,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename,
          });
          break;
        case 'newline':
          if (!options || !options.block) break loop;
          var tok = this.advance();
          var ne***REMOVED***tType = this.peek().type;
          if (ne***REMOVED***tType === 'te***REMOVED***t' || ne***REMOVED***tType === 'interpolated-code') {
            tags.push({
              type: 'Te***REMOVED***t',
              val: '\n',
              line: tok.loc.start.line,
              column: tok.loc.start.column,
              filename: this.filename,
            });
          }
          break;
        case 'start-pug-interpolation':
          this.advance();
          tags.push(this.parseE***REMOVED***pr());
          this.e***REMOVED***pect('end-pug-interpolation');
          break;
        default:
          var pluginResult = this.runPlugin('te***REMOVED***tTokens', ne***REMOVED***tTok, tags);
          if (pluginResult) break;
          break loop;
      }
      ne***REMOVED***tTok = this.peek();
    }
    if (tags.length === 1) return tags[0];
    else return this.initBlock(lineno, tags);
  },

  parseTe***REMOVED***tHtml: function() {
    var nodes = [];
    var currentNode = null;
    loop: while (true) {
      switch (this.peek().type) {
        case 'te***REMOVED***t-html':
          var te***REMOVED***t = this.advance();
          if (!currentNode) {
            currentNode = {
              type: 'Te***REMOVED***t',
              val: te***REMOVED***t.val,
              filename: this.filename,
              line: te***REMOVED***t.loc.start.line,
              column: te***REMOVED***t.loc.start.column,
              isHtml: true,
            };
            nodes.push(currentNode);
          } else {
            currentNode.val += '\n' + te***REMOVED***t.val;
          }
          break;
        case 'indent':
          var block = this.block();
          block.nodes.forEach(function(node) {
            if (node.isHtml) {
              if (!currentNode) {
                currentNode = node;
                nodes.push(currentNode);
              } else {
                currentNode.val += '\n' + node.val;
              }
            } else {
              currentNode = null;
              nodes.push(node);
            }
          });
          break;
        case 'code':
          currentNode = null;
          nodes.push(this.parseCode(true));
          break;
        case 'newline':
          this.advance();
          break;
        default:
          break loop;
      }
    }
    return nodes;
  },

  /**
   *   ':' e***REMOVED***pr
   * | block
   */

  parseBlockE***REMOVED***pansion: function() {
    var tok = this.accept(':');
    if (tok) {
      var e***REMOVED***pr = this.parseE***REMOVED***pr();
      return e***REMOVED***pr.type === 'Block'
        ? e***REMOVED***pr
        : this.initBlock(tok.loc.start.line, [e***REMOVED***pr]);
    } else {
      return this.block();
    }
  },

  /**
   * case
   */

  parseCase: function() {
    var tok = this.e***REMOVED***pect('case');
    var node = {
      type: 'Case',
      e***REMOVED***pr: tok.val,
      line: tok.loc.start.line,
      column: tok.loc.start.column,
      filename: this.filename,
    };

    var block = this.emptyBlock(tok.loc.start.line + 1);
    this.e***REMOVED***pect('indent');
    while ('outdent' != this.peek().type) {
      switch (this.peek().type) {
        case 'comment':
        case 'newline':
          this.advance();
          break;
        case 'when':
          block.nodes.push(this.parseWhen());
          break;
        case 'default':
          block.nodes.push(this.parseDefault());
          break;
        default:
          var pluginResult = this.runPlugin('caseTokens', this.peek(), block);
          if (pluginResult) break;
          this.error(
            'INVALID_TOKEN',
            'Une***REMOVED***pected token "' +
              this.peek().type +
              '", e***REMOVED***pected "when", "default" or "newline"',
            this.peek()
          );
      }
    }
    this.e***REMOVED***pect('outdent');

    node.block = block;

    return node;
  },

  /**
   * when
   */

  parseWhen: function() {
    var tok = this.e***REMOVED***pect('when');
    if (this.peek().type !== 'newline') {
      return {
        type: 'When',
        e***REMOVED***pr: tok.val,
        block: this.parseBlockE***REMOVED***pansion(),
        debug: false,
        line: tok.loc.start.line,
        column: tok.loc.start.column,
        filename: this.filename,
      };
    } else {
      return {
        type: 'When',
        e***REMOVED***pr: tok.val,
        debug: false,
        line: tok.loc.start.line,
        column: tok.loc.start.column,
        filename: this.filename,
      };
    }
  },

  /**
   * default
   */

  parseDefault: function() {
    var tok = this.e***REMOVED***pect('default');
    return {
      type: 'When',
      e***REMOVED***pr: 'default',
      block: this.parseBlockE***REMOVED***pansion(),
      debug: false,
      line: tok.loc.start.line,
      column: tok.loc.start.column,
      filename: this.filename,
    };
  },

  /**
   * code
   */

  parseCode: function(noBlock) {
    var tok = this.e***REMOVED***pect('code');
    assert(
      typeof tok.mustEscape === 'boolean',
      'Please update to the newest version of pug-le***REMOVED***er.'
    );
    var node = {
      type: 'Code',
      val: tok.val,
      buffer: tok.buffer,
      mustEscape: tok.mustEscape !== false,
      isInline: !!noBlock,
      line: tok.loc.start.line,
      column: tok.loc.start.column,
      filename: this.filename,
    };
    // todo: why is this here?  It seems like a hacky workaround
    if (node.val.match(/^ *else/)) node.debug = false;

    if (noBlock) return node;

    var block;

    // handle block
    block = 'indent' == this.peek().type;
    if (block) {
      if (tok.buffer) {
        this.error(
          'BLOCK_IN_BUFFERED_CODE',
          'Buffered code cannot have a block attached to it',
          this.peek()
        );
      }
      node.block = this.block();
    }

    return node;
  },
  parseConditional: function() {
    var tok = this.e***REMOVED***pect('if');
    var node = {
      type: 'Conditional',
      test: tok.val,
      consequent: this.emptyBlock(tok.loc.start.line),
      alternate: null,
      line: tok.loc.start.line,
      column: tok.loc.start.column,
      filename: this.filename,
    };

    // handle block
    if ('indent' == this.peek().type) {
      node.consequent = this.block();
    }

    var currentNode = node;
    while (true) {
      if (this.peek().type === 'newline') {
        this.e***REMOVED***pect('newline');
      } else if (this.peek().type === 'else-if') {
        tok = this.e***REMOVED***pect('else-if');
        currentNode = currentNode.alternate = {
          type: 'Conditional',
          test: tok.val,
          consequent: this.emptyBlock(tok.loc.start.line),
          alternate: null,
          line: tok.loc.start.line,
          column: tok.loc.start.column,
          filename: this.filename,
        };
        if ('indent' == this.peek().type) {
          currentNode.consequent = this.block();
        }
      } else if (this.peek().type === 'else') {
        this.e***REMOVED***pect('else');
        if (this.peek().type === 'indent') {
          currentNode.alternate = this.block();
        }
        break;
      } else {
        break;
      }
    }

    return node;
  },
  parseWhile: function() {
    var tok = this.e***REMOVED***pect('while');
    var node = {
      type: 'While',
      test: tok.val,
      line: tok.loc.start.line,
      column: tok.loc.start.column,
      filename: this.filename,
    };

    // handle block
    if ('indent' == this.peek().type) {
      node.block = this.block();
    } else {
      node.block = this.emptyBlock(tok.loc.start.line);
    }

    return node;
  },

  /**
   * block code
   */

  parseBlockCode: function() {
    var tok = this.e***REMOVED***pect('blockcode');
    var line = tok.loc.start.line;
    var column = tok.loc.start.column;
    var body = this.peek();
    var te***REMOVED***t = '';
    if (body.type === 'start-pipeless-te***REMOVED***t') {
      this.advance();
      while (this.peek().type !== 'end-pipeless-te***REMOVED***t') {
        tok = this.advance();
        switch (tok.type) {
          case 'te***REMOVED***t':
            te***REMOVED***t += tok.val;
            break;
          case 'newline':
            te***REMOVED***t += '\n';
            break;
          default:
            var pluginResult = this.runPlugin('blockCodeTokens', tok, tok);
            if (pluginResult) {
              te***REMOVED***t += pluginResult;
              break;
            }
            this.error(
              'INVALID_TOKEN',
              'Une***REMOVED***pected token type: ' + tok.type,
              tok
            );
        }
      }
      this.advance();
    }
    return {
      type: 'Code',
      val: te***REMOVED***t,
      buffer: false,
      mustEscape: false,
      isInline: false,
      line: line,
      column: column,
      filename: this.filename,
    };
  },
  /**
   * comment
   */

  parseComment: function() {
    var tok = this.e***REMOVED***pect('comment');
    var block;
    if ((block = this.parseTe***REMOVED***tBlock())) {
      return {
        type: 'BlockComment',
        val: tok.val,
        block: block,
        buffer: tok.buffer,
        line: tok.loc.start.line,
        column: tok.loc.start.column,
        filename: this.filename,
      };
    } else {
      return {
        type: 'Comment',
        val: tok.val,
        buffer: tok.buffer,
        line: tok.loc.start.line,
        column: tok.loc.start.column,
        filename: this.filename,
      };
    }
  },

  /**
   * doctype
   */

  parseDoctype: function() {
    var tok = this.e***REMOVED***pect('doctype');
    return {
      type: 'Doctype',
      val: tok.val,
      line: tok.loc.start.line,
      column: tok.loc.start.column,
      filename: this.filename,
    };
  },

  parseIncludeFilter: function() {
    var tok = this.e***REMOVED***pect('filter');
    var attrs = [];

    if (this.peek().type === 'start-attributes') {
      attrs = this.attrs();
    }

    return {
      type: 'IncludeFilter',
      name: tok.val,
      attrs: attrs,
      line: tok.loc.start.line,
      column: tok.loc.start.column,
      filename: this.filename,
    };
  },

  /**
   * filter attrs? te***REMOVED***t-block
   */

  parseFilter: function() {
    var tok = this.e***REMOVED***pect('filter');
    var block,
      attrs = [];

    if (this.peek().type === 'start-attributes') {
      attrs = this.attrs();
    }

    if (this.peek().type === 'te***REMOVED***t') {
      var te***REMOVED***tToken = this.advance();
      block = this.initBlock(te***REMOVED***tToken.loc.start.line, [
        {
          type: 'Te***REMOVED***t',
          val: te***REMOVED***tToken.val,
          line: te***REMOVED***tToken.loc.start.line,
          column: te***REMOVED***tToken.loc.start.column,
          filename: this.filename,
        },
      ]);
    } else if (this.peek().type === 'filter') {
      block = this.initBlock(tok.loc.start.line, [this.parseFilter()]);
    } else {
      block = this.parseTe***REMOVED***tBlock() || this.emptyBlock(tok.loc.start.line);
    }

    return {
      type: 'Filter',
      name: tok.val,
      block: block,
      attrs: attrs,
      line: tok.loc.start.line,
      column: tok.loc.start.column,
      filename: this.filename,
    };
  },

  /**
   * each block
   */

  parseEach: function() {
    var tok = this.e***REMOVED***pect('each');
    var node = {
      type: 'Each',
      obj: tok.code,
      val: tok.val,
      key: tok.key,
      block: this.block(),
      line: tok.loc.start.line,
      column: tok.loc.start.column,
      filename: this.filename,
    };
    if (this.peek().type == 'else') {
      this.advance();
      node.alternate = this.block();
    }
    return node;
  },

  parseEachOf: function() {
    var tok = this.e***REMOVED***pect('eachOf');
    var node = {
      type: 'EachOf',
      obj: tok.code,
      val: tok.val,
      block: this.block(),
      line: tok.loc.start.line,
      column: tok.loc.start.column,
      filename: this.filename,
    };
    return node;
  },
  /**
   * 'e***REMOVED***tends' name
   */

  parseE***REMOVED***tends: function() {
    var tok = this.e***REMOVED***pect('e***REMOVED***tends');
    var path = this.e***REMOVED***pect('path');
    return {
      type: 'E***REMOVED***tends',
      file: {
        type: 'FileReference',
        path: path.val.trim(),
        line: path.loc.start.line,
        column: path.loc.start.column,
        filename: this.filename,
      },
      line: tok.loc.start.line,
      column: tok.loc.start.column,
      filename: this.filename,
    };
  },

  /**
   * 'block' name block
   */

  parseBlock: function() {
    var tok = this.e***REMOVED***pect('block');

    var node =
      'indent' == this.peek().type
        ? this.block()
        : this.emptyBlock(tok.loc.start.line);
    node.type = 'NamedBlock';
    node.name = tok.val.trim();
    node.mode = tok.mode;
    node.line = tok.loc.start.line;
    node.column = tok.loc.start.column;

    return node;
  },

  parseMi***REMOVED***inBlock: function() {
    var tok = this.e***REMOVED***pect('mi***REMOVED***in-block');
    if (!this.inMi***REMOVED***in) {
      this.error(
        'BLOCK_OUTISDE_MIXIN',
        'Anonymous blocks are not allowed unless they are part of a mi***REMOVED***in.',
        tok
      );
    }
    return {
      type: 'Mi***REMOVED***inBlock',
      line: tok.loc.start.line,
      column: tok.loc.start.column,
      filename: this.filename,
    };
  },

  parseYield: function() {
    var tok = this.e***REMOVED***pect('yield');
    return {
      type: 'YieldBlock',
      line: tok.loc.start.line,
      column: tok.loc.start.column,
      filename: this.filename,
    };
  },

  /**
   * include block?
   */

  parseInclude: function() {
    var tok = this.e***REMOVED***pect('include');
    var node = {
      type: 'Include',
      file: {
        type: 'FileReference',
        filename: this.filename,
      },
      line: tok.loc.start.line,
      column: tok.loc.start.column,
      filename: this.filename,
    };
    var filters = [];
    while (this.peek().type === 'filter') {
      filters.push(this.parseIncludeFilter());
    }
    var path = this.e***REMOVED***pect('path');

    node.file.path = path.val.trim();
    node.file.line = path.loc.start.line;
    node.file.column = path.loc.start.column;

    if (
      (/\.jade$/.test(node.file.path) || /\.pug$/.test(node.file.path)) &&
      !filters.length
    ) {
      node.block =
        'indent' == this.peek().type
          ? this.block()
          : this.emptyBlock(tok.loc.start.line);
      if (/\.jade$/.test(node.file.path)) {
        console.warn(
          this.filename +
            ', line ' +
            tok.loc.start.line +
            ':\nThe .jade e***REMOVED***tension is deprecated, use .pug for "' +
            node.file.path +
            '".'
        );
      }
    } else {
      node.type = 'RawInclude';
      node.filters = filters;
      if (this.peek().type === 'indent') {
        this.error(
          'RAW_INCLUDE_BLOCK',
          'Raw inclusion cannot contain a block',
          this.peek()
        );
      }
    }
    return node;
  },

  /**
   * call ident block
   */

  parseCall: function() {
    var tok = this.e***REMOVED***pect('call');
    var name = tok.val;
    var args = tok.args;
    var mi***REMOVED***in = {
      type: 'Mi***REMOVED***in',
      name: name,
      args: args,
      block: this.emptyBlock(tok.loc.start.line),
      call: true,
      attrs: [],
      attributeBlocks: [],
      line: tok.loc.start.line,
      column: tok.loc.start.column,
      filename: this.filename,
    };

    this.tag(mi***REMOVED***in);
    if (mi***REMOVED***in.code) {
      mi***REMOVED***in.block.nodes.push(mi***REMOVED***in.code);
      delete mi***REMOVED***in.code;
    }
    if (mi***REMOVED***in.block.nodes.length === 0) mi***REMOVED***in.block = null;
    return mi***REMOVED***in;
  },

  /**
   * mi***REMOVED***in block
   */

  parseMi***REMOVED***in: function() {
    var tok = this.e***REMOVED***pect('mi***REMOVED***in');
    var name = tok.val;
    var args = tok.args;

    if ('indent' == this.peek().type) {
      this.inMi***REMOVED***in++;
      var mi***REMOVED***in = {
        type: 'Mi***REMOVED***in',
        name: name,
        args: args,
        block: this.block(),
        call: false,
        line: tok.loc.start.line,
        column: tok.loc.start.column,
        filename: this.filename,
      };
      this.inMi***REMOVED***in--;
      return mi***REMOVED***in;
    } else {
      this.error(
        'MIXIN_WITHOUT_BODY',
        'Mi***REMOVED***in ' + name + ' declared without body',
        tok
      );
    }
  },

  /**
   * indent (te***REMOVED***t | newline)* outdent
   */

  parseTe***REMOVED***tBlock: function() {
    var tok = this.accept('start-pipeless-te***REMOVED***t');
    if (!tok) return;
    var block = this.emptyBlock(tok.loc.start.line);
    while (this.peek().type !== 'end-pipeless-te***REMOVED***t') {
      var tok = this.advance();
      switch (tok.type) {
        case 'te***REMOVED***t':
          block.nodes.push({
            type: 'Te***REMOVED***t',
            val: tok.val,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename,
          });
          break;
        case 'newline':
          block.nodes.push({
            type: 'Te***REMOVED***t',
            val: '\n',
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename,
          });
          break;
        case 'start-pug-interpolation':
          block.nodes.push(this.parseE***REMOVED***pr());
          this.e***REMOVED***pect('end-pug-interpolation');
          break;
        case 'interpolated-code':
          block.nodes.push({
            type: 'Code',
            val: tok.val,
            buffer: tok.buffer,
            mustEscape: tok.mustEscape !== false,
            isInline: true,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename,
          });
          break;
        default:
          var pluginResult = this.runPlugin('te***REMOVED***tBlockTokens', tok, block, tok);
          if (pluginResult) break;
          this.error(
            'INVALID_TOKEN',
            'Une***REMOVED***pected token type: ' + tok.type,
            tok
          );
      }
    }
    this.advance();
    return block;
  },

  /**
   * indent e***REMOVED***pr* outdent
   */

  block: function() {
    var tok = this.e***REMOVED***pect('indent');
    var block = this.emptyBlock(tok.loc.start.line);
    while ('outdent' != this.peek().type) {
      if ('newline' == this.peek().type) {
        this.advance();
      } else if ('te***REMOVED***t-html' == this.peek().type) {
        block.nodes = block.nodes.concat(this.parseTe***REMOVED***tHtml());
      } else {
        var e***REMOVED***pr = this.parseE***REMOVED***pr();
        if (e***REMOVED***pr.type === 'Block') {
          block.nodes = block.nodes.concat(e***REMOVED***pr.nodes);
        } else {
          block.nodes.push(e***REMOVED***pr);
        }
      }
    }
    this.e***REMOVED***pect('outdent');
    return block;
  },

  /**
   * interpolation (attrs | class | id)* (te***REMOVED***t | code | ':')? newline* block?
   */

  parseInterpolation: function() {
    var tok = this.advance();
    var tag = {
      type: 'InterpolatedTag',
      e***REMOVED***pr: tok.val,
      selfClosing: false,
      block: this.emptyBlock(tok.loc.start.line),
      attrs: [],
      attributeBlocks: [],
      isInline: false,
      line: tok.loc.start.line,
      column: tok.loc.start.column,
      filename: this.filename,
    };

    return this.tag(tag, {selfClosingAllowed: true});
  },

  /**
   * tag (attrs | class | id)* (te***REMOVED***t | code | ':')? newline* block?
   */

  parseTag: function() {
    var tok = this.advance();
    var tag = {
      type: 'Tag',
      name: tok.val,
      selfClosing: false,
      block: this.emptyBlock(tok.loc.start.line),
      attrs: [],
      attributeBlocks: [],
      isInline: inlineTags.inde***REMOVED***Of(tok.val) !== -1,
      line: tok.loc.start.line,
      column: tok.loc.start.column,
      filename: this.filename,
    };

    return this.tag(tag, {selfClosingAllowed: true});
  },

  /**
   * Parse tag.
   */

  tag: function(tag, options) {
    var seenAttrs = false;
    var attributeNames = [];
    var selfClosingAllowed = options && options.selfClosingAllowed;
    // (attrs | class | id)*
    out: while (true) {
      switch (this.peek().type) {
        case 'id':
        case 'class':
          var tok = this.advance();
          if (tok.type === 'id') {
            if (attributeNames.inde***REMOVED***Of('id') !== -1) {
              this.error(
                'DUPLICATE_ID',
                'Duplicate attribute "id" is not allowed.',
                tok
              );
            }
            attributeNames.push('id');
          }
          tag.attrs.push({
            name: tok.type,
            val: "'" + tok.val + "'",
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename,
            mustEscape: false,
          });
          continue;
        case 'start-attributes':
          if (seenAttrs) {
            console.warn(
              this.filename +
                ', line ' +
                this.peek().loc.start.line +
                ':\nYou should not have pug tags with multiple attributes.'
            );
          }
          seenAttrs = true;
          tag.attrs = tag.attrs.concat(this.attrs(attributeNames));
          continue;
        case '&attributes':
          var tok = this.advance();
          tag.attributeBlocks.push({
            type: 'AttributeBlock',
            val: tok.val,
            line: tok.loc.start.line,
            column: tok.loc.start.column,
            filename: this.filename,
          });
          break;
        default:
          var pluginResult = this.runPlugin(
            'tagAttributeTokens',
            this.peek(),
            tag,
            attributeNames
          );
          if (pluginResult) break;
          break out;
      }
    }

    // check immediate '.'
    if ('dot' == this.peek().type) {
      tag.te***REMOVED***tOnly = true;
      this.advance();
    }

    // (te***REMOVED***t | code | ':')?
    switch (this.peek().type) {
      case 'te***REMOVED***t':
      case 'interpolated-code':
        var te***REMOVED***t = this.parseTe***REMOVED***t();
        if (te***REMOVED***t.type === 'Block') {
          tag.block.nodes.push.apply(tag.block.nodes, te***REMOVED***t.nodes);
        } else {
          tag.block.nodes.push(te***REMOVED***t);
        }
        break;
      case 'code':
        tag.block.nodes.push(this.parseCode(true));
        break;
      case ':':
        this.advance();
        var e***REMOVED***pr = this.parseE***REMOVED***pr();
        tag.block =
          e***REMOVED***pr.type === 'Block' ? e***REMOVED***pr : this.initBlock(tag.line, [e***REMOVED***pr]);
        break;
      case 'newline':
      case 'indent':
      case 'outdent':
      case 'eos':
      case 'start-pipeless-te***REMOVED***t':
      case 'end-pug-interpolation':
        break;
      case 'slash':
        if (selfClosingAllowed) {
          this.advance();
          tag.selfClosing = true;
          break;
        }
      default:
        var pluginResult = this.runPlugin(
          'tagTokens',
          this.peek(),
          tag,
          options
        );
        if (pluginResult) break;
        this.error(
          'INVALID_TOKEN',
          'Une***REMOVED***pected token `' +
            this.peek().type +
            '` e***REMOVED***pected `te***REMOVED***t`, `interpolated-code`, `code`, `:`' +
            (selfClosingAllowed ? ', `slash`' : '') +
            ', `newline` or `eos`',
          this.peek()
        );
    }

    // newline*
    while ('newline' == this.peek().type) this.advance();

    // block?
    if (tag.te***REMOVED***tOnly) {
      tag.block = this.parseTe***REMOVED***tBlock() || this.emptyBlock(tag.line);
    } else if ('indent' == this.peek().type) {
      var block = this.block();
      for (var i = 0, len = block.nodes.length; i < len; ++i) {
        tag.block.nodes.push(block.nodes[i]);
      }
    }

    return tag;
  },

  attrs: function(attributeNames) {
    this.e***REMOVED***pect('start-attributes');

    var attrs = [];
    var tok = this.advance();
    while (tok.type === 'attribute') {
      if (tok.name !== 'class' && attributeNames) {
        if (attributeNames.inde***REMOVED***Of(tok.name) !== -1) {
          this.error(
            'DUPLICATE_ATTRIBUTE',
            'Duplicate attribute "' + tok.name + '" is not allowed.',
            tok
          );
        }
        attributeNames.push(tok.name);
      }
      attrs.push({
        name: tok.name,
        val: tok.val,
        line: tok.loc.start.line,
        column: tok.loc.start.column,
        filename: this.filename,
        mustEscape: tok.mustEscape !== false,
      });
      tok = this.advance();
    }
    this.tokens.defer(tok);
    this.e***REMOVED***pect('end-attributes');
    return attrs;
  },
};
