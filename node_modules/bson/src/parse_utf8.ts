import { BSONError } from './error';

type Te***REMOVED***tDecoder = {
  readonly encoding: string;
  readonly fatal: boolean;
  readonly ignoreBOM: boolean;
  decode(input?: Uint8Array): string;
};
type Te***REMOVED***tDecoderConstructor = {
  new (label: 'utf8', options: { fatal: boolean; ignoreBOM?: boolean }): Te***REMOVED***tDecoder;
};

// parse utf8 globals
declare const Te***REMOVED***tDecoder: Te***REMOVED***tDecoderConstructor;
let Te***REMOVED***tDecoderFatal: Te***REMOVED***tDecoder;
let Te***REMOVED***tDecoderNonFatal: Te***REMOVED***tDecoder;

/**
 * Determines if the passed in bytes are valid utf8
 * @param bytes - An array of 8-bit bytes. Must be inde***REMOVED***able and have length property
 * @param start - The inde***REMOVED*** to start validating
 * @param end - The inde***REMOVED*** to end validating
 */
e***REMOVED***port function parseUtf8(buffer: Uint8Array, start: number, end: number, fatal: boolean): string {
  if (fatal) {
    Te***REMOVED***tDecoderFatal ??= new Te***REMOVED***tDecoder('utf8', { fatal: true });
    try {
      return Te***REMOVED***tDecoderFatal.decode(buffer.subarray(start, end));
    } catch (cause) {
      throw new BSONError('Invalid UTF-8 string in BSON document', { cause });
    }
  }
  Te***REMOVED***tDecoderNonFatal ??= new Te***REMOVED***tDecoder('utf8', { fatal: false });
  return Te***REMOVED***tDecoderNonFatal.decode(buffer.subarray(start, end));
}
