import { BSONValue } from './bson_value';
import { BSONError } from './error';
import type { EJSONOptions } from './e***REMOVED***tended_json';
import { type InspectFn, defaultInspect, getStylizeFunction } from './parser/utils';

function alphabetize(str: string): string {
  return str.split('').sort().join('');
}

/** @public */
e***REMOVED***port interface BSONRegE***REMOVED***pE***REMOVED***tendedLegacy {
  $rege***REMOVED***: string | BSONRegE***REMOVED***p;
  $options: string;
}

/** @public */
e***REMOVED***port interface BSONRegE***REMOVED***pE***REMOVED***tended {
  $regularE***REMOVED***pression: {
    pattern: string;
    options: string;
  };
}

/**
 * A class representation of the BSON RegE***REMOVED***p type.
 * @public
 * @category BSONType
 */
e***REMOVED***port class BSONRegE***REMOVED***p e***REMOVED***tends BSONValue {
  get _bsontype(): 'BSONRegE***REMOVED***p' {
    return 'BSONRegE***REMOVED***p';
  }

  pattern!: string;
  options!: string;
  /**
   * @param pattern - The regular e***REMOVED***pression pattern to match
   * @param options - The regular e***REMOVED***pression options
   */
  constructor(pattern: string, options?: string) {
    super();
    this.pattern = pattern;
    this.options = alphabetize(options ?? '');

    if (this.pattern.inde***REMOVED***Of('\***REMOVED***00') !== -1) {
      throw new BSONError(
        `BSON Rege***REMOVED*** patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`
      );
    }
    if (this.options.inde***REMOVED***Of('\***REMOVED***00') !== -1) {
      throw new BSONError(
        `BSON Rege***REMOVED*** options cannot contain null bytes, found: ${JSON.stringify(this.options)}`
      );
    }

    // Validate options
    for (let i = 0; i < this.options.length; i++) {
      if (
        !(
          this.options[i] === 'i' ||
          this.options[i] === 'm' ||
          this.options[i] === '***REMOVED***' ||
          this.options[i] === 'l' ||
          this.options[i] === 's' ||
          this.options[i] === 'u'
        )
      ) {
        throw new BSONError(`The regular e***REMOVED***pression option [${this.options[i]}] is not supported`);
      }
    }
  }

  static parseOptions(options?: string): string {
    return options ? options.split('').sort().join('') : '';
  }

  /** @internal */
  toE***REMOVED***tendedJSON(options?: EJSONOptions): BSONRegE***REMOVED***pE***REMOVED***tendedLegacy | BSONRegE***REMOVED***pE***REMOVED***tended {
    options = options || {};
    if (options.legacy) {
      return { $rege***REMOVED***: this.pattern, $options: this.options };
    }
    return { $regularE***REMOVED***pression: { pattern: this.pattern, options: this.options } };
  }

  /** @internal */
  static fromE***REMOVED***tendedJSON(doc: BSONRegE***REMOVED***pE***REMOVED***tendedLegacy | BSONRegE***REMOVED***pE***REMOVED***tended): BSONRegE***REMOVED***p {
    if ('$rege***REMOVED***' in doc) {
      if (typeof doc.$rege***REMOVED*** !== 'string') {
        // This is for $rege***REMOVED*** query operators that have e***REMOVED***tended json values.
        if (doc.$rege***REMOVED***._bsontype === 'BSONRegE***REMOVED***p') {
          return doc as unknown as BSONRegE***REMOVED***p;
        }
      } else {
        return new BSONRegE***REMOVED***p(doc.$rege***REMOVED***, BSONRegE***REMOVED***p.parseOptions(doc.$options));
      }
    }
    if ('$regularE***REMOVED***pression' in doc) {
      return new BSONRegE***REMOVED***p(
        doc.$regularE***REMOVED***pression.pattern,
        BSONRegE***REMOVED***p.parseOptions(doc.$regularE***REMOVED***pression.options)
      );
    }
    throw new BSONError(`Une***REMOVED***pected BSONRegE***REMOVED***p EJSON object form: ${JSON.stringify(doc)}`);
  }

  inspect(depth?: number, options?: unknown, inspect?: InspectFn): string {
    const stylize = getStylizeFunction(options) ?? (v => v);
    inspect ??= defaultInspect;
    const pattern = stylize(inspect(this.pattern), 'rege***REMOVED***p');
    const flags = stylize(inspect(this.options), 'rege***REMOVED***p');
    return `new BSONRegE***REMOVED***p(${pattern}, ${flags})`;
  }
}
