import { Binary } from '../binary';
import type { BSONSymbol, DBRef, Document, Ma***REMOVED***Key } from '../bson';
import type { Code } from '../code';
import * as constants from '../constants';
import type { DBRefLike } from '../db_ref';
import type { Decimal128 } from '../decimal128';
import type { Double } from '../double';
import { BSONError, BSONVersionError } from '../error';
import type { Int32 } from '../int_32';
import { Long } from '../long';
import type { MinKey } from '../min_key';
import type { ObjectId } from '../objectid';
import type { BSONRegE***REMOVED***p } from '../rege***REMOVED***p';
import { ByteUtils } from '../utils/byte_utils';
import { NumberUtils } from '../utils/number_utils';
import { isAnyArrayBuffer, isDate, isMap, isRegE***REMOVED***p, isUint8Array } from './utils';

/** @public */
e***REMOVED***port interface SerializeOptions {
  /**
   * the serializer will check if keys are valid.
   * @defaultValue `false`
   */
  checkKeys?: boolean;
  /**
   * serialize the javascript functions
   * @defaultValue `false`
   */
  serializeFunctions?: boolean;
  /**
   * serialize will not emit undefined fields
   * note that the driver sets this to `false`
   * @defaultValue `true`
   */
  ignoreUndefined?: boolean;
  /** @internal Resize internal buffer */
  minInternalBufferSize?: number;
  /**
   * the inde***REMOVED*** in the buffer where we wish to start serializing into
   * @defaultValue `0`
   */
  inde***REMOVED***?: number;
}

const rege***REMOVED***p = /\***REMOVED***00/; // eslint-disable-line no-control-rege***REMOVED***
const ignoreKeys = new Set(['$db', '$ref', '$id', '$clusterTime']);

/*
 * isArray indicates if we are writing to a BSON array (type 0***REMOVED***04)
 * which forces the "key" which really an array inde***REMOVED*** as a string to be written as ascii
 * This will catch any errors in inde***REMOVED*** as a string generation
 */

function serializeString(buffer: Uint8Array, key: string, value: string, inde***REMOVED***: number) {
  // Encode String type
  buffer[inde***REMOVED***++] = constants.BSON_DATA_STRING;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, inde***REMOVED***);
  // Encode the name
  inde***REMOVED*** = inde***REMOVED*** + numberOfWrittenBytes + 1;
  buffer[inde***REMOVED*** - 1] = 0;
  // Write the string
  const size = ByteUtils.encodeUTF8Into(buffer, value, inde***REMOVED*** + 4);
  // Write the size of the string to buffer
  NumberUtils.setInt32LE(buffer, inde***REMOVED***, size + 1);
  // Update inde***REMOVED***
  inde***REMOVED*** = inde***REMOVED*** + 4 + size;
  // Write zero
  buffer[inde***REMOVED***++] = 0;
  return inde***REMOVED***;
}

function serializeNumber(buffer: Uint8Array, key: string, value: number, inde***REMOVED***: number) {
  const isNegativeZero = Object.is(value, -0);

  const type =
    !isNegativeZero &&
    Number.isSafeInteger(value) &&
    value <= constants.BSON_INT32_MAX &&
    value >= constants.BSON_INT32_MIN
      ? constants.BSON_DATA_INT
      : constants.BSON_DATA_NUMBER;

  buffer[inde***REMOVED***++] = type;

  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, inde***REMOVED***);
  inde***REMOVED*** = inde***REMOVED*** + numberOfWrittenBytes;
  buffer[inde***REMOVED***++] = 0***REMOVED***00;

  if (type === constants.BSON_DATA_INT) {
    inde***REMOVED*** += NumberUtils.setInt32LE(buffer, inde***REMOVED***, value);
  } else {
    inde***REMOVED*** += NumberUtils.setFloat64LE(buffer, inde***REMOVED***, value);
  }

  return inde***REMOVED***;
}

function serializeBigInt(buffer: Uint8Array, key: string, value: bigint, inde***REMOVED***: number) {
  buffer[inde***REMOVED***++] = constants.BSON_DATA_LONG;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, inde***REMOVED***);
  // Encode the name
  inde***REMOVED*** += numberOfWrittenBytes;
  buffer[inde***REMOVED***++] = 0;

  inde***REMOVED*** += NumberUtils.setBigInt64LE(buffer, inde***REMOVED***, value);

  return inde***REMOVED***;
}

function serializeNull(buffer: Uint8Array, key: string, _: unknown, inde***REMOVED***: number) {
  // Set long type
  buffer[inde***REMOVED***++] = constants.BSON_DATA_NULL;

  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, inde***REMOVED***);

  // Encode the name
  inde***REMOVED*** = inde***REMOVED*** + numberOfWrittenBytes;
  buffer[inde***REMOVED***++] = 0;
  return inde***REMOVED***;
}

function serializeBoolean(buffer: Uint8Array, key: string, value: boolean, inde***REMOVED***: number) {
  // Write the type
  buffer[inde***REMOVED***++] = constants.BSON_DATA_BOOLEAN;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, inde***REMOVED***);
  // Encode the name
  inde***REMOVED*** = inde***REMOVED*** + numberOfWrittenBytes;
  buffer[inde***REMOVED***++] = 0;
  // Encode the boolean value
  buffer[inde***REMOVED***++] = value ? 1 : 0;
  return inde***REMOVED***;
}

function serializeDate(buffer: Uint8Array, key: string, value: Date, inde***REMOVED***: number) {
  // Write the type
  buffer[inde***REMOVED***++] = constants.BSON_DATA_DATE;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, inde***REMOVED***);
  // Encode the name
  inde***REMOVED*** = inde***REMOVED*** + numberOfWrittenBytes;
  buffer[inde***REMOVED***++] = 0;

  // Write the date
  const dateInMilis = Long.fromNumber(value.getTime());
  const lowBits = dateInMilis.getLowBits();
  const highBits = dateInMilis.getHighBits();
  // Encode low bits
  inde***REMOVED*** += NumberUtils.setInt32LE(buffer, inde***REMOVED***, lowBits);
  // Encode high bits
  inde***REMOVED*** += NumberUtils.setInt32LE(buffer, inde***REMOVED***, highBits);
  return inde***REMOVED***;
}

function serializeRegE***REMOVED***p(buffer: Uint8Array, key: string, value: RegE***REMOVED***p, inde***REMOVED***: number) {
  // Write the type
  buffer[inde***REMOVED***++] = constants.BSON_DATA_REGEXP;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, inde***REMOVED***);

  // Encode the name
  inde***REMOVED*** = inde***REMOVED*** + numberOfWrittenBytes;
  buffer[inde***REMOVED***++] = 0;
  if (value.source && value.source.match(rege***REMOVED***p) != null) {
    throw new BSONError('value ' + value.source + ' must not contain null bytes');
  }
  // Adjust the inde***REMOVED***
  inde***REMOVED*** = inde***REMOVED*** + ByteUtils.encodeUTF8Into(buffer, value.source, inde***REMOVED***);
  // Write zero
  buffer[inde***REMOVED***++] = 0***REMOVED***00;
  // Write the parameters
  if (value.ignoreCase) buffer[inde***REMOVED***++] = 0***REMOVED***69; // i
  if (value.global) buffer[inde***REMOVED***++] = 0***REMOVED***73; // s
  if (value.multiline) buffer[inde***REMOVED***++] = 0***REMOVED***6d; // m

  // Add ending zero
  buffer[inde***REMOVED***++] = 0***REMOVED***00;
  return inde***REMOVED***;
}

function serializeBSONRegE***REMOVED***p(buffer: Uint8Array, key: string, value: BSONRegE***REMOVED***p, inde***REMOVED***: number) {
  // Write the type
  buffer[inde***REMOVED***++] = constants.BSON_DATA_REGEXP;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, inde***REMOVED***);
  // Encode the name
  inde***REMOVED*** = inde***REMOVED*** + numberOfWrittenBytes;
  buffer[inde***REMOVED***++] = 0;

  // Check the pattern for 0 bytes
  if (value.pattern.match(rege***REMOVED***p) != null) {
    // The BSON spec doesn't allow keys with null bytes because keys are
    // null-terminated.
    throw new BSONError('pattern ' + value.pattern + ' must not contain null bytes');
  }

  // Adjust the inde***REMOVED***
  inde***REMOVED*** = inde***REMOVED*** + ByteUtils.encodeUTF8Into(buffer, value.pattern, inde***REMOVED***);
  // Write zero
  buffer[inde***REMOVED***++] = 0***REMOVED***00;
  // Write the options
  const sortedOptions = value.options.split('').sort().join('');
  inde***REMOVED*** = inde***REMOVED*** + ByteUtils.encodeUTF8Into(buffer, sortedOptions, inde***REMOVED***);
  // Add ending zero
  buffer[inde***REMOVED***++] = 0***REMOVED***00;
  return inde***REMOVED***;
}

function serializeMinMa***REMOVED***(buffer: Uint8Array, key: string, value: MinKey | Ma***REMOVED***Key, inde***REMOVED***: number) {
  // Write the type of either min or ma***REMOVED*** key
  if (value === null) {
    buffer[inde***REMOVED***++] = constants.BSON_DATA_NULL;
  } else if (value._bsontype === 'MinKey') {
    buffer[inde***REMOVED***++] = constants.BSON_DATA_MIN_KEY;
  } else {
    buffer[inde***REMOVED***++] = constants.BSON_DATA_MAX_KEY;
  }

  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, inde***REMOVED***);
  // Encode the name
  inde***REMOVED*** = inde***REMOVED*** + numberOfWrittenBytes;
  buffer[inde***REMOVED***++] = 0;
  return inde***REMOVED***;
}

function serializeObjectId(buffer: Uint8Array, key: string, value: ObjectId, inde***REMOVED***: number) {
  // Write the type
  buffer[inde***REMOVED***++] = constants.BSON_DATA_OID;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, inde***REMOVED***);

  // Encode the name
  inde***REMOVED*** = inde***REMOVED*** + numberOfWrittenBytes;
  buffer[inde***REMOVED***++] = 0;

  inde***REMOVED*** += value.serializeInto(buffer, inde***REMOVED***);

  // Adjust inde***REMOVED***
  return inde***REMOVED***;
}

function serializeBuffer(buffer: Uint8Array, key: string, value: Uint8Array, inde***REMOVED***: number) {
  // Write the type
  buffer[inde***REMOVED***++] = constants.BSON_DATA_BINARY;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, inde***REMOVED***);
  // Encode the name
  inde***REMOVED*** = inde***REMOVED*** + numberOfWrittenBytes;
  buffer[inde***REMOVED***++] = 0;
  // Get size of the buffer (current write point)
  const size = value.length;
  // Write the size of the string to buffer
  inde***REMOVED*** += NumberUtils.setInt32LE(buffer, inde***REMOVED***, size);
  // Write the default subtype
  buffer[inde***REMOVED***++] = constants.BSON_BINARY_SUBTYPE_DEFAULT;
  // Copy the content form the binary field to the buffer
  if (size <= 16) {
    for (let i = 0; i < size; i++) buffer[inde***REMOVED*** + i] = value[i];
  } else {
    buffer.set(value, inde***REMOVED***);
  }
  // Adjust the inde***REMOVED***
  inde***REMOVED*** = inde***REMOVED*** + size;
  return inde***REMOVED***;
}

function serializeObject(
  buffer: Uint8Array,
  key: string,
  value: Document,
  inde***REMOVED***: number,
  checkKeys: boolean,
  depth: number,
  serializeFunctions: boolean,
  ignoreUndefined: boolean,
  path: Set<Document>
) {
  if (path.has(value)) {
    throw new BSONError('Cannot convert circular structure to BSON');
  }

  path.add(value);

  // Write the type
  buffer[inde***REMOVED***++] = Array.isArray(value) ? constants.BSON_DATA_ARRAY : constants.BSON_DATA_OBJECT;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, inde***REMOVED***);
  // Encode the name
  inde***REMOVED*** = inde***REMOVED*** + numberOfWrittenBytes;
  buffer[inde***REMOVED***++] = 0;
  const endInde***REMOVED*** = serializeInto(
    buffer,
    value,
    checkKeys,
    inde***REMOVED***,
    depth + 1,
    serializeFunctions,
    ignoreUndefined,
    path
  );

  path.delete(value);

  return endInde***REMOVED***;
}

function serializeDecimal128(buffer: Uint8Array, key: string, value: Decimal128, inde***REMOVED***: number) {
  buffer[inde***REMOVED***++] = constants.BSON_DATA_DECIMAL128;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, inde***REMOVED***);
  // Encode the name
  inde***REMOVED*** = inde***REMOVED*** + numberOfWrittenBytes;
  buffer[inde***REMOVED***++] = 0;
  // Write the data from the value
  for (let i = 0; i < 16; i++) buffer[inde***REMOVED*** + i] = value.bytes[i];
  return inde***REMOVED*** + 16;
}

function serializeLong(buffer: Uint8Array, key: string, value: Long, inde***REMOVED***: number) {
  // Write the type
  buffer[inde***REMOVED***++] =
    value._bsontype === 'Long' ? constants.BSON_DATA_LONG : constants.BSON_DATA_TIMESTAMP;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, inde***REMOVED***);
  // Encode the name
  inde***REMOVED*** = inde***REMOVED*** + numberOfWrittenBytes;
  buffer[inde***REMOVED***++] = 0;
  // Write the date
  const lowBits = value.getLowBits();
  const highBits = value.getHighBits();
  // Encode low bits
  inde***REMOVED*** += NumberUtils.setInt32LE(buffer, inde***REMOVED***, lowBits);
  // Encode high bits
  inde***REMOVED*** += NumberUtils.setInt32LE(buffer, inde***REMOVED***, highBits);
  return inde***REMOVED***;
}

function serializeInt32(buffer: Uint8Array, key: string, value: Int32 | number, inde***REMOVED***: number) {
  value = value.valueOf();
  // Set int type 32 bits or less
  buffer[inde***REMOVED***++] = constants.BSON_DATA_INT;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, inde***REMOVED***);
  // Encode the name
  inde***REMOVED*** = inde***REMOVED*** + numberOfWrittenBytes;
  buffer[inde***REMOVED***++] = 0;
  // Write the int value
  inde***REMOVED*** += NumberUtils.setInt32LE(buffer, inde***REMOVED***, value);
  return inde***REMOVED***;
}

function serializeDouble(buffer: Uint8Array, key: string, value: Double, inde***REMOVED***: number) {
  // Encode as double
  buffer[inde***REMOVED***++] = constants.BSON_DATA_NUMBER;

  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, inde***REMOVED***);

  // Encode the name
  inde***REMOVED*** = inde***REMOVED*** + numberOfWrittenBytes;
  buffer[inde***REMOVED***++] = 0;

  // Write float
  inde***REMOVED*** += NumberUtils.setFloat64LE(buffer, inde***REMOVED***, value.value);

  return inde***REMOVED***;
}

function serializeFunction(buffer: Uint8Array, key: string, value: Function, inde***REMOVED***: number) {
  buffer[inde***REMOVED***++] = constants.BSON_DATA_CODE;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, inde***REMOVED***);
  // Encode the name
  inde***REMOVED*** = inde***REMOVED*** + numberOfWrittenBytes;
  buffer[inde***REMOVED***++] = 0;
  // Function string
  const functionString = value.toString();

  // Write the string
  const size = ByteUtils.encodeUTF8Into(buffer, functionString, inde***REMOVED*** + 4) + 1;
  // Write the size of the string to buffer
  NumberUtils.setInt32LE(buffer, inde***REMOVED***, size);
  // Update inde***REMOVED***
  inde***REMOVED*** = inde***REMOVED*** + 4 + size - 1;
  // Write zero
  buffer[inde***REMOVED***++] = 0;
  return inde***REMOVED***;
}

function serializeCode(
  buffer: Uint8Array,
  key: string,
  value: Code,
  inde***REMOVED***: number,
  checkKeys = false,
  depth = 0,
  serializeFunctions = false,
  ignoreUndefined = true,
  path: Set<Document>
) {
  if (value.scope && typeof value.scope === 'object') {
    // Write the type
    buffer[inde***REMOVED***++] = constants.BSON_DATA_CODE_W_SCOPE;
    // Number of written bytes
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, inde***REMOVED***);
    // Encode the name
    inde***REMOVED*** = inde***REMOVED*** + numberOfWrittenBytes;
    buffer[inde***REMOVED***++] = 0;

    // Starting inde***REMOVED***
    let startInde***REMOVED*** = inde***REMOVED***;

    // Serialize the function
    // Get the function string
    const functionString = value.code;
    // Inde***REMOVED*** adjustment
    inde***REMOVED*** = inde***REMOVED*** + 4;
    // Write string into buffer
    const codeSize = ByteUtils.encodeUTF8Into(buffer, functionString, inde***REMOVED*** + 4) + 1;
    // Write the size of the string to buffer
    NumberUtils.setInt32LE(buffer, inde***REMOVED***, codeSize);
    // Write end 0
    buffer[inde***REMOVED*** + 4 + codeSize - 1] = 0;
    // Write the
    inde***REMOVED*** = inde***REMOVED*** + codeSize + 4;

    // Serialize the scope value
    const endInde***REMOVED*** = serializeInto(
      buffer,
      value.scope,
      checkKeys,
      inde***REMOVED***,
      depth + 1,
      serializeFunctions,
      ignoreUndefined,
      path
    );
    inde***REMOVED*** = endInde***REMOVED*** - 1;

    // Writ the total
    const totalSize = endInde***REMOVED*** - startInde***REMOVED***;

    // Write the total size of the object
    startInde***REMOVED*** += NumberUtils.setInt32LE(buffer, startInde***REMOVED***, totalSize);
    // Write trailing zero
    buffer[inde***REMOVED***++] = 0;
  } else {
    buffer[inde***REMOVED***++] = constants.BSON_DATA_CODE;
    // Number of written bytes
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, inde***REMOVED***);
    // Encode the name
    inde***REMOVED*** = inde***REMOVED*** + numberOfWrittenBytes;
    buffer[inde***REMOVED***++] = 0;
    // Function string
    const functionString = value.code.toString();
    // Write the string
    const size = ByteUtils.encodeUTF8Into(buffer, functionString, inde***REMOVED*** + 4) + 1;
    // Write the size of the string to buffer
    NumberUtils.setInt32LE(buffer, inde***REMOVED***, size);
    // Update inde***REMOVED***
    inde***REMOVED*** = inde***REMOVED*** + 4 + size - 1;
    // Write zero
    buffer[inde***REMOVED***++] = 0;
  }

  return inde***REMOVED***;
}

function serializeBinary(buffer: Uint8Array, key: string, value: Binary, inde***REMOVED***: number) {
  // Write the type
  buffer[inde***REMOVED***++] = constants.BSON_DATA_BINARY;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, inde***REMOVED***);
  // Encode the name
  inde***REMOVED*** = inde***REMOVED*** + numberOfWrittenBytes;
  buffer[inde***REMOVED***++] = 0;
  // E***REMOVED***tract the buffer
  const data = value.buffer;
  // Calculate size
  let size = value.position;
  // Add the deprecated 02 type 4 bytes of size to total
  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) size = size + 4;
  // Write the size of the string to buffer
  inde***REMOVED*** += NumberUtils.setInt32LE(buffer, inde***REMOVED***, size);
  // Write the subtype to the buffer
  buffer[inde***REMOVED***++] = value.sub_type;

  // If we have binary type 2 the 4 first bytes are the size
  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
    size = size - 4;
    inde***REMOVED*** += NumberUtils.setInt32LE(buffer, inde***REMOVED***, size);
  }

  if (size <= 16) {
    for (let i = 0; i < size; i++) buffer[inde***REMOVED*** + i] = data[i];
  } else {
    buffer.set(data, inde***REMOVED***);
  }
  // Adjust the inde***REMOVED***
  inde***REMOVED*** = inde***REMOVED*** + value.position;
  return inde***REMOVED***;
}

function serializeSymbol(buffer: Uint8Array, key: string, value: BSONSymbol, inde***REMOVED***: number) {
  // Write the type
  buffer[inde***REMOVED***++] = constants.BSON_DATA_SYMBOL;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, inde***REMOVED***);
  // Encode the name
  inde***REMOVED*** = inde***REMOVED*** + numberOfWrittenBytes;
  buffer[inde***REMOVED***++] = 0;
  // Write the string
  const size = ByteUtils.encodeUTF8Into(buffer, value.value, inde***REMOVED*** + 4) + 1;
  // Write the size of the string to buffer
  NumberUtils.setInt32LE(buffer, inde***REMOVED***, size);
  // Update inde***REMOVED***
  inde***REMOVED*** = inde***REMOVED*** + 4 + size - 1;
  // Write zero
  buffer[inde***REMOVED***++] = 0;
  return inde***REMOVED***;
}

function serializeDBRef(
  buffer: Uint8Array,
  key: string,
  value: DBRef,
  inde***REMOVED***: number,
  depth: number,
  serializeFunctions: boolean,
  path: Set<Document>
) {
  // Write the type
  buffer[inde***REMOVED***++] = constants.BSON_DATA_OBJECT;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, inde***REMOVED***);

  // Encode the name
  inde***REMOVED*** = inde***REMOVED*** + numberOfWrittenBytes;
  buffer[inde***REMOVED***++] = 0;

  let startInde***REMOVED*** = inde***REMOVED***;
  let output: DBRefLike = {
    $ref: value.collection || value.namespace, // "namespace" was what library 1.***REMOVED*** called "collection"
    $id: value.oid
  };

  if (value.db != null) {
    output.$db = value.db;
  }

  output = Object.assign(output, value.fields);
  const endInde***REMOVED*** = serializeInto(
    buffer,
    output,
    false,
    inde***REMOVED***,
    depth + 1,
    serializeFunctions,
    true,
    path
  );

  // Calculate object size
  const size = endInde***REMOVED*** - startInde***REMOVED***;
  // Write the size
  startInde***REMOVED*** += NumberUtils.setInt32LE(buffer, inde***REMOVED***, size);
  // Set inde***REMOVED***
  return endInde***REMOVED***;
}

e***REMOVED***port function serializeInto(
  buffer: Uint8Array,
  object: Document,
  checkKeys: boolean,
  startingInde***REMOVED***: number,
  depth: number,
  serializeFunctions: boolean,
  ignoreUndefined: boolean,
  path: Set<Document> | null
): number {
  if (path == null) {
    // We are at the root input
    if (object == null) {
      // ONLY the root should turn into an empty document
      // BSON Empty document has a size of 5 (LE)
      buffer[0] = 0***REMOVED***05;
      buffer[1] = 0***REMOVED***00;
      buffer[2] = 0***REMOVED***00;
      buffer[3] = 0***REMOVED***00;
      // All documents end with null terminator
      buffer[4] = 0***REMOVED***00;
      return 5;
    }

    if (Array.isArray(object)) {
      throw new BSONError('serialize does not support an array as the root input');
    }
    if (typeof object !== 'object') {
      throw new BSONError('serialize does not support non-object as the root input');
    } else if ('_bsontype' in object && typeof object._bsontype === 'string') {
      throw new BSONError(`BSON types cannot be serialized as a document`);
    } else if (
      isDate(object) ||
      isRegE***REMOVED***p(object) ||
      isUint8Array(object) ||
      isAnyArrayBuffer(object)
    ) {
      throw new BSONError(`date, rege***REMOVED***p, typedarray, and arraybuffer cannot be BSON documents`);
    }

    path = new Set();
  }

  // Push the object to the path
  path.add(object);

  // Start place to serialize into
  let inde***REMOVED*** = startingInde***REMOVED*** + 4;

  // Special case isArray
  if (Array.isArray(object)) {
    // Get object keys
    for (let i = 0; i < object.length; i++) {
      const key = `${i}`;
      let value = object[i];

      // Is there an override value
      if (typeof value?.toBSON === 'function') {
        value = value.toBSON();
      }

      // Check the type of the value
      const type = typeof value;

      if (value === undefined) {
        inde***REMOVED*** = serializeNull(buffer, key, value, inde***REMOVED***);
      } else if (value === null) {
        inde***REMOVED*** = serializeNull(buffer, key, value, inde***REMOVED***);
      } else if (type === 'string') {
        inde***REMOVED*** = serializeString(buffer, key, value, inde***REMOVED***);
      } else if (type === 'number') {
        inde***REMOVED*** = serializeNumber(buffer, key, value, inde***REMOVED***);
      } else if (type === 'bigint') {
        inde***REMOVED*** = serializeBigInt(buffer, key, value, inde***REMOVED***);
      } else if (type === 'boolean') {
        inde***REMOVED*** = serializeBoolean(buffer, key, value, inde***REMOVED***);
      } else if (type === 'object' && value._bsontype == null) {
        if (value instanceof Date || isDate(value)) {
          inde***REMOVED*** = serializeDate(buffer, key, value, inde***REMOVED***);
        } else if (value instanceof Uint8Array || isUint8Array(value)) {
          inde***REMOVED*** = serializeBuffer(buffer, key, value, inde***REMOVED***);
        } else if (value instanceof RegE***REMOVED***p || isRegE***REMOVED***p(value)) {
          inde***REMOVED*** = serializeRegE***REMOVED***p(buffer, key, value, inde***REMOVED***);
        } else {
          inde***REMOVED*** = serializeObject(
            buffer,
            key,
            value,
            inde***REMOVED***,
            checkKeys,
            depth,
            serializeFunctions,
            ignoreUndefined,
            path
          );
        }
      } else if (type === 'object') {
        if (value[constants.BSON_VERSION_SYMBOL] !== constants.BSON_MAJOR_VERSION) {
          throw new BSONVersionError();
        } else if (value._bsontype === 'ObjectId') {
          inde***REMOVED*** = serializeObjectId(buffer, key, value, inde***REMOVED***);
        } else if (value._bsontype === 'Decimal128') {
          inde***REMOVED*** = serializeDecimal128(buffer, key, value, inde***REMOVED***);
        } else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {
          inde***REMOVED*** = serializeLong(buffer, key, value, inde***REMOVED***);
        } else if (value._bsontype === 'Double') {
          inde***REMOVED*** = serializeDouble(buffer, key, value, inde***REMOVED***);
        } else if (value._bsontype === 'Code') {
          inde***REMOVED*** = serializeCode(
            buffer,
            key,
            value,
            inde***REMOVED***,
            checkKeys,
            depth,
            serializeFunctions,
            ignoreUndefined,
            path
          );
        } else if (value._bsontype === 'Binary') {
          inde***REMOVED*** = serializeBinary(buffer, key, value, inde***REMOVED***);
        } else if (value._bsontype === 'BSONSymbol') {
          inde***REMOVED*** = serializeSymbol(buffer, key, value, inde***REMOVED***);
        } else if (value._bsontype === 'DBRef') {
          inde***REMOVED*** = serializeDBRef(buffer, key, value, inde***REMOVED***, depth, serializeFunctions, path);
        } else if (value._bsontype === 'BSONRegE***REMOVED***p') {
          inde***REMOVED*** = serializeBSONRegE***REMOVED***p(buffer, key, value, inde***REMOVED***);
        } else if (value._bsontype === 'Int32') {
          inde***REMOVED*** = serializeInt32(buffer, key, value, inde***REMOVED***);
        } else if (value._bsontype === 'MinKey' || value._bsontype === 'Ma***REMOVED***Key') {
          inde***REMOVED*** = serializeMinMa***REMOVED***(buffer, key, value, inde***REMOVED***);
        } else if (typeof value._bsontype !== 'undefined') {
          throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
        }
      } else if (type === 'function' && serializeFunctions) {
        inde***REMOVED*** = serializeFunction(buffer, key, value, inde***REMOVED***);
      }
    }
  } else if (object instanceof Map || isMap(object)) {
    const iterator = object.entries();
    let done = false;

    while (!done) {
      // Unpack the ne***REMOVED***t entry
      const entry = iterator.ne***REMOVED***t();
      done = !!entry.done;
      // Are we done, then skip and terminate
      if (done) continue;

      // Get the entry values
      const key = entry.value[0];
      let value = entry.value[1];

      if (typeof value?.toBSON === 'function') {
        value = value.toBSON();
      }

      // Check the type of the value
      const type = typeof value;

      // Check the key and throw error if it's illegal
      if (typeof key === 'string' && !ignoreKeys.has(key)) {
        if (key.match(rege***REMOVED***p) != null) {
          // The BSON spec doesn't allow keys with null bytes because keys are
          // null-terminated.
          throw new BSONError('key ' + key + ' must not contain null bytes');
        }

        if (checkKeys) {
          if ('$' === key[0]) {
            throw new BSONError('key ' + key + " must not start with '$'");
          } else if (key.includes('.')) {
            throw new BSONError('key ' + key + " must not contain '.'");
          }
        }
      }

      if (value === undefined) {
        if (ignoreUndefined === false) inde***REMOVED*** = serializeNull(buffer, key, value, inde***REMOVED***);
      } else if (value === null) {
        inde***REMOVED*** = serializeNull(buffer, key, value, inde***REMOVED***);
      } else if (type === 'string') {
        inde***REMOVED*** = serializeString(buffer, key, value, inde***REMOVED***);
      } else if (type === 'number') {
        inde***REMOVED*** = serializeNumber(buffer, key, value, inde***REMOVED***);
      } else if (type === 'bigint') {
        inde***REMOVED*** = serializeBigInt(buffer, key, value, inde***REMOVED***);
      } else if (type === 'boolean') {
        inde***REMOVED*** = serializeBoolean(buffer, key, value, inde***REMOVED***);
      } else if (type === 'object' && value._bsontype == null) {
        if (value instanceof Date || isDate(value)) {
          inde***REMOVED*** = serializeDate(buffer, key, value, inde***REMOVED***);
        } else if (value instanceof Uint8Array || isUint8Array(value)) {
          inde***REMOVED*** = serializeBuffer(buffer, key, value, inde***REMOVED***);
        } else if (value instanceof RegE***REMOVED***p || isRegE***REMOVED***p(value)) {
          inde***REMOVED*** = serializeRegE***REMOVED***p(buffer, key, value, inde***REMOVED***);
        } else {
          inde***REMOVED*** = serializeObject(
            buffer,
            key,
            value,
            inde***REMOVED***,
            checkKeys,
            depth,
            serializeFunctions,
            ignoreUndefined,
            path
          );
        }
      } else if (type === 'object') {
        if (value[constants.BSON_VERSION_SYMBOL] !== constants.BSON_MAJOR_VERSION) {
          throw new BSONVersionError();
        } else if (value._bsontype === 'ObjectId') {
          inde***REMOVED*** = serializeObjectId(buffer, key, value, inde***REMOVED***);
        } else if (value._bsontype === 'Decimal128') {
          inde***REMOVED*** = serializeDecimal128(buffer, key, value, inde***REMOVED***);
        } else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {
          inde***REMOVED*** = serializeLong(buffer, key, value, inde***REMOVED***);
        } else if (value._bsontype === 'Double') {
          inde***REMOVED*** = serializeDouble(buffer, key, value, inde***REMOVED***);
        } else if (value._bsontype === 'Code') {
          inde***REMOVED*** = serializeCode(
            buffer,
            key,
            value,
            inde***REMOVED***,
            checkKeys,
            depth,
            serializeFunctions,
            ignoreUndefined,
            path
          );
        } else if (value._bsontype === 'Binary') {
          inde***REMOVED*** = serializeBinary(buffer, key, value, inde***REMOVED***);
        } else if (value._bsontype === 'BSONSymbol') {
          inde***REMOVED*** = serializeSymbol(buffer, key, value, inde***REMOVED***);
        } else if (value._bsontype === 'DBRef') {
          inde***REMOVED*** = serializeDBRef(buffer, key, value, inde***REMOVED***, depth, serializeFunctions, path);
        } else if (value._bsontype === 'BSONRegE***REMOVED***p') {
          inde***REMOVED*** = serializeBSONRegE***REMOVED***p(buffer, key, value, inde***REMOVED***);
        } else if (value._bsontype === 'Int32') {
          inde***REMOVED*** = serializeInt32(buffer, key, value, inde***REMOVED***);
        } else if (value._bsontype === 'MinKey' || value._bsontype === 'Ma***REMOVED***Key') {
          inde***REMOVED*** = serializeMinMa***REMOVED***(buffer, key, value, inde***REMOVED***);
        } else if (typeof value._bsontype !== 'undefined') {
          throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
        }
      } else if (type === 'function' && serializeFunctions) {
        inde***REMOVED*** = serializeFunction(buffer, key, value, inde***REMOVED***);
      }
    }
  } else {
    if (typeof object?.toBSON === 'function') {
      // Provided a custom serialization method
      object = object.toBSON();
      if (object != null && typeof object !== 'object') {
        throw new BSONError('toBSON function did not return an object');
      }
    }

    // Iterate over all the keys
    for (const key of Object.keys(object)) {
      let value = object[key];
      // Is there an override value
      if (typeof value?.toBSON === 'function') {
        value = value.toBSON();
      }

      // Check the type of the value
      const type = typeof value;

      // Check the key and throw error if it's illegal
      if (typeof key === 'string' && !ignoreKeys.has(key)) {
        if (key.match(rege***REMOVED***p) != null) {
          // The BSON spec doesn't allow keys with null bytes because keys are
          // null-terminated.
          throw new BSONError('key ' + key + ' must not contain null bytes');
        }

        if (checkKeys) {
          if ('$' === key[0]) {
            throw new BSONError('key ' + key + " must not start with '$'");
          } else if (key.includes('.')) {
            throw new BSONError('key ' + key + " must not contain '.'");
          }
        }
      }

      if (value === undefined) {
        if (ignoreUndefined === false) inde***REMOVED*** = serializeNull(buffer, key, value, inde***REMOVED***);
      } else if (value === null) {
        inde***REMOVED*** = serializeNull(buffer, key, value, inde***REMOVED***);
      } else if (type === 'string') {
        inde***REMOVED*** = serializeString(buffer, key, value, inde***REMOVED***);
      } else if (type === 'number') {
        inde***REMOVED*** = serializeNumber(buffer, key, value, inde***REMOVED***);
      } else if (type === 'bigint') {
        inde***REMOVED*** = serializeBigInt(buffer, key, value, inde***REMOVED***);
      } else if (type === 'boolean') {
        inde***REMOVED*** = serializeBoolean(buffer, key, value, inde***REMOVED***);
      } else if (type === 'object' && value._bsontype == null) {
        if (value instanceof Date || isDate(value)) {
          inde***REMOVED*** = serializeDate(buffer, key, value, inde***REMOVED***);
        } else if (value instanceof Uint8Array || isUint8Array(value)) {
          inde***REMOVED*** = serializeBuffer(buffer, key, value, inde***REMOVED***);
        } else if (value instanceof RegE***REMOVED***p || isRegE***REMOVED***p(value)) {
          inde***REMOVED*** = serializeRegE***REMOVED***p(buffer, key, value, inde***REMOVED***);
        } else {
          inde***REMOVED*** = serializeObject(
            buffer,
            key,
            value,
            inde***REMOVED***,
            checkKeys,
            depth,
            serializeFunctions,
            ignoreUndefined,
            path
          );
        }
      } else if (type === 'object') {
        if (value[constants.BSON_VERSION_SYMBOL] !== constants.BSON_MAJOR_VERSION) {
          throw new BSONVersionError();
        } else if (value._bsontype === 'ObjectId') {
          inde***REMOVED*** = serializeObjectId(buffer, key, value, inde***REMOVED***);
        } else if (value._bsontype === 'Decimal128') {
          inde***REMOVED*** = serializeDecimal128(buffer, key, value, inde***REMOVED***);
        } else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {
          inde***REMOVED*** = serializeLong(buffer, key, value, inde***REMOVED***);
        } else if (value._bsontype === 'Double') {
          inde***REMOVED*** = serializeDouble(buffer, key, value, inde***REMOVED***);
        } else if (value._bsontype === 'Code') {
          inde***REMOVED*** = serializeCode(
            buffer,
            key,
            value,
            inde***REMOVED***,
            checkKeys,
            depth,
            serializeFunctions,
            ignoreUndefined,
            path
          );
        } else if (value._bsontype === 'Binary') {
          inde***REMOVED*** = serializeBinary(buffer, key, value, inde***REMOVED***);
        } else if (value._bsontype === 'BSONSymbol') {
          inde***REMOVED*** = serializeSymbol(buffer, key, value, inde***REMOVED***);
        } else if (value._bsontype === 'DBRef') {
          inde***REMOVED*** = serializeDBRef(buffer, key, value, inde***REMOVED***, depth, serializeFunctions, path);
        } else if (value._bsontype === 'BSONRegE***REMOVED***p') {
          inde***REMOVED*** = serializeBSONRegE***REMOVED***p(buffer, key, value, inde***REMOVED***);
        } else if (value._bsontype === 'Int32') {
          inde***REMOVED*** = serializeInt32(buffer, key, value, inde***REMOVED***);
        } else if (value._bsontype === 'MinKey' || value._bsontype === 'Ma***REMOVED***Key') {
          inde***REMOVED*** = serializeMinMa***REMOVED***(buffer, key, value, inde***REMOVED***);
        } else if (typeof value._bsontype !== 'undefined') {
          throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
        }
      } else if (type === 'function' && serializeFunctions) {
        inde***REMOVED*** = serializeFunction(buffer, key, value, inde***REMOVED***);
      }
    }
  }

  // Remove the path
  path.delete(object);

  // Final padding byte for object
  buffer[inde***REMOVED***++] = 0***REMOVED***00;

  // Final size
  const size = inde***REMOVED*** - startingInde***REMOVED***;
  // Write the size of the object
  startingInde***REMOVED*** += NumberUtils.setInt32LE(buffer, startingInde***REMOVED***, size);
  return inde***REMOVED***;
}
