# braces [![Donate](https://img.shields.io/badge/Donate-PayPal-green.svg)](https://www.paypal.com/cgi-bin/webscr?cmd=_s-***REMOVED***click&hosted_button_id=W8YFZ425KND68) [![NPM version](https://img.shields.io/npm/v/braces.svg?style=flat)](https://www.npmjs.com/package/braces) [![NPM monthly downloads](https://img.shields.io/npm/dm/braces.svg?style=flat)](https://npmjs.org/package/braces) [![NPM total downloads](https://img.shields.io/npm/dt/braces.svg?style=flat)](https://npmjs.org/package/braces) [![Linu***REMOVED*** Build Status](https://img.shields.io/travis/micromatch/braces.svg?style=flat&label=Travis)](https://travis-ci.org/micromatch/braces)

> Bash-like brace e***REMOVED***pansion, implemented in JavaScript. Safer than other brace e***REMOVED***pansion libs, with complete support for the Bash 4.3 braces specification, without sacrificing speed.

Please consider following this project's author, [Jon Schlinkert](https://github.com/jonschlinkert), and consider starring the project to show your :heart: and support.

## Install

Install with [npm](https://www.npmjs.com/):

```sh
$ npm install --save braces
```

## v3.0.0 Released!!

See the [changelog](CHANGELOG.md) for details.

## Why use braces?

Brace patterns make globs more powerful by adding the ability to match specific ranges and sequences of characters.

- **Accurate** - complete support for the [Bash 4.3 Brace E***REMOVED***pansion](www.gnu.org/software/bash/) specification (passes all of the Bash braces tests)
- **[fast and performant](#benchmarks)** - Starts fast, runs fast and [scales well](#performance) as patterns increase in comple***REMOVED***ity.
- **Organized code base** - The parser and compiler are easy to maintain and update when edge cases crop up.
- **Well-tested** - Thousands of test assertions, and passes all of the Bash, minimatch, and [brace-e***REMOVED***pansion](https://github.com/juliangruber/brace-e***REMOVED***pansion) unit tests (as of the date this was written).
- **Safer** - You shouldn't have to worry about users defining aggressive or malicious brace patterns that can break your application. Braces takes measures to prevent malicious rege***REMOVED*** that can be used for DDoS attacks (see [catastrophic backtracking](https://www.regular-e***REMOVED***pressions.info/catastrophic.html)).
- [Supports lists](#lists) - (aka "sets") `a/{b,c}/d` => `['a/b/d', 'a/c/d']`
- [Supports sequences](#sequences) - (aka "ranges") `{01..03}` => `['01', '02', '03']`
- [Supports steps](#steps) - (aka "increments") `{2..10..2}` => `['2', '4', '6', '8', '10']`
- [Supports escaping](#escaping) - To prevent evaluation of special characters.

## Usage

The main e***REMOVED***port is a function that takes one or more brace `patterns` and `options`.

```js
const braces = require('braces');
// braces(patterns[, options]);

console.log(braces(['{01..05}', '{a..e}']));
//=> ['(0[1-5])', '([a-e])']

console.log(braces(['{01..05}', '{a..e}'], { e***REMOVED***pand: true }));
//=> ['01', '02', '03', '04', '05', 'a', 'b', 'c', 'd', 'e']
```

### Brace E***REMOVED***pansion vs. Compilation

By default, brace patterns are compiled into strings that are optimized for creating regular e***REMOVED***pressions and matching.

**Compiled**

```js
console.log(braces('a/{***REMOVED***,y,z}/b'));
//=> ['a/(***REMOVED***|y|z)/b']
console.log(braces(['a/{01..20}/b', 'a/{1..5}/b']));
//=> [ 'a/(0[1-9]|1[0-9]|20)/b', 'a/([1-5])/b' ]
```

**E***REMOVED***panded**

Enable brace e***REMOVED***pansion by setting the `e***REMOVED***pand` option to true, or by using [braces.e***REMOVED***pand()](#e***REMOVED***pand) (returns an array similar to what you'd e***REMOVED***pect from Bash, or `echo {1..5}`, or [minimatch](https://github.com/isaacs/minimatch)):

```js
console.log(braces('a/{***REMOVED***,y,z}/b', { e***REMOVED***pand: true }));
//=> ['a/***REMOVED***/b', 'a/y/b', 'a/z/b']

console.log(braces.e***REMOVED***pand('{01..10}'));
//=> ['01','02','03','04','05','06','07','08','09','10']
```

### Lists

E***REMOVED***pand lists (like Bash "sets"):

```js
console.log(braces('a/{foo,bar,baz}/*.js'));
//=> ['a/(foo|bar|baz)/*.js']

console.log(braces.e***REMOVED***pand('a/{foo,bar,baz}/*.js'));
//=> ['a/foo/*.js', 'a/bar/*.js', 'a/baz/*.js']
```

### Sequences

E***REMOVED***pand ranges of characters (like Bash "sequences"):

```js
console.log(braces.e***REMOVED***pand('{1..3}')); // ['1', '2', '3']
console.log(braces.e***REMOVED***pand('a/{1..3}/b')); // ['a/1/b', 'a/2/b', 'a/3/b']
console.log(braces('{a..c}', { e***REMOVED***pand: true })); // ['a', 'b', 'c']
console.log(braces('foo/{a..c}', { e***REMOVED***pand: true })); // ['foo/a', 'foo/b', 'foo/c']

// supports zero-padded ranges
console.log(braces('a/{01..03}/b')); //=> ['a/(0[1-3])/b']
console.log(braces('a/{001..300}/b')); //=> ['a/(0{2}[1-9]|0[1-9][0-9]|[12][0-9]{2}|300)/b']
```

See [fill-range](https://github.com/jonschlinkert/fill-range) for all available range-e***REMOVED***pansion options.

### Steppped ranges

Steps, or increments, may be used with ranges:

```js
console.log(braces.e***REMOVED***pand('{2..10..2}'));
//=> ['2', '4', '6', '8', '10']

console.log(braces('{2..10..2}'));
//=> ['(2|4|6|8|10)']
```

When the [.optimize](#optimize) method is used, or [options.optimize](#optionsoptimize) is set to true, sequences are passed to [to-rege***REMOVED***-range](https://github.com/jonschlinkert/to-rege***REMOVED***-range) for e***REMOVED***pansion.

### Nesting

Brace patterns may be nested. The results of each e***REMOVED***panded string are not sorted, and left to right order is preserved.

**"E***REMOVED***panded" braces**

```js
console.log(braces.e***REMOVED***pand('a{b,c,/{***REMOVED***,y}}/e'));
//=> ['ab/e', 'ac/e', 'a/***REMOVED***/e', 'a/y/e']

console.log(braces.e***REMOVED***pand('a/{***REMOVED***,{1..5},y}/c'));
//=> ['a/***REMOVED***/c', 'a/1/c', 'a/2/c', 'a/3/c', 'a/4/c', 'a/5/c', 'a/y/c']
```

**"Optimized" braces**

```js
console.log(braces('a{b,c,/{***REMOVED***,y}}/e'));
//=> ['a(b|c|/(***REMOVED***|y))/e']

console.log(braces('a/{***REMOVED***,{1..5},y}/c'));
//=> ['a/(***REMOVED***|([1-5])|y)/c']
```

### Escaping

**Escaping braces**

A brace pattern will not be e***REMOVED***panded or evaluted if _either the opening or closing brace is escaped_:

```js
console.log(braces.e***REMOVED***pand('a\\{d,c,b}e'));
//=> ['a{d,c,b}e']

console.log(braces.e***REMOVED***pand('a{d,c,b\\}e'));
//=> ['a{d,c,b}e']
```

**Escaping commas**

Commas inside braces may also be escaped:

```js
console.log(braces.e***REMOVED***pand('a{b\\,c}d'));
//=> ['a{b,c}d']

console.log(braces.e***REMOVED***pand('a{d\\,c,b}e'));
//=> ['ad,ce', 'abe']
```

**Single items**

Following bash conventions, a brace pattern is also not e***REMOVED***panded when it contains a single character:

```js
console.log(braces.e***REMOVED***pand('a{b}c'));
//=> ['a{b}c']
```

## Options

### options.ma***REMOVED***Length

**Type**: `Number`

**Default**: `10,000`

**Description**: Limit the length of the input string. Useful when the input string is generated or your application allows users to pass a string, et cetera.

```js
console.log(braces('a/{b,c}/d', { ma***REMOVED***Length: 3 })); //=> throws an error
```

### options.e***REMOVED***pand

**Type**: `Boolean`

**Default**: `undefined`

**Description**: Generate an "e***REMOVED***panded" brace pattern (alternatively you can use the `braces.e***REMOVED***pand()` method, which does the same thing).

```js
console.log(braces('a/{b,c}/d', { e***REMOVED***pand: true }));
//=> [ 'a/b/d', 'a/c/d' ]
```

### options.nodupes

**Type**: `Boolean`

**Default**: `undefined`

**Description**: Remove duplicates from the returned array.

### options.rangeLimit

**Type**: `Number`

**Default**: `1000`

**Description**: To prevent malicious patterns from being passed by users, an error is thrown when `braces.e***REMOVED***pand()` is used or `options.e***REMOVED***pand` is true and the generated range will e***REMOVED***ceed the `rangeLimit`.

You can customize `options.rangeLimit` or set it to `Inifinity` to disable this altogether.

**E***REMOVED***amples**

```js
// pattern e***REMOVED***ceeds the "rangeLimit", so it's optimized automatically
console.log(braces.e***REMOVED***pand('{1..1000}'));
//=> ['([1-9]|[1-9][0-9]{1,2}|1000)']

// pattern does not e***REMOVED***ceed "rangeLimit", so it's NOT optimized
console.log(braces.e***REMOVED***pand('{1..100}'));
//=> ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '100']
```

### options.transform

**Type**: `Function`

**Default**: `undefined`

**Description**: Customize range e***REMOVED***pansion.

**E***REMOVED***ample: Transforming non-numeric values**

```js
const alpha = braces.e***REMOVED***pand('***REMOVED***/{a..e}/y', {
  transform(value, inde***REMOVED***) {
    // When non-numeric values are passed, "value" is a character code.
    return 'foo/' + String.fromCharCode(value) + '-' + inde***REMOVED***;
  },
});
console.log(alpha);
//=> [ '***REMOVED***/foo/a-0/y', '***REMOVED***/foo/b-1/y', '***REMOVED***/foo/c-2/y', '***REMOVED***/foo/d-3/y', '***REMOVED***/foo/e-4/y' ]
```

**E***REMOVED***ample: Transforming numeric values**

```js
const numeric = braces.e***REMOVED***pand('{1..5}', {
  transform(value) {
    // when numeric values are passed, "value" is a number
    return 'foo/' + value * 2;
  },
});
console.log(numeric);
//=> [ 'foo/2', 'foo/4', 'foo/6', 'foo/8', 'foo/10' ]
```

### options.quantifiers

**Type**: `Boolean`

**Default**: `undefined`

**Description**: In regular e***REMOVED***pressions, quanitifiers can be used to specify how many times a token can be repeated. For e***REMOVED***ample, `a{1,3}` will match the letter `a` one to three times.

Unfortunately, rege***REMOVED*** quantifiers happen to share the same synta***REMOVED*** as [Bash lists](#lists)

The `quantifiers` option tells braces to detect when [rege***REMOVED*** quantifiers](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegE***REMOVED***p#quantifiers) are defined in the given pattern, and not to try to e***REMOVED***pand them as lists.

**E***REMOVED***amples**

```js
const braces = require('braces');
console.log(braces('a/b{1,3}/{***REMOVED***,y,z}'));
//=> [ 'a/b(1|3)/(***REMOVED***|y|z)' ]
console.log(braces('a/b{1,3}/{***REMOVED***,y,z}', { quantifiers: true }));
//=> [ 'a/b{1,3}/(***REMOVED***|y|z)' ]
console.log(braces('a/b{1,3}/{***REMOVED***,y,z}', { quantifiers: true, e***REMOVED***pand: true }));
//=> [ 'a/b{1,3}/***REMOVED***', 'a/b{1,3}/y', 'a/b{1,3}/z' ]
```

### options.keepEscaping

**Type**: `Boolean`

**Default**: `undefined`

**Description**: Do not strip backslashes that were used for escaping from the result.

## What is "brace e***REMOVED***pansion"?

Brace e***REMOVED***pansion is a type of parameter e***REMOVED***pansion that was made popular by uni***REMOVED*** shells for generating lists of strings, as well as rege***REMOVED***-like matching when used alongside wildcards (globs).

In addition to "e***REMOVED***pansion", braces are also used for matching. In other words:

- [brace e***REMOVED***pansion](#brace-e***REMOVED***pansion) is for generating new lists
- [brace matching](#brace-matching) is for filtering e***REMOVED***isting lists

<details>
<summary><strong>More about brace e***REMOVED***pansion</strong> (click to e***REMOVED***pand)</summary>

There are two main types of brace e***REMOVED***pansion:

1. **lists**: which are defined using comma-separated values inside curly braces: `{a,b,c}`
2. **sequences**: which are defined using a starting value and an ending value, separated by two dots: `a{1..3}b`. Optionally, a third argument may be passed to define a "step" or increment to use: `a{1..100..10}b`. These are also sometimes referred to as "ranges".

Here are some e***REMOVED***ample brace patterns to illustrate how they work:

**Sets**

```
{a,b,c}       => a b c
{a,b,c}{1,2}  => a1 a2 b1 b2 c1 c2
```

**Sequences**

```
{1..9}        => 1 2 3 4 5 6 7 8 9
{4..-4}       => 4 3 2 1 0 -1 -2 -3 -4
{1..20..3}    => 1 4 7 10 13 16 19
{a..j}        => a b c d e f g h i j
{j..a}        => j i h g f e d c b a
{a..z..3}     => a d g j m p s v y
```

**Combination**

Sets and sequences can be mi***REMOVED***ed together or used along with any other strings.

```
{a,b,c}{1..3}   => a1 a2 a3 b1 b2 b3 c1 c2 c3
foo/{a,b,c}/bar => foo/a/bar foo/b/bar foo/c/bar
```

The fact that braces can be "e***REMOVED***panded" from relatively simple patterns makes them ideal for quickly generating test fi***REMOVED***tures, file paths, and similar use cases.

## Brace matching

In addition to _e***REMOVED***pansion_, brace patterns are also useful for performing regular-e***REMOVED***pression-like matching.

For e***REMOVED***ample, the pattern `foo/{1..3}/bar` would match any of following strings:

```
foo/1/bar
foo/2/bar
foo/3/bar
```

But not:

```
baz/1/qu***REMOVED***
baz/2/qu***REMOVED***
baz/3/qu***REMOVED***
```

Braces can also be combined with [glob patterns](https://github.com/jonschlinkert/micromatch) to perform more advanced wildcard matching. For e***REMOVED***ample, the pattern `*/{1..3}/*` would match any of following strings:

```
foo/1/bar
foo/2/bar
foo/3/bar
baz/1/qu***REMOVED***
baz/2/qu***REMOVED***
baz/3/qu***REMOVED***
```

## Brace matching pitfalls

Although brace patterns offer a user-friendly way of matching ranges or sets of strings, there are also some major disadvantages and potential risks you should be aware of.

### tldr

**"brace bombs"**

- brace e***REMOVED***pansion can eat up a huge amount of processing resources
- as brace patterns increase _linearly in size_, the system resources required to e***REMOVED***pand the pattern increase e***REMOVED***ponentially
- users can accidentally (or intentially) e***REMOVED***haust your system's resources resulting in the equivalent of a DoS attack (bonus: no programming knowledge is required!)

For a more detailed e***REMOVED***planation with e***REMOVED***amples, see the [geometric comple***REMOVED***ity](#geometric-comple***REMOVED***ity) section.

### The solution

Jump to the [performance section](#performance) to see how Braces solves this problem in comparison to other libraries.

### Geometric comple***REMOVED***ity

At minimum, brace patterns with sets limited to two elements have quadradic or `O(n^2)` comple***REMOVED***ity. But the comple***REMOVED***ity of the algorithm increases e***REMOVED***ponentially as the number of sets, _and elements per set_, increases, which is `O(n^c)`.

For e***REMOVED***ample, the following sets demonstrate quadratic (`O(n^2)`) comple***REMOVED***ity:

```
{1,2}{3,4}      => (2X2)    => 13 14 23 24
{1,2}{3,4}{5,6} => (2X2X2)  => 135 136 145 146 235 236 245 246
```

But add an element to a set, and we get a n-fold Cartesian product with `O(n^c)` comple***REMOVED***ity:

```
{1,2,3}{4,5,6}{7,8,9} => (3X3X3) => 147 148 149 157 158 159 167 168 169 247 248
                                    249 257 258 259 267 268 269 347 348 349 357
                                    358 359 367 368 369
```

Now, imagine how this comple***REMOVED***ity grows given that each element is a n-tuple:

```
{1..100}{1..100}         => (100X100)     => 10,000 elements (38.4 kB)
{1..100}{1..100}{1..100} => (100X100X100) => 1,000,000 elements (5.76 MB)
```

Although these e***REMOVED***amples are clearly contrived, they demonstrate how brace patterns can quickly grow out of control.

**More information**

Interested in learning more about brace e***REMOVED***pansion?

- [linu***REMOVED***journal/bash-brace-e***REMOVED***pansion](http://www.linu***REMOVED***journal.com/content/bash-brace-e***REMOVED***pansion)
- [rosettacode/Brace_e***REMOVED***pansion](https://rosettacode.org/wiki/Brace_e***REMOVED***pansion)
- [cartesian product](https://en.wikipedia.org/wiki/Cartesian_product)

</details>

## Performance

Braces is not only screaming fast, it's also more accurate the other brace e***REMOVED***pansion libraries.

### Better algorithms

Fortunately there is a solution to the ["brace bomb" problem](#brace-matching-pitfalls): _don't e***REMOVED***pand brace patterns into an array when they're used for matching_.

Instead, convert the pattern into an optimized regular e***REMOVED***pression. This is easier said than done, and braces is the only library that does this currently.

**The proof is in the numbers**

Minimatch gets e***REMOVED***ponentially slower as patterns increase in comple***REMOVED***ity, braces does not. The following results were generated using `braces()` and `minimatch.braceE***REMOVED***pand()`, respectively.

| **Pattern**                 | **braces**          | **[minimatch][]**            |
| --------------------------- | ------------------- | ---------------------------- |
| `{1..9007199254740991}`[^1] | `298 B` (5ms 459μs) | N/A (freezes)                |
| `{1..1000000000000000}`     | `41 B` (1ms 15μs)   | N/A (freezes)                |
| `{1..100000000000000}`      | `40 B` (890μs)      | N/A (freezes)                |
| `{1..10000000000000}`       | `39 B` (2ms 49μs)   | N/A (freezes)                |
| `{1..1000000000000}`        | `38 B` (608μs)      | N/A (freezes)                |
| `{1..100000000000}`         | `37 B` (397μs)      | N/A (freezes)                |
| `{1..10000000000}`          | `35 B` (983μs)      | N/A (freezes)                |
| `{1..1000000000}`           | `34 B` (798μs)      | N/A (freezes)                |
| `{1..100000000}`            | `33 B` (733μs)      | N/A (freezes)                |
| `{1..10000000}`             | `32 B` (5ms 632μs)  | `78.89 MB` (16s 388ms 569μs) |
| `{1..1000000}`              | `31 B` (1ms 381μs)  | `6.89 MB` (1s 496ms 887μs)   |
| `{1..100000}`               | `30 B` (950μs)      | `588.89 kB` (146ms 921μs)    |
| `{1..10000}`                | `29 B` (1ms 114μs)  | `48.89 kB` (14ms 187μs)      |
| `{1..1000}`                 | `28 B` (760μs)      | `3.89 kB` (1ms 453μs)        |
| `{1..100}`                  | `22 B` (345μs)      | `291 B` (196μs)              |
| `{1..10}`                   | `10 B` (533μs)      | `20 B` (37μs)                |
| `{1..3}`                    | `7 B` (190μs)       | `5 B` (27μs)                 |

### Faster algorithms

When you need e***REMOVED***pansion, braces is still much faster.

_(the following results were generated using `braces.e***REMOVED***pand()` and `minimatch.braceE***REMOVED***pand()`, respectively)_

| **Pattern**     | **braces**                  | **[minimatch][]**            |
| --------------- | --------------------------- | ---------------------------- |
| `{1..10000000}` | `78.89 MB` (2s 698ms 642μs) | `78.89 MB` (18s 601ms 974μs) |
| `{1..1000000}`  | `6.89 MB` (458ms 576μs)     | `6.89 MB` (1s 491ms 621μs)   |
| `{1..100000}`   | `588.89 kB` (20ms 728μs)    | `588.89 kB` (156ms 919μs)    |
| `{1..10000}`    | `48.89 kB` (2ms 202μs)      | `48.89 kB` (13ms 641μs)      |
| `{1..1000}`     | `3.89 kB` (1ms 796μs)       | `3.89 kB` (1ms 958μs)        |
| `{1..100}`      | `291 B` (424μs)             | `291 B` (211μs)              |
| `{1..10}`       | `20 B` (487μs)              | `20 B` (72μs)                |
| `{1..3}`        | `5 B` (166μs)               | `5 B` (27μs)                 |

If you'd like to run these comparisons yourself, see [test/support/generate.js](test/support/generate.js).

## Benchmarks

### Running benchmarks

Install dev dependencies:

```bash
npm i -d && npm benchmark
```

### Latest results

Braces is more accurate, without sacrificing performance.

```bash
● e***REMOVED***pand - range (e***REMOVED***panded)
     braces ***REMOVED*** 53,167 ops/sec ±0.12% (102 runs sampled)
  minimatch ***REMOVED*** 11,378 ops/sec ±0.10% (102 runs sampled)
● e***REMOVED***pand - range (optimized for rege***REMOVED***)
     braces ***REMOVED*** 373,442 ops/sec ±0.04% (100 runs sampled)
  minimatch ***REMOVED*** 3,262 ops/sec ±0.18% (100 runs sampled)
● e***REMOVED***pand - nested ranges (e***REMOVED***panded)
     braces ***REMOVED*** 33,921 ops/sec ±0.09% (99 runs sampled)
  minimatch ***REMOVED*** 10,855 ops/sec ±0.28% (100 runs sampled)
● e***REMOVED***pand - nested ranges (optimized for rege***REMOVED***)
     braces ***REMOVED*** 287,479 ops/sec ±0.52% (98 runs sampled)
  minimatch ***REMOVED*** 3,219 ops/sec ±0.28% (101 runs sampled)
● e***REMOVED***pand - set (e***REMOVED***panded)
     braces ***REMOVED*** 238,243 ops/sec ±0.19% (97 runs sampled)
  minimatch ***REMOVED*** 538,268 ops/sec ±0.31% (96 runs sampled)
● e***REMOVED***pand - set (optimized for rege***REMOVED***)
     braces ***REMOVED*** 321,844 ops/sec ±0.10% (97 runs sampled)
  minimatch ***REMOVED*** 140,600 ops/sec ±0.15% (100 runs sampled)
● e***REMOVED***pand - nested sets (e***REMOVED***panded)
     braces ***REMOVED*** 165,371 ops/sec ±0.42% (96 runs sampled)
  minimatch ***REMOVED*** 337,720 ops/sec ±0.28% (100 runs sampled)
● e***REMOVED***pand - nested sets (optimized for rege***REMOVED***)
     braces ***REMOVED*** 242,948 ops/sec ±0.12% (99 runs sampled)
  minimatch ***REMOVED*** 87,403 ops/sec ±0.79% (96 runs sampled)
```

## About

<details>
<summary><strong>Contributing</strong></summary>

Pull requests and stars are always welcome. For bugs and feature requests, [please create an issue](../../issues/new).

</details>

<details>
<summary><strong>Running Tests</strong></summary>

Running and reviewing unit tests is a great way to get familiarized with a library and its API. You can install dependencies and run tests with the following command:

```sh
$ npm install && npm test
```

</details>

<details>
<summary><strong>Building docs</strong></summary>

_(This project's readme.md is generated by [verb](https://github.com/verbose/verb-generate-readme), please don't edit the readme directly. Any changes to the readme must be made in the [.verb.md](.verb.md) readme template.)_

To generate the readme, run the following command:

```sh
$ npm install -g verbose/verb#dev verb-generate-readme && verb
```

</details>

### Contributors

| **Commits** | **Contributor**                                               |
| ----------- | ------------------------------------------------------------- |
| 197         | [jonschlinkert](https://github.com/jonschlinkert)             |
| 4           | [doowb](https://github.com/doowb)                             |
| 1           | [es128](https://github.com/es128)                             |
| 1           | [eush77](https://github.com/eush77)                           |
| 1           | [hemanth](https://github.com/hemanth)                         |
| 1           | [wtgtybhertgeghgtwtg](https://github.com/wtgtybhertgeghgtwtg) |

### Author

**Jon Schlinkert**

- [GitHub Profile](https://github.com/jonschlinkert)
- [Twitter Profile](https://twitter.com/jonschlinkert)
- [LinkedIn Profile](https://linkedin.com/in/jonschlinkert)

### License

Copyright © 2019, [Jon Schlinkert](https://github.com/jonschlinkert).
Released under the [MIT License](LICENSE).

---

_This file was generated by [verb-generate-readme](https://github.com/verbose/verb-generate-readme), v0.8.0, on April 08, 2019._
