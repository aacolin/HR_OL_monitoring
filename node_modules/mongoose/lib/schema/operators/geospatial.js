/*!
 * Module requirements.
 */

'use strict';

const castArraysOfNumbers = require('./helpers').castArraysOfNumbers;
const castToNumber = require('./helpers').castToNumber;

/*!
 * ignore
 */

e***REMOVED***ports.cast$geoIntersects = cast$geoIntersects;
e***REMOVED***ports.cast$near = cast$near;
e***REMOVED***ports.cast$within = cast$within;

function cast$near(val) {
  const SchemaArray = require('../array');

  if (Array.isArray(val)) {
    castArraysOfNumbers(val, this);
    return val;
  }

  _castMinMa***REMOVED***Distance(this, val);

  if (val && val.$geometry) {
    return cast$geometry(val, this);
  }

  if (!Array.isArray(val)) {
    throw new TypeError('$near must be either an array or an object ' +
      'with a $geometry property');
  }

  return SchemaArray.prototype.castForQuery.call(this, null, val);
}

function cast$geometry(val, self) {
  switch (val.$geometry.type) {
    case 'Polygon':
    case 'LineString':
    case 'Point':
      castArraysOfNumbers(val.$geometry.coordinates, self);
      break;
    default:
      // ignore unknowns
      break;
  }

  _castMinMa***REMOVED***Distance(self, val);

  return val;
}

function cast$within(val) {
  _castMinMa***REMOVED***Distance(this, val);

  if (val.$bo***REMOVED*** || val.$polygon) {
    const type = val.$bo***REMOVED*** ? '$bo***REMOVED***' : '$polygon';
    val[type].forEach(arr => {
      if (!Array.isArray(arr)) {
        const msg = 'Invalid $within $bo***REMOVED*** argument. '
            + 'E***REMOVED***pected an array, received ' + arr;
        throw new TypeError(msg);
      }
      arr.forEach((v, i) => {
        arr[i] = castToNumber.call(this, v);
      });
    });
  } else if (val.$center || val.$centerSphere) {
    const type = val.$center ? '$center' : '$centerSphere';
    val[type].forEach((item, i) => {
      if (Array.isArray(item)) {
        item.forEach((v, j) => {
          item[j] = castToNumber.call(this, v);
        });
      } else {
        val[type][i] = castToNumber.call(this, item);
      }
    });
  } else if (val.$geometry) {
    cast$geometry(val, this);
  }

  return val;
}

function cast$geoIntersects(val) {
  const geo = val.$geometry;
  if (!geo) {
    return;
  }

  cast$geometry(val, this);
  return val;
}

function _castMinMa***REMOVED***Distance(self, val) {
  if (val.$ma***REMOVED***Distance) {
    val.$ma***REMOVED***Distance = castToNumber.call(self, val.$ma***REMOVED***Distance);
  }
  if (val.$minDistance) {
    val.$minDistance = castToNumber.call(self, val.$minDistance);
  }
}
