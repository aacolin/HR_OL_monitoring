'use strict';

const get = require('../get');
const utils = require('../../utils');
/**
 * Given a Mongoose inde***REMOVED*** definition (key + options objects) and a MongoDB server
 * inde***REMOVED*** definition, determine if the two inde***REMOVED***es are equal.
 *
 * @param {Object} schemaInde***REMOVED***KeysObject the Mongoose inde***REMOVED*** spec
 * @param {Object} options the Mongoose inde***REMOVED*** definition's options
 * @param {Object} dbInde***REMOVED*** the inde***REMOVED*** in MongoDB as returned by `listInde***REMOVED***es()`
 * @api private
 */

module.e***REMOVED***ports = function isInde***REMOVED***Equal(schemaInde***REMOVED***KeysObject, options, dbInde***REMOVED***) {
  // Special case: te***REMOVED***t inde***REMOVED***es have a special format in the db. For e***REMOVED***ample,
  // `{ name: 'te***REMOVED***t' }` becomes:
  // {
  //   v: 2,
  //   key: { _fts: 'te***REMOVED***t', _fts***REMOVED***: 1 },
  //   name: 'name_te***REMOVED***t',
  //   ns: 'test.tests',
  //   background: true,
  //   weights: { name: 1 },
  //   default_language: 'english',
  //   language_override: 'language',
  //   te***REMOVED***tInde***REMOVED***Version: 3
  // }
  if (dbInde***REMOVED***.te***REMOVED***tInde***REMOVED***Version != null) {
    delete dbInde***REMOVED***.key._fts;
    delete dbInde***REMOVED***.key._fts***REMOVED***;
    const weights = { ...dbInde***REMOVED***.weights, ...dbInde***REMOVED***.key };
    if (Object.keys(weights).length !== Object.keys(schemaInde***REMOVED***KeysObject).length) {
      return false;
    }
    for (const prop of Object.keys(weights)) {
      if (!(prop in schemaInde***REMOVED***KeysObject)) {
        return false;
      }
      const weight = weights[prop];
      if (weight !== get(options, 'weights.' + prop) && !(weight === 1 && get(options, 'weights.' + prop) == null)) {
        return false;
      }
    }

    if (options['default_language'] !== dbInde***REMOVED***['default_language']) {
      return dbInde***REMOVED***['default_language'] === 'english' && options['default_language'] == null;
    }

    return true;
  }

  const optionKeys = [
    'unique',
    'partialFilterE***REMOVED***pression',
    'sparse',
    'e***REMOVED***pireAfterSeconds',
    'collation'
  ];
  for (const key of optionKeys) {
    if (!(key in options) && !(key in dbInde***REMOVED***)) {
      continue;
    }
    if (key === 'collation') {
      if (options[key] == null || dbInde***REMOVED***[key] == null) {
        return options[key] == null && dbInde***REMOVED***[key] == null;
      }
      const definedKeys = Object.keys(options.collation);
      const schemaCollation = options.collation;
      const dbCollation = dbInde***REMOVED***.collation;
      for (const opt of definedKeys) {
        if (get(schemaCollation, opt) !== get(dbCollation, opt)) {
          return false;
        }
      }
    } else if (!utils.deepEqual(options[key], dbInde***REMOVED***[key])) {
      return false;
    }
  }

  const schemaInde***REMOVED***Keys = Object.keys(schemaInde***REMOVED***KeysObject);
  const dbInde***REMOVED***Keys = Object.keys(dbInde***REMOVED***.key);
  if (schemaInde***REMOVED***Keys.length !== dbInde***REMOVED***Keys.length) {
    return false;
  }
  for (let i = 0; i < schemaInde***REMOVED***Keys.length; ++i) {
    if (schemaInde***REMOVED***Keys[i] !== dbInde***REMOVED***Keys[i]) {
      return false;
    }
    if (!utils.deepEqual(schemaInde***REMOVED***KeysObject[schemaInde***REMOVED***Keys[i]], dbInde***REMOVED***.key[dbInde***REMOVED***Keys[i]])) {
      return false;
    }
  }

  return true;
};
