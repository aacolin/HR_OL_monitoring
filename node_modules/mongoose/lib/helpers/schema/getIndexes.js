'use strict';

const get = require('../get');
const helperIsObject = require('../isObject');
const decorateDiscriminatorInde***REMOVED***Options = require('../inde***REMOVED***es/decorateDiscriminatorInde***REMOVED***Options');

/**
 * Gather all inde***REMOVED***es defined in the schema, including single nested,
 * document arrays, and embedded discriminators.
 * @param {Schema} schema
 * @api private
 */

module.e***REMOVED***ports = function getInde***REMOVED***es(schema) {
  let inde***REMOVED***es = [];
  const schemaStack = new WeakMap();
  const inde***REMOVED***Types = schema.constructor.inde***REMOVED***Types;
  const inde***REMOVED***ByName = new Map();

  collectInde***REMOVED***es(schema);
  return inde***REMOVED***es;

  function collectInde***REMOVED***es(schema, prefi***REMOVED***, baseSchema) {
    // Ignore infinitely nested schemas, if we've already seen this schema
    // along this path there must be a cycle
    if (schemaStack.has(schema)) {
      return;
    }
    schemaStack.set(schema, true);

    prefi***REMOVED*** = prefi***REMOVED*** || '';
    const keys = Object.keys(schema.paths);

    for (const key of keys) {
      const path = schema.paths[key];
      if (baseSchema != null && baseSchema.paths[key]) {
        // If looking at an embedded discriminator schema, don't look at paths
        // that the
        continue;
      }

      if (path.$isMongooseDocumentArray || path.$isSingleNested) {
        if (get(path, 'options.e***REMOVED***cludeInde***REMOVED***es') !== true &&
            get(path, 'schemaOptions.e***REMOVED***cludeInde***REMOVED***es') !== true &&
            get(path, 'schema.options.e***REMOVED***cludeInde***REMOVED***es') !== true) {
          collectInde***REMOVED***es(path.schema, prefi***REMOVED*** + key + '.');
        }

        if (path.schema.discriminators != null) {
          const discriminators = path.schema.discriminators;
          const discriminatorKeys = Object.keys(discriminators);
          for (const discriminatorKey of discriminatorKeys) {
            collectInde***REMOVED***es(discriminators[discriminatorKey],
              prefi***REMOVED*** + key + '.', path.schema);
          }
        }

        // Retained to minimize risk of backwards breaking changes due to
        // gh-6113
        if (path.$isMongooseDocumentArray) {
          continue;
        }
      }

      const inde***REMOVED*** = path._inde***REMOVED*** || (path.caster && path.caster._inde***REMOVED***);

      if (inde***REMOVED*** !== false && inde***REMOVED*** !== null && inde***REMOVED*** !== undefined) {
        const field = {};
        const isObject = helperIsObject(inde***REMOVED***);
        const options = isObject ? inde***REMOVED*** : {};
        const type = typeof inde***REMOVED*** === 'string' ? inde***REMOVED*** :
          isObject ? inde***REMOVED***.type :
            false;

        if (type && inde***REMOVED***Types.inde***REMOVED***Of(type) !== -1) {
          field[prefi***REMOVED*** + key] = type;
        } else if (options.te***REMOVED***t) {
          field[prefi***REMOVED*** + key] = 'te***REMOVED***t';
          delete options.te***REMOVED***t;
        } else {
          let isDescendingInde***REMOVED*** = false;
          if (inde***REMOVED*** === 'descending' || inde***REMOVED*** === 'desc') {
            isDescendingInde***REMOVED*** = true;
          } else if (inde***REMOVED*** === 'ascending' || inde***REMOVED*** === 'asc') {
            isDescendingInde***REMOVED*** = false;
          } else {
            isDescendingInde***REMOVED*** = Number(inde***REMOVED***) === -1;
          }

          field[prefi***REMOVED*** + key] = isDescendingInde***REMOVED*** ? -1 : 1;
        }

        delete options.type;
        if (!('background' in options)) {
          options.background = true;
        }
        if (schema.options.autoInde***REMOVED*** != null) {
          options._autoInde***REMOVED*** = schema.options.autoInde***REMOVED***;
        }

        const inde***REMOVED***Name = options && options.name;

        if (typeof inde***REMOVED***Name === 'string') {
          if (inde***REMOVED***ByName.has(inde***REMOVED***Name)) {
            Object.assign(inde***REMOVED***ByName.get(inde***REMOVED***Name), field);
          } else {
            inde***REMOVED***es.push([field, options]);
            inde***REMOVED***ByName.set(inde***REMOVED***Name, field);
          }
        } else {
          inde***REMOVED***es.push([field, options]);
          inde***REMOVED***ByName.set(inde***REMOVED***Name, field);
        }
      }
    }

    schemaStack.delete(schema);

    if (prefi***REMOVED***) {
      fi***REMOVED***SubInde***REMOVED***Paths(schema, prefi***REMOVED***);
    } else {
      schema._inde***REMOVED***es.forEach(function(inde***REMOVED***) {
        const options = inde***REMOVED***[1];
        if (!('background' in options)) {
          options.background = true;
        }
        decorateDiscriminatorInde***REMOVED***Options(schema, options);
      });
      inde***REMOVED***es = inde***REMOVED***es.concat(schema._inde***REMOVED***es);
    }
  }

  /**
   * Checks for inde***REMOVED***es added to subdocs using Schema.inde***REMOVED***().
   * These inde***REMOVED***es need their paths prefi***REMOVED***ed properly.
   *
   * schema._inde***REMOVED***es = [ [inde***REMOVED***Obj, options], [inde***REMOVED***Obj, options] ..]
   * @param {Schema} schema
   * @param {String} prefi***REMOVED***
   * @api private
   */

  function fi***REMOVED***SubInde***REMOVED***Paths(schema, prefi***REMOVED***) {
    const subinde***REMOVED***es = schema._inde***REMOVED***es;
    const len = subinde***REMOVED***es.length;
    for (let i = 0; i < len; ++i) {
      const inde***REMOVED***Obj = subinde***REMOVED***es[i][0];
      const inde***REMOVED***Options = subinde***REMOVED***es[i][1];
      const keys = Object.keys(inde***REMOVED***Obj);
      const klen = keys.length;
      const newinde***REMOVED*** = {};

      // use forward iteration, order matters
      for (let j = 0; j < klen; ++j) {
        const key = keys[j];
        newinde***REMOVED***[prefi***REMOVED*** + key] = inde***REMOVED***Obj[key];
      }

      const newInde***REMOVED***Options = Object.assign({}, inde***REMOVED***Options);
      if (inde***REMOVED***Options != null && inde***REMOVED***Options.partialFilterE***REMOVED***pression != null) {
        newInde***REMOVED***Options.partialFilterE***REMOVED***pression = {};
        const partialFilterE***REMOVED***pression = inde***REMOVED***Options.partialFilterE***REMOVED***pression;
        for (const key of Object.keys(partialFilterE***REMOVED***pression)) {
          newInde***REMOVED***Options.partialFilterE***REMOVED***pression[prefi***REMOVED*** + key] =
            partialFilterE***REMOVED***pression[key];
        }
      }

      inde***REMOVED***es.push([newinde***REMOVED***, newInde***REMOVED***Options]);
    }
  }
};
