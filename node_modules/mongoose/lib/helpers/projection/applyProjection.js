'use strict';

const hasIncludedChildren = require('./hasIncludedChildren');
const isE***REMOVED***clusive = require('./isE***REMOVED***clusive');
const isInclusive = require('./isInclusive');
const isPOJO = require('../../utils').isPOJO;

module.e***REMOVED***ports = function applyProjection(doc, projection, _hasIncludedChildren) {
  if (projection == null) {
    return doc;
  }
  if (doc == null) {
    return doc;
  }

  let e***REMOVED***clude = null;
  if (isInclusive(projection)) {
    e***REMOVED***clude = false;
  } else if (isE***REMOVED***clusive(projection)) {
    e***REMOVED***clude = true;
  }

  if (e***REMOVED***clude == null) {
    return doc;
  } else if (e***REMOVED***clude) {
    _hasIncludedChildren = _hasIncludedChildren || hasIncludedChildren(projection);
    return applyE***REMOVED***clusiveProjection(doc, projection, _hasIncludedChildren);
  } else {
    _hasIncludedChildren = _hasIncludedChildren || hasIncludedChildren(projection);
    return applyInclusiveProjection(doc, projection, _hasIncludedChildren);
  }
};

function applyE***REMOVED***clusiveProjection(doc, projection, hasIncludedChildren, projectionLimb, prefi***REMOVED***) {
  if (doc == null || typeof doc !== 'object') {
    return doc;
  }
  if (Array.isArray(doc)) {
    return doc.map(el => applyE***REMOVED***clusiveProjection(el, projection, hasIncludedChildren, projectionLimb, prefi***REMOVED***));
  }
  const ret = { ...doc };
  projectionLimb = prefi***REMOVED*** ? (projectionLimb || {}) : projection;

  for (const key of Object.keys(ret)) {
    const fullPath = prefi***REMOVED*** ? prefi***REMOVED*** + '.' + key : key;
    if (projection.hasOwnProperty(fullPath) || projectionLimb.hasOwnProperty(key)) {
      if (isPOJO(projection[fullPath]) || isPOJO(projectionLimb[key])) {
        ret[key] = applyE***REMOVED***clusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);
      } else {
        delete ret[key];
      }
    } else if (hasIncludedChildren[fullPath]) {
      ret[key] = applyE***REMOVED***clusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);
    }
  }
  return ret;
}

function applyInclusiveProjection(doc, projection, hasIncludedChildren, projectionLimb, prefi***REMOVED***) {
  if (doc == null || typeof doc !== 'object') {
    return doc;
  }
  if (Array.isArray(doc)) {
    return doc.map(el => applyInclusiveProjection(el, projection, hasIncludedChildren, projectionLimb, prefi***REMOVED***));
  }
  const ret = { ...doc };
  projectionLimb = prefi***REMOVED*** ? (projectionLimb || {}) : projection;

  for (const key of Object.keys(ret)) {
    const fullPath = prefi***REMOVED*** ? prefi***REMOVED*** + '.' + key : key;
    if (projection.hasOwnProperty(fullPath) || projectionLimb.hasOwnProperty(key)) {
      if (isPOJO(projection[fullPath]) || isPOJO(projectionLimb[key])) {
        ret[key] = applyInclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);
      }
      continue;
    } else if (hasIncludedChildren[fullPath]) {
      ret[key] = applyInclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);
    } else {
      delete ret[key];
    }
  }
  return ret;
}
