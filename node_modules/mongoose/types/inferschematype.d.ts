import {
  Schema,
  InferSchemaType,
  SchemaType,
  SchemaTypeOptions,
  TypeKeyBaseType,
  Types,
  NumberSchemaDefinition,
  StringSchemaDefinition,
  BooleanSchemaDefinition,
  DateSchemaDefinition,
  ObtainDocumentType,
  DefaultTypeKey,
  ObjectIdSchemaDefinition,
  IfEquals,
  DefaultSchemaOptions,
  IsItRecordAndNotAny
} from 'mongoose';

declare module 'mongoose' {
  /**
   * @summary Obtains document schema type.
   * @description Obtains document schema type from document Definition OR returns enforced schema type if it's provided.
   * @param {DocDefinition} DocDefinition A generic equals to the type of document definition "provided in as first parameter in Schema constructor".
   * @param {EnforcedDocType} EnforcedDocType A generic type enforced by user "provided before schema constructor".
   * @param {TypeKey} TypeKey A generic of literal string type."Refers to the property used for path type definition".
   */
  type ObtainDocumentType<
    DocDefinition,
    EnforcedDocType = any,
    TSchemaOptions e***REMOVED***tends Record<any, any> = DefaultSchemaOptions
  > = IsItRecordAndNotAny<EnforcedDocType> e***REMOVED***tends true ?
    EnforcedDocType :
    {
      [
      K in keyof (RequiredPaths<DocDefinition, TSchemaOptions['typeKey']> &
      OptionalPaths<DocDefinition, TSchemaOptions['typeKey']>)
      ]: IsPathRequired<DocDefinition[K], TSchemaOptions['typeKey']> e***REMOVED***tends true ?
        ObtainDocumentPathType<DocDefinition[K], TSchemaOptions['typeKey']> :
        ObtainDocumentPathType<DocDefinition[K], TSchemaOptions['typeKey']> | null;
    };

  /**
   * @summary Obtains document schema type from Schema instance.
   * @param {Schema} TSchema `typeof` a schema instance.
   * @e***REMOVED***ample
   * const userSchema = new Schema({userName:String});
   * type UserType = InferSchemaType<typeof userSchema>;
   * // result
   * type UserType = {userName?: string}
   */
  e***REMOVED***port type InferSchemaType<TSchema> = IfAny<TSchema, any, ObtainSchemaGeneric<TSchema, 'DocType'>>;

  /**
   * @summary Obtains schema Generic type by using generic alias.
   * @param {TSchema} TSchema A generic of schema type instance.
   * @param {alias} alias Targeted generic alias.
   */
  type ObtainSchemaGeneric<TSchema, alias e***REMOVED***tends 'EnforcedDocType' | 'M' | 'TInstanceMethods' | 'TQueryHelpers' | 'TVirtuals' | 'TStaticMethods' | 'TSchemaOptions' | 'DocType'> =
   TSchema e***REMOVED***tends Schema<infer EnforcedDocType, infer M, infer TInstanceMethods, infer TQueryHelpers, infer TVirtuals, infer TStaticMethods, infer TSchemaOptions, infer DocType>
     ? {
       EnforcedDocType: EnforcedDocType;
       M: M;
       TInstanceMethods: TInstanceMethods;
       TQueryHelpers: TQueryHelpers;
       TVirtuals: TVirtuals;
       TStaticMethods: TStaticMethods;
       TSchemaOptions: TSchemaOptions;
       DocType: DocType;
     }[alias]
     : unknown;

  type ResolveSchemaOptions<T> = MergeType<DefaultSchemaOptions, T>;

  type ApplySchemaOptions<T, O = DefaultSchemaOptions> = ResolveTimestamps<T, O>;

  type ResolveTimestamps<T, O> = O e***REMOVED***tends { methods: any } | { statics: any } | { virtuals: any } | { timestamps?: false } ? T
    // For some reason, TypeScript sets all the document properties to unknown
    // if we use methods, statics, or virtuals. So avoid inferring timestamps
    // if any of these are set for now. See gh-12807
    : O e***REMOVED***tends { timestamps: infer TimestampOptions } ? TimestampOptions e***REMOVED***tends true
      ? { createdAt: NativeDate; updatedAt: NativeDate; } & T
      : TimestampOptions e***REMOVED***tends SchemaTimestampsConfig
        ? {
          -readonly [K in keyof Pick<
            TimestampOptions,
            'createdAt' | 'updatedAt'
          > as TimestampOptions[K] e***REMOVED***tends true
            ? K
            : TimestampOptions[K] e***REMOVED***tends `${infer TimestampValue}`
              ? TimestampValue
              : never]: NativeDate;
        } & T
        : T
      : T;
}

type IsPathDefaultUndefined<PathType> = PathType e***REMOVED***tends { default: undefined } ?
  true :
  PathType e***REMOVED***tends { default: (...args: any[]) => undefined } ?
    true :
    false;

/**
 * @summary Checks if a document path is required or optional.
 * @param {P} P Document path.
 * @param {TypeKey} TypeKey A generic of literal string type."Refers to the property used for path type definition".
 */
type IsPathRequired<P, TypeKey e***REMOVED***tends string = DefaultTypeKey> =
  P e***REMOVED***tends { required: true | [true, string | undefined] | { isRequired: true } } | ArrayConstructor | any[]
    ? true
    : P e***REMOVED***tends { required: boolean }
      ? P e***REMOVED***tends { required: false }
        ? false
        : true
      : P e***REMOVED***tends (Record<TypeKey, ArrayConstructor | any[]>)
        ? IsPathDefaultUndefined<P> e***REMOVED***tends true
          ? false
          : true
        : P e***REMOVED***tends (Record<TypeKey, any>)
          ? P e***REMOVED***tends { default: any }
            ? IfEquals<P['default'], undefined, false, true>
            : false
          : false;

/**
 * @summary Path base type defined by using TypeKey
 * @description It helps to check if a path is defined by TypeKey OR not.
 * @param {TypeKey} TypeKey A literal string refers to path type property key.
 */
type PathWithTypePropertyBaseType<TypeKey e***REMOVED***tends string = DefaultTypeKey> = { [k in TypeKey]: any };

/**
 * @summary A Utility to obtain schema's required path keys.
 * @param {T} T A generic refers to document definition.
 * @param {TypeKey} TypeKey A generic of literal string type."Refers to the property used for path type definition".
 * @returns required paths keys of document definition.
 */
type RequiredPathKeys<T, TypeKey e***REMOVED***tends string = DefaultTypeKey> = {
  [K in keyof T]: IsPathRequired<T[K], TypeKey> e***REMOVED***tends true ? IfEquals<T[K], any, never, K> : never;
}[keyof T];

/**
 * @summary A Utility to obtain schema's required paths.
 * @param {T} T A generic refers to document definition.
 * @param {TypeKey} TypeKey A generic of literal string type."Refers to the property used for path type definition".
 * @returns a record contains required paths with the corresponding type.
 */
type RequiredPaths<T, TypeKey e***REMOVED***tends string = DefaultTypeKey> = Pick<
  { -readonly [K in keyof T]: T[K] },
  RequiredPathKeys<T, TypeKey>
>;

/**
 * @summary A Utility to obtain schema's optional path keys.
 * @param {T} T A generic refers to document definition.
 * @param {TypeKey} TypeKey A generic of literal string type."Refers to the property used for path type definition".
 * @returns optional paths keys of document definition.
 */
type OptionalPathKeys<T, TypeKey e***REMOVED***tends string = DefaultTypeKey> = {
  [K in keyof T]: IsPathRequired<T[K], TypeKey> e***REMOVED***tends true ? never : K;
}[keyof T];

/**
 * @summary A Utility to obtain schema's optional paths.
 * @param {T} T A generic refers to document definition.
 * @param {TypeKey} TypeKey A generic of literal string type."Refers to the property used for path type definition".
 * @returns a record contains optional paths with the corresponding type.
 */
type OptionalPaths<T, TypeKey e***REMOVED***tends string = DefaultTypeKey> = Pick<
  { -readonly [K in keyof T]?: T[K] },
  OptionalPathKeys<T, TypeKey>
>;

/**
 * @summary Allows users to optionally choose their own type for a schema field for stronger typing.
 */
type TypeHint<T> = T e***REMOVED***tends { __typehint: infer U } ? U: never;


/**
 * @summary Obtains schema Path type.
 * @description Obtains Path type by separating path type from other options and calling {@link ResolvePathType}
 * @param {PathValueType} PathValueType Document definition path type.
 * @param {TypeKey} TypeKey A generic refers to document definition.
 */
type ObtainDocumentPathType<PathValueType, TypeKey e***REMOVED***tends string = DefaultTypeKey> = ResolvePathType<
  PathValueType e***REMOVED***tends PathWithTypePropertyBaseType<TypeKey>
    ? PathValueType[TypeKey] e***REMOVED***tends PathWithTypePropertyBaseType<TypeKey>
      ? PathValueType
      : PathValueType[TypeKey]
    : PathValueType,
  PathValueType e***REMOVED***tends PathWithTypePropertyBaseType<TypeKey>
    ? PathValueType[TypeKey] e***REMOVED***tends PathWithTypePropertyBaseType<TypeKey>
      ? {}
      : Omit<PathValueType, TypeKey>
    : {},
TypeKey,
TypeHint<PathValueType>
>;

/**
 * @param {T} T A generic refers to string path enums.
 * @returns Path enum values type as literal strings or string.
 */
type PathEnumOrString<T e***REMOVED***tends SchemaTypeOptions<string>['enum']> = T e***REMOVED***tends ReadonlyArray<infer E> ? E : T e***REMOVED***tends { values: any } ? PathEnumOrString<T['values']> : string;

type IsSchemaTypeFromBuiltinClass<T> = T e***REMOVED***tends (typeof String)
  ? true
  : T e***REMOVED***tends (typeof Number)
    ? true
    : T e***REMOVED***tends (typeof Boolean)
      ? true
      : T e***REMOVED***tends (typeof Buffer)
        ? true
        : T e***REMOVED***tends (typeof Schema.Types.ObjectId)
          ? true
          : T e***REMOVED***tends (typeof Schema.Types.UUID)
            ? true
            : T e***REMOVED***tends (typeof Schema.Types.Decimal128)
              ? true
              : T e***REMOVED***tends (typeof Schema.Types.String)
                ? true
                : T e***REMOVED***tends (typeof Schema.Types.Number)
                  ? true
                  : T e***REMOVED***tends (typeof Schema.Types.Date)
                    ? true
                    : T e***REMOVED***tends (typeof Schema.Types.Boolean)
                      ? true
                      : T e***REMOVED***tends (typeof Schema.Types.Buffer)
                        ? true
                        : T e***REMOVED***tends Types.ObjectId
                          ? true
                          : T e***REMOVED***tends Types.Decimal128
                            ? true
                            : T e***REMOVED***tends Buffer
                              ? true
                              : T e***REMOVED***tends NativeDate
                                ? true
                                : T e***REMOVED***tends (typeof Schema.Types.Mi***REMOVED***ed)
                                  ? true
                                  : IfEquals<T, Schema.Types.ObjectId, true, false>;

/**
 * @summary Resolve path type by returning the corresponding type.
 * @param {PathValueType} PathValueType Document definition path type.
 * @param {Options} Options Document definition path options e***REMOVED***cept path type.
 * @param {TypeKey} TypeKey A generic of literal string type."Refers to the property used for path type definition".
 * @returns Number, "Number" or "number" will be resolved to number type.
 */
type ResolvePathType<PathValueType, Options e***REMOVED***tends SchemaTypeOptions<PathValueType> = {}, TypeKey e***REMOVED***tends string = DefaultSchemaOptions['typeKey'], TypeHint = never> =
  IfEquals<TypeHint, never,
    PathValueType e***REMOVED***tends Schema ? InferSchemaType<PathValueType> :
      PathValueType e***REMOVED***tends (infer Item)[] ?
        IfEquals<Item, never, any[], Item e***REMOVED***tends Schema ?
          // If Item is a schema, infer its type.
          Types.DocumentArray<InferSchemaType<Item>> :
          Item e***REMOVED***tends Record<TypeKey, any> ?
            Item[TypeKey] e***REMOVED***tends Function | String ?
              // If Item has a type key that's a string or a callable, it must be a scalar,
              // so we can directly obtain its path type.
              ObtainDocumentPathType<Item, TypeKey>[] :
              // If the type key isn't callable, then this is an array of objects, in which case
              // we need to call ObtainDocumentType to correctly infer its type.
              Types.DocumentArray<ObtainDocumentType<Item, any, { typeKey: TypeKey }>> :
            IsSchemaTypeFromBuiltinClass<Item> e***REMOVED***tends true ?
              ObtainDocumentPathType<Item, TypeKey>[] :
              IsItRecordAndNotAny<Item> e***REMOVED***tends true ?
                Item e***REMOVED***tends Record<string, never> ?
                  ObtainDocumentPathType<Item, TypeKey>[] :
                  Types.DocumentArray<ObtainDocumentType<Item, any, { typeKey: TypeKey }>> :
                ObtainDocumentPathType<Item, TypeKey>[]
        >:
        PathValueType e***REMOVED***tends ReadonlyArray<infer Item> ?
          IfEquals<Item, never, any[], Item e***REMOVED***tends Schema ?
            Types.DocumentArray<InferSchemaType<Item>> :
            Item e***REMOVED***tends Record<TypeKey, any> ?
              Item[TypeKey] e***REMOVED***tends Function | String ?
                ObtainDocumentPathType<Item, TypeKey>[] :
                ObtainDocumentType<Item, any, { typeKey: TypeKey }>[]:
              IsSchemaTypeFromBuiltinClass<Item> e***REMOVED***tends true ?
                ObtainDocumentPathType<Item, TypeKey>[] :
                IsItRecordAndNotAny<Item> e***REMOVED***tends true ?
                  Item e***REMOVED***tends Record<string, never> ?
                    ObtainDocumentPathType<Item, TypeKey>[] :
                    Types.DocumentArray<ObtainDocumentType<Item, any, { typeKey: TypeKey }>> :
                  ObtainDocumentPathType<Item, TypeKey>[]
          >:
          PathValueType e***REMOVED***tends StringSchemaDefinition ? PathEnumOrString<Options['enum']> :
            IfEquals<PathValueType, Schema.Types.String> e***REMOVED***tends true ? PathEnumOrString<Options['enum']> :
              IfEquals<PathValueType, String> e***REMOVED***tends true ? PathEnumOrString<Options['enum']> :
                PathValueType e***REMOVED***tends NumberSchemaDefinition ? Options['enum'] e***REMOVED***tends ReadonlyArray<any> ? Options['enum'][number] : number :
                  IfEquals<PathValueType, Schema.Types.Number> e***REMOVED***tends true ? number :
                    PathValueType e***REMOVED***tends DateSchemaDefinition ? NativeDate :
                      IfEquals<PathValueType, Schema.Types.Date> e***REMOVED***tends true ? NativeDate :
                        PathValueType e***REMOVED***tends typeof Buffer | 'buffer' | 'Buffer' | typeof Schema.Types.Buffer ? Buffer :
                          PathValueType e***REMOVED***tends BooleanSchemaDefinition ? boolean :
                            IfEquals<PathValueType, Schema.Types.Boolean> e***REMOVED***tends true ? boolean :
                              PathValueType e***REMOVED***tends ObjectIdSchemaDefinition ? Types.ObjectId :
                                IfEquals<PathValueType, Types.ObjectId> e***REMOVED***tends true ? Types.ObjectId :
                                  IfEquals<PathValueType, Schema.Types.ObjectId> e***REMOVED***tends true ? Types.ObjectId :
                                    PathValueType e***REMOVED***tends 'decimal128' | 'Decimal128' | typeof Schema.Types.Decimal128 ? Types.Decimal128 :
                                      IfEquals<PathValueType, Schema.Types.Decimal128> e***REMOVED***tends true ? Types.Decimal128 :
                                        IfEquals<PathValueType, Types.Decimal128> e***REMOVED***tends true ? Types.Decimal128 :
                                          IfEquals<PathValueType, Schema.Types.BigInt> e***REMOVED***tends true ? bigint :
                                            IfEquals<PathValueType, BigInt> e***REMOVED***tends true ? bigint :
                                              PathValueType e***REMOVED***tends 'bigint' | 'BigInt' | typeof Schema.Types.BigInt | typeof BigInt ? bigint :
                                                PathValueType e***REMOVED***tends 'uuid' | 'UUID' | typeof Schema.Types.UUID ? Buffer :
                                                  IfEquals<PathValueType, Schema.Types.UUID> e***REMOVED***tends true ? Buffer :
                                                    PathValueType e***REMOVED***tends MapConstructor | 'Map' ? Map<string, ResolvePathType<Options['of']>> :
                                                      IfEquals<PathValueType, typeof Schema.Types.Map> e***REMOVED***tends true ? Map<string, ResolvePathType<Options['of']>> :
                                                        PathValueType e***REMOVED***tends ArrayConstructor ? any[] :
                                                          PathValueType e***REMOVED***tends typeof Schema.Types.Mi***REMOVED***ed ? any:
                                                            IfEquals<PathValueType, ObjectConstructor> e***REMOVED***tends true ? any:
                                                              IfEquals<PathValueType, {}> e***REMOVED***tends true ? any:
                                                                PathValueType e***REMOVED***tends typeof SchemaType ? PathValueType['prototype'] :
                                                                  PathValueType e***REMOVED***tends Record<string, any> ? ObtainDocumentType<PathValueType, any, { typeKey: TypeKey }> :
                                                                    unknown,
    TypeHint>;
