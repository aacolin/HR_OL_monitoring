/// <reference path="./aggregate.d.ts" />
/// <reference path="./callback.d.ts" />
/// <reference path="./collection.d.ts" />
/// <reference path="./connection.d.ts" />
/// <reference path="./cursor.d.ts" />
/// <reference path="./document.d.ts" />
/// <reference path="./error.d.ts" />
/// <reference path="./e***REMOVED***pressions.d.ts" />
/// <reference path="./helpers.d.ts" />
/// <reference path="./middlewares.d.ts" />
/// <reference path="./inde***REMOVED***es.d.ts" />
/// <reference path="./models.d.ts" />
/// <reference path="./mongooseoptions.d.ts" />
/// <reference path="./pipelinestage.d.ts" />
/// <reference path="./populate.d.ts" />
/// <reference path="./query.d.ts" />
/// <reference path="./schemaoptions.d.ts" />
/// <reference path="./schematypes.d.ts" />
/// <reference path="./session.d.ts" />
/// <reference path="./types.d.ts" />
/// <reference path="./utility.d.ts" />
/// <reference path="./validation.d.ts" />
/// <reference path="./inferrawdoctype.d.ts" />
/// <reference path="./inferschematype.d.ts" />
/// <reference path="./virtuals.d.ts" />
/// <reference path="./augmentations.d.ts" />

declare class NativeDate e***REMOVED***tends globalThis.Date { }

declare module 'mongoose' {
  import Kareem = require('kareem');
  import events = require('events');
  import mongodb = require('mongodb');
  import mongoose = require('mongoose');

  e***REMOVED***port type Mongoose = typeof mongoose;

  /**
   * Mongoose constructor. The e***REMOVED***ports object of the `mongoose` module is an instance of this
   * class. Most apps will only use this one instance.
   */
  e***REMOVED***port const Mongoose: new (options?: MongooseOptions | null) => Mongoose;

  e***REMOVED***port let Promise: any;

  /**
   * Can be e***REMOVED***tended to e***REMOVED***plicitly type specific models.
   */
  e***REMOVED***port interface Models {
    [modelName: string]: Model<any>
  }

  /** An array containing all models associated with this Mongoose instance. */
  e***REMOVED***port const models: Models;

  /**
   * Removes the model named `name` from the default connection, if it e***REMOVED***ists.
   * You can use this function to clean up any models you created in your tests to
   * prevent OverwriteModelErrors.
   */
  e***REMOVED***port function deleteModel(name: string | RegE***REMOVED***p): Mongoose;

  /**
   * Sanitizes query filters against query selector injection attacks by wrapping
   * any nested objects that have a property whose name starts with `$` in a `$eq`.
   */
  e***REMOVED***port function sanitizeFilter<T>(filter: FilterQuery<T>): FilterQuery<T>;

  /** Gets mongoose options */
  e***REMOVED***port function get<K e***REMOVED***tends keyof MongooseOptions>(key: K): MongooseOptions[K];

  e***REMOVED***port function omitUndefined<T e***REMOVED***tends Record<string, any>>(val: T): T;

  /* ! ignore */
  e***REMOVED***port type CompileModelOptions = {
    overwriteModels?: boolean,
    connection?: Connection
  };

  e***REMOVED***port function model<TSchema e***REMOVED***tends Schema = any>(
    name: string,
    schema?: TSchema,
    collection?: string,
    options?: CompileModelOptions
  ): Model<
  InferSchemaType<TSchema>,
  ObtainSchemaGeneric<TSchema, 'TQueryHelpers'>,
  ObtainSchemaGeneric<TSchema, 'TInstanceMethods'>,
  ObtainSchemaGeneric<TSchema, 'TVirtuals'>,
  HydratedDocument<
  InferSchemaType<TSchema>,
  ObtainSchemaGeneric<TSchema, 'TVirtuals'> & ObtainSchemaGeneric<TSchema, 'TInstanceMethods'>,
  ObtainSchemaGeneric<TSchema, 'TQueryHelpers'>
  >,
  TSchema
  > & ObtainSchemaGeneric<TSchema, 'TStaticMethods'>;

  e***REMOVED***port function model<T>(name: string, schema?: Schema<T, any, any> | Schema<T & Document, any, any>, collection?: string, options?: CompileModelOptions): Model<T>;

  e***REMOVED***port function model<T, U, TQueryHelpers = {}>(
    name: string,
    schema?: Schema<T, any, any, TQueryHelpers, any, any, any>,
    collection?: string,
    options?: CompileModelOptions
  ): U;

  /** Returns an array of model names created on this instance of Mongoose. */
  e***REMOVED***port function modelNames(): Array<string>;

  /**
   * Overwrites the current driver used by this Mongoose instance. A driver is a
   * Mongoose-specific interface that defines functions like `find()`.
   */
  e***REMOVED***port function setDriver(driver: any): Mongoose;

  /** The node-mongodb-native driver Mongoose uses. */
  e***REMOVED***port { mongodb as mongo };

  /** Declares a global plugin e***REMOVED***ecuted on all Schemas. */
  e***REMOVED***port function plugin(fn: (schema: Schema, opts?: any) => void, opts?: any): Mongoose;

  /** Getter/setter around function for pluralizing collection names. */
  e***REMOVED***port function pluralize(fn?: ((str: string) => string) | null): ((str: string) => string) | null;

  /** Sets mongoose options */
  e***REMOVED***port function set<K e***REMOVED***tends keyof MongooseOptions>(key: K, value: MongooseOptions[K]): Mongoose;
  e***REMOVED***port function set(options: { [K in keyof MongooseOptions]: MongooseOptions[K] }): Mongoose;

  /** The Mongoose version */
  e***REMOVED***port const version: string;

  e***REMOVED***port type AnyKeys<T> = { [P in keyof T]?: T[P] | any };
  e***REMOVED***port interface AnyObject {
    [k: string]: any
  }

  e***REMOVED***port type Require_id<T> = T e***REMOVED***tends { _id?: infer U }
    ? IfAny<U, T & { _id: Types.ObjectId }, T & Required<{ _id: U }>>
    : T & { _id: Types.ObjectId };

  e***REMOVED***port type Default__v<T> = T e***REMOVED***tends { __v?: infer U }
    ? T
    : T & { __v: number };

  /** Helper type for getting the hydrated document type from the raw document type. The hydrated document type is what `new MyModel()` returns. */
  e***REMOVED***port type HydratedDocument<
    DocType,
    TOverrides = {},
    TQueryHelpers = {}
  > = IfAny<
    DocType,
    any,
    TOverrides e***REMOVED***tends Record<string, never> ?
      Document<unknown, TQueryHelpers, DocType> & Default__v<Require_id<DocType>> :
      IfAny<
        TOverrides,
        Document<unknown, TQueryHelpers, DocType> & Default__v<Require_id<DocType>>,
        Document<unknown, TQueryHelpers, DocType> & MergeType<
          Default__v<Require_id<DocType>>,
          TOverrides
        >
      >
  >;
  e***REMOVED***port type HydratedSingleSubdocument<
    DocType,
    TOverrides = {}
  > = IfAny<
  DocType,
  any,
  TOverrides e***REMOVED***tends Record<string, never> ?
    Types.Subdocument<unknown, Record<string, never>, DocType> & Require_id<DocType> :
    IfAny<
      TOverrides,
      Types.Subdocument<unknown, Record<string, never>, DocType> & Require_id<DocType>,
      Types.Subdocument<unknown, Record<string, never>, DocType> & MergeType<
        Require_id<DocType>,
        TOverrides
      >
    >
  >;
  e***REMOVED***port type HydratedArraySubdocument<DocType, TOverrides = {}> = IfAny<
    DocType,
    any,
    TOverrides e***REMOVED***tends Record<string, never> ?
      Types.ArraySubdocument<unknown, Record<string, never>, DocType> & Require_id<DocType> :
      IfAny<
        TOverrides,
        Types.ArraySubdocument<unknown, Record<string, never>, DocType> & Require_id<DocType>,
        Types.ArraySubdocument<unknown, Record<string, never>, DocType> & MergeType<
          Require_id<DocType>,
          TOverrides
        >
      >
    >;

  e***REMOVED***port type HydratedDocumentFromSchema<TSchema e***REMOVED***tends Schema> = HydratedDocument<
  InferSchemaType<TSchema>,
  ObtainSchemaGeneric<TSchema, 'TInstanceMethods'>,
  ObtainSchemaGeneric<TSchema, 'TQueryHelpers'>
  >;

  e***REMOVED***port interface TagSet {
    [k: string]: string;
  }

  e***REMOVED***port interface ToObjectOptions<THydratedDocumentType = HydratedDocument<unknown>> {
    /** apply all getters (path and virtual getters) */
    getters?: boolean;
    /** apply virtual getters (can override getters option) */
    virtuals?: boolean | string[];
    /** if `options.virtuals = true`, you can set `options.aliases = false` to skip applying aliases. This option is a no-op if `options.virtuals = false`. */
    aliases?: boolean;
    /** remove empty objects (defaults to true) */
    minimize?: boolean;
    /** if set, mongoose will call this function to allow you to transform the returned object */
    transform?: boolean | ((
      doc: THydratedDocumentType,
      ret: Record<string, any>,
      options: ToObjectOptions<THydratedDocumentType>
    ) => any);
    /** if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths. */
    depopulate?: boolean;
    /** if false, e***REMOVED***clude the version key (`__v` by default) from the output */
    versionKey?: boolean;
    /** if true, convert Maps to POJOs. Useful if you want to `JSON.stringify()` the result of `toObject()`. */
    flattenMaps?: boolean;
    /** if true, convert any ObjectIds in the result to 24 character he***REMOVED*** strings. */
    flattenObjectIds?: boolean;
    /** If true, omits fields that are e***REMOVED***cluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema. */
    useProjection?: boolean;
  }

  e***REMOVED***port type DiscriminatorModel<M, T> = T e***REMOVED***tends Model<infer T, infer TQueryHelpers, infer TInstanceMethods, infer TVirtuals>
    ?
    M e***REMOVED***tends Model<infer M, infer MQueryHelpers, infer MInstanceMethods, infer MVirtuals>
      ? Model<Omit<M, keyof T> & T, MQueryHelpers | TQueryHelpers, MInstanceMethods | TInstanceMethods, MVirtuals | TVirtuals>
      : M
    : M;

  e***REMOVED***port type DiscriminatorSchema<DocType, M, TInstanceMethods, TQueryHelpers, TVirtuals, TStaticMethods, DisSchema> =
    DisSchema e***REMOVED***tends Schema<infer DisSchemaEDocType, infer DisSchemaM, infer DisSchemaInstanceMethods, infer DisSchemaQueryhelpers, infer DisSchemaVirtuals, infer DisSchemaStatics>
      ? Schema<MergeType<DocType, DisSchemaEDocType>, DiscriminatorModel<DisSchemaM, M>, DisSchemaInstanceMethods | TInstanceMethods, DisSchemaQueryhelpers | TQueryHelpers, DisSchemaVirtuals | TVirtuals, DisSchemaStatics & TStaticMethods>
      : Schema<DocType, M, TInstanceMethods, TQueryHelpers, TVirtuals, TStaticMethods>;

  type QueryResultType<T> = T e***REMOVED***tends Query<infer ResultType, any> ? ResultType : never;

  type PluginFunction<
    DocType,
    M,
    TInstanceMethods,
    TQueryHelpers,
    TVirtuals,
    TStaticMethods> = (schema: Schema<DocType, M, TInstanceMethods, TQueryHelpers, TVirtuals, TStaticMethods>, opts?: any) => void;

  e***REMOVED***port class Schema<
    RawDocType = any,
    TModelType = Model<RawDocType, any, any, any>,
    TInstanceMethods = {},
    TQueryHelpers = {},
    TVirtuals = {},
    TStaticMethods = {},
    TSchemaOptions = DefaultSchemaOptions,
    DocType e***REMOVED***tends ApplySchemaOptions<
      ObtainDocumentType<DocType, RawDocType, ResolveSchemaOptions<TSchemaOptions>>,
      ResolveSchemaOptions<TSchemaOptions>
    > = ApplySchemaOptions<
      ObtainDocumentType<any, RawDocType, ResolveSchemaOptions<TSchemaOptions>>,
      ResolveSchemaOptions<TSchemaOptions>
    >,
    THydratedDocumentType = HydratedDocument<FlatRecord<DocType>, TVirtuals & TInstanceMethods>
  >
    e***REMOVED***tends events.EventEmitter {
    /**
     * Create a new schema
     */
    constructor(definition?: SchemaDefinition<SchemaDefinitionType<RawDocType>, RawDocType> | DocType, options?: SchemaOptions<FlatRecord<DocType>, TInstanceMethods, TQueryHelpers, TStaticMethods, TVirtuals, THydratedDocumentType> | ResolveSchemaOptions<TSchemaOptions>);

    /** Adds key path / schema type pairs to this schema. */
    add(obj: SchemaDefinition<SchemaDefinitionType<RawDocType>> | Schema, prefi***REMOVED***?: string): this;

    /**
     * Add an alias for `path`. This means getting or setting the `alias`
     * is equivalent to getting or setting the `path`.
     */
    alias(path: string, alias: string | string[]): this;

    /**
     * Array of child schemas (from document arrays and single nested subdocs)
     * and their corresponding compiled models. Each element of the array is
     * an object with 2 properties: `schema` and `model`.
     */
    childSchemas: { schema: Schema, model: any }[];

    /** Removes all inde***REMOVED***es on this schema */
    clearInde***REMOVED***es(): this;

    /** Returns a copy of this schema */
    clone<T = this>(): T;

    discriminator<DisSchema = Schema>(name: string | number, schema: DisSchema): this;

    /** Returns a new schema that has the picked `paths` from this schema. */
    pick<T = this>(paths: string[], options?: SchemaOptions): T;

    /** Object containing discriminators defined on this schema */
    discriminators?: { [name: string]: Schema };

    /** Iterates the schemas paths similar to Array#forEach. */
    eachPath(fn: (path: string, type: SchemaType) => void): this;

    /** Defines an inde***REMOVED*** (most likely compound) for this schema. */
    inde***REMOVED***(fields: Inde***REMOVED***Definition, options?: Inde***REMOVED***Options): this;

    /**
     * Define a search inde***REMOVED*** for this schema.
     *
     * @remarks Search inde***REMOVED***es are only supported when used against a 7.0+ Mongo Atlas cluster.
     */
    searchInde***REMOVED***(description: SearchInde***REMOVED***Description): this;

    /**
     * Returns a list of inde***REMOVED***es that this schema declares, via `schema.inde***REMOVED***()`
     * or by `inde***REMOVED***: true` in a path's options.
     */
    inde***REMOVED***es(): Array<[Inde***REMOVED***Definition, Inde***REMOVED***Options]>;

    /** Gets a schema option. */
    get<K e***REMOVED***tends keyof SchemaOptions>(key: K): SchemaOptions[K];

    /**
     * Loads an ES6 class into a schema. Maps [setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set) + [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get), [static methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static),
     * and [instance methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions)
     * to schema [virtuals](http://mongoosejs.com/docs/guide.html#virtuals),
     * [statics](http://mongoosejs.com/docs/guide.html#statics), and
     * [methods](http://mongoosejs.com/docs/guide.html#methods).
     */
    loadClass(model: Function, onlyVirtuals?: boolean): this;

    /** Adds an instance method to documents constructed from Models compiled from this schema. */
    method<Conte***REMOVED***t = THydratedDocumentType>(name: string, fn: (this: Conte***REMOVED***t, ...args: any[]) => any, opts?: any): this;
    method(obj: Partial<TInstanceMethods>): this;

    /** Object of currently defined methods on this schema. */
    methods: AddThisParameter<TInstanceMethods, THydratedDocumentType> & AnyObject;

    /** The original object passed to the schema constructor */
    obj: SchemaDefinition<SchemaDefinitionType<RawDocType>, RawDocType>;

    /** Returns a new schema that has the `paths` from the original schema, minus the omitted ones. */
    omit<T = this>(paths: string[], options?: SchemaOptions): T;

    /** Gets/sets schema paths. */
    path<ResultType e***REMOVED***tends SchemaType = SchemaType<any, THydratedDocumentType>>(path: string): ResultType;
    path<pathGeneric e***REMOVED***tends keyof RawDocType>(path: pathGeneric): SchemaType<RawDocType[pathGeneric]>;
    path(path: string, constructor: any): this;

    /** Lists all paths and their type in the schema. */
    paths: {
      [key: string]: SchemaType;
    };

    /** Returns the pathType of `path` for this schema. */
    pathType(path: string): string;

    /** Registers a plugin for this schema. */
    plugin<PFunc e***REMOVED***tends PluginFunction<DocType, TModelType, any, any, any, any>, POptions e***REMOVED***tends Parameters<PFunc>[1] = Parameters<PFunc>[1]>(fn: PFunc, opts?: POptions): this;

    /** Defines a post hook for the model. */

    // PostMiddlewareFunction
    // with errorHandler set to true
    post<T = Query<any, any>>(method: MongooseQueryMiddleware | MongooseQueryMiddleware[] | RegE***REMOVED***p, options: SchemaPostOptions & { errorHandler: true }, fn: ErrorHandlingMiddlewareWithOption<T>): this;
    post<T = THydratedDocumentType>(method: MongooseDocumentMiddleware | MongooseDocumentMiddleware[] | RegE***REMOVED***p, options: SchemaPostOptions & { errorHandler: true }, fn: ErrorHandlingMiddlewareWithOption<T>): this;
    post<T e***REMOVED***tends Aggregate<any>>(method: 'aggregate' | RegE***REMOVED***p, options: SchemaPostOptions & { errorHandler: true }, fn: ErrorHandlingMiddlewareWithOption<T, Array<any>>): this;
    post<T = TModelType>(method: 'insertMany' | RegE***REMOVED***p, options: SchemaPostOptions & { errorHandler: true }, fn: ErrorHandlingMiddlewareWithOption<T>): this;

    // this = never since it never happens
    post<T = never>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegE***REMOVED***p, options: SchemaPostOptions & { document: false, query: false }, fn: PostMiddlewareFunction<never, never>): this;
    post<T = never>(method: MongooseDistinctQueryMiddleware|MongooseDistinctQueryMiddleware[], options: SchemaPostOptions & { document: boolean, query: false }, fn: PostMiddlewareFunction<T, QueryResultType<T>>): this;
    post<T = never>(method: MongooseDistinctDocumentMiddleware | MongooseDistinctDocumentMiddleware[] | RegE***REMOVED***p, options: SchemaPostOptions & { document: false, query: true }, fn: PostMiddlewareFunction<T, T>): this;
    // this = Document
    post<T = THydratedDocumentType>(method: MongooseDistinctDocumentMiddleware|MongooseDistinctDocumentMiddleware[], fn: PostMiddlewareFunction<T, T>): this;
    post<T = THydratedDocumentType>(method: MongooseDistinctDocumentMiddleware|MongooseDistinctDocumentMiddleware[], options: SchemaPostOptions & SchemaPostOptions, fn: PostMiddlewareFunction<T, T>): this;
    post<T = THydratedDocumentType>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegE***REMOVED***p, options: SchemaPostOptions & { document: true, query: false }, fn: PostMiddlewareFunction<T, T>): this;
    // this = Query
    post<T = Query<any, any>>(method: MongooseRawResultQueryMiddleware|MongooseRawResultQueryMiddleware[], fn: PostMiddlewareFunction<T, null | QueryResultType<T> | ModifyResult<QueryResultType<T>>>): this;
    post<T = Query<any, any>>(method: MongooseDefaultQueryMiddleware|MongooseDefaultQueryMiddleware[], fn: PostMiddlewareFunction<T, QueryResultType<T>>): this;
    post<T = Query<any, any>>(method: MongooseDistinctQueryMiddleware|MongooseDistinctQueryMiddleware[], options: SchemaPostOptions, fn: PostMiddlewareFunction<T, QueryResultType<T>>): this;
    post<T = Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegE***REMOVED***p, options: SchemaPostOptions & { document: false, query: true }, fn: PostMiddlewareFunction<T, QueryResultType<T>>): this;
    // this = Union of Document and Query, could be called with any of them
    post<T = THydratedDocumentType|Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegE***REMOVED***p, options: SchemaPostOptions & { document: true, query: true }, fn: PostMiddlewareFunction<T, T|QueryResultType<T>>): this;
    post<T = THydratedDocumentType|Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegE***REMOVED***p, fn: PostMiddlewareFunction<T, T|QueryResultType<T>>): this;

    // ErrorHandlingMiddlewareFunction
    // this = never since it never happens
    post<T = never>(method: MongooseDistinctQueryMiddleware|MongooseDistinctQueryMiddleware[], options: SchemaPostOptions & { document: boolean, query: false }, fn: ErrorHandlingMiddlewareFunction<T>): this;
    post<T = never>(method: MongooseDistinctDocumentMiddleware|MongooseDistinctDocumentMiddleware[], options: SchemaPostOptions & { document: false, query: boolean }, fn: ErrorHandlingMiddlewareFunction<T>): this;
    post<T = never>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegE***REMOVED***p, options: SchemaPostOptions & { document: false, query: false }, fn: ErrorHandlingMiddlewareFunction<T>): this;
    // this = Document
    post<T = THydratedDocumentType>(method: MongooseDistinctDocumentMiddleware|MongooseDistinctDocumentMiddleware[], fn: ErrorHandlingMiddlewareFunction<T>): this;
    post<T = THydratedDocumentType>(method: MongooseDistinctDocumentMiddleware|MongooseDistinctDocumentMiddleware[], options: SchemaPostOptions, fn: ErrorHandlingMiddlewareFunction<T>): this;
    post<T = THydratedDocumentType>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegE***REMOVED***p, options: SchemaPostOptions & { document: true, query: false }, fn: ErrorHandlingMiddlewareFunction<T>): this;
    // this = Query
    post<T = Query<any, any>>(method: MongooseDefaultQueryMiddleware|MongooseDefaultQueryMiddleware[], fn: ErrorHandlingMiddlewareFunction<T>): this;
    post<T = Query<any, any>>(method: MongooseDistinctQueryMiddleware|MongooseDistinctQueryMiddleware[], options: SchemaPostOptions, fn: ErrorHandlingMiddlewareFunction<T>): this;
    post<T = Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegE***REMOVED***p, options: SchemaPostOptions & { document: false, query: true }, fn: ErrorHandlingMiddlewareFunction<T>): this;
    // this = Union of Document and Query, could be called with any of them
    post<T = THydratedDocumentType|Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegE***REMOVED***p, options: SchemaPostOptions & { document: true, query: true }, fn: ErrorHandlingMiddlewareFunction<T>): this;
    post<T = THydratedDocumentType|Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegE***REMOVED***p, fn: ErrorHandlingMiddlewareFunction<T>): this;

    // method aggregate and insertMany with PostMiddlewareFunction
    post<T e***REMOVED***tends Aggregate<any>>(method: 'aggregate' | RegE***REMOVED***p, fn: PostMiddlewareFunction<T, Array<AggregateE***REMOVED***tract<T>>>): this;
    post<T e***REMOVED***tends Aggregate<any>>(method: 'aggregate' | RegE***REMOVED***p, options: SchemaPostOptions, fn: PostMiddlewareFunction<T, Array<AggregateE***REMOVED***tract<T>>>): this;
    post<T = TModelType>(method: 'insertMany' | RegE***REMOVED***p, fn: PostMiddlewareFunction<T, T>): this;
    post<T = TModelType>(method: 'insertMany' | RegE***REMOVED***p, options: SchemaPostOptions, fn: PostMiddlewareFunction<T, T>): this;

    // method aggregate and insertMany with ErrorHandlingMiddlewareFunction
    post<T e***REMOVED***tends Aggregate<any>>(method: 'aggregate' | RegE***REMOVED***p, fn: ErrorHandlingMiddlewareFunction<T, Array<any>>): this;
    post<T e***REMOVED***tends Aggregate<any>>(method: 'aggregate' | RegE***REMOVED***p, options: SchemaPostOptions, fn: ErrorHandlingMiddlewareFunction<T, Array<any>>): this;
    post<T = TModelType>(method: 'bulkWrite' | 'createCollection' | 'insertMany' | RegE***REMOVED***p, fn: ErrorHandlingMiddlewareFunction<T>): this;
    post<T = TModelType>(method: 'bulkWrite' | 'createCollection' | 'insertMany' | RegE***REMOVED***p, options: SchemaPostOptions, fn: ErrorHandlingMiddlewareFunction<T>): this;

    /** Defines a pre hook for the model. */
    // this = never since it never happens
    pre<T = never>(method: 'save', options: SchemaPreOptions & { document: false, query: boolean }, fn: PreSaveMiddlewareFunction<T>): this;
    pre<T = never>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegE***REMOVED***p, options: SchemaPreOptions & { document: false, query: false }, fn: PreMiddlewareFunction<T>): this;
    pre<T = never>(method: MongooseDistinctQueryMiddleware|MongooseDistinctQueryMiddleware[], options: SchemaPreOptions & { document: boolean, query: false }, fn: PreMiddlewareFunction<T>): this;
    pre<T = never>(method: MongooseDistinctDocumentMiddleware | MongooseDistinctDocumentMiddleware[] | RegE***REMOVED***p, options: SchemaPreOptions & { document: false, query: boolean }, fn: PreMiddlewareFunction<T>): this;
    // this = Union of Document and Query, could be called with any of them
    pre<T = THydratedDocumentType | Query<any, any>>(
      method: MongooseQueryAndDocumentMiddleware | MongooseQueryAndDocumentMiddleware[] | RegE***REMOVED***p,
      options: SchemaPreOptions & { document: true, query: true },
      fn: PreMiddlewareFunction<T>
    ): this;
    // this = Document
    pre<T = THydratedDocumentType>(method: 'save', fn: PreSaveMiddlewareFunction<T>): this;
    pre<T = THydratedDocumentType>(method: MongooseDistinctDocumentMiddleware|MongooseDistinctDocumentMiddleware[], fn: PreMiddlewareFunction<T>): this;
    pre<T = THydratedDocumentType>(method: MongooseDistinctDocumentMiddleware|MongooseDistinctDocumentMiddleware[], options: SchemaPreOptions, fn: PreMiddlewareFunction<T>): this;
    pre<T = THydratedDocumentType>(
      method: MongooseQueryAndDocumentMiddleware | MongooseQueryAndDocumentMiddleware[] | RegE***REMOVED***p,
      options: SchemaPreOptions & { document: true },
      fn: PreMiddlewareFunction<T>
    ): this;
    pre<T = THydratedDocumentType>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegE***REMOVED***p, options: SchemaPreOptions & { document: true, query: false }, fn: PreMiddlewareFunction<T>): this;
    // this = Query
    pre<T = Query<any, any>>(method: MongooseDefaultQueryMiddleware|MongooseDefaultQueryMiddleware[], fn: PreMiddlewareFunction<T>): this;
    pre<T = Query<any, any>>(method: MongooseDistinctQueryMiddleware|MongooseDistinctQueryMiddleware[], options: SchemaPreOptions, fn: PreMiddlewareFunction<T>): this;
    pre<T = Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegE***REMOVED***p, options: SchemaPreOptions & { document: false, query: true }, fn: PreMiddlewareFunction<T>): this;
    // this = Union of Document and Query, could be called with any of them
    pre<T = THydratedDocumentType|Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegE***REMOVED***p, options: SchemaPreOptions & { document: true, query: true }, fn: PreMiddlewareFunction<T>): this;
    pre<T = THydratedDocumentType|Query<any, any>>(method: MongooseQueryOrDocumentMiddleware | MongooseQueryOrDocumentMiddleware[] | RegE***REMOVED***p, fn: PreMiddlewareFunction<T>): this;
    // method aggregate
    pre<T e***REMOVED***tends Aggregate<any>>(method: 'aggregate' | RegE***REMOVED***p, fn: PreMiddlewareFunction<T>): this;
    /* method insertMany */
    pre<T = TModelType>(
      method: 'insertMany' | RegE***REMOVED***p,
      fn: (
        this: T,
        ne***REMOVED***t: (err?: CallbackError) => void,
        docs: any | Array<any>,
        options?: InsertManyOptions & { lean?: boolean }
      ) => void | Promise<void>
    ): this;
    /* method bulkWrite */
    pre<T = TModelType>(
      method: 'bulkWrite' | RegE***REMOVED***p,
      fn: (
        this: T,
        ne***REMOVED***t: (err?: CallbackError) => void,
        ops: Array<AnyBulkWriteOperation<any>>,
        options?: mongodb.BulkWriteOptions & MongooseBulkWriteOptions
      ) => void | Promise<void>
    ): this;
    /* method createCollection */
    pre<T = TModelType>(
      method: 'createCollection' | RegE***REMOVED***p,
      fn: (
        this: T,
        ne***REMOVED***t: (err?: CallbackError) => void,
        options?: mongodb.CreateCollectionOptions & Pick<SchemaOptions, 'e***REMOVED***pires'>
      ) => void | Promise<void>
    ): this;

    /** Object of currently defined query helpers on this schema. */
    query: TQueryHelpers;

    /** Adds a method call to the queue. */
    queue(name: string, args: any[]): this;

    /** Removes the given `path` (or [`paths`]). */
    remove(paths: string | Array<string>): this;

    /** Removes inde***REMOVED*** by name or inde***REMOVED*** spec */
    remove(inde***REMOVED***: string | AnyObject): this;

    /** Returns an Array of path strings that are required by this schema. */
    requiredPaths(invalidate?: boolean): string[];

    /** Sets a schema option. */
    set<K e***REMOVED***tends keyof SchemaOptions>(key: K, value: SchemaOptions[K], _tags?: any): this;

    /** Adds static "class" methods to Models compiled from this schema. */
    static<K e***REMOVED***tends keyof TStaticMethods>(name: K, fn: TStaticMethods[K]): this;
    static(obj: { [F in keyof TStaticMethods]: TStaticMethods[F] } & { [name: string]: (this: TModelType, ...args: any[]) => any }): this;
    static(name: string, fn: (this: TModelType, ...args: any[]) => any): this;

    /** Object of currently defined statics on this schema. */
    statics: { [F in keyof TStaticMethods]: TStaticMethods[F] } &
    { [name: string]: (this: TModelType, ...args: any[]) => unknown };

    /** Creates a virtual type with the given name. */
    virtual<T = HydratedDocument<DocType, TVirtuals & TInstanceMethods, TQueryHelpers>>(
      name: keyof TVirtuals | string,
      options?: VirtualTypeOptions<T, DocType>
    ): VirtualType<T>;

    /** Object of currently defined virtuals on this schema */
    virtuals: TVirtuals;

    /** Returns the virtual type with the given `name`. */
    virtualpath<T = THydratedDocumentType>(name: string): VirtualType<T> | null;

    static ObjectId: typeof Schema.Types.ObjectId;
  }

  e***REMOVED***port type NumberSchemaDefinition = typeof Number | 'number' | 'Number' | typeof Schema.Types.Number;
  e***REMOVED***port type StringSchemaDefinition = typeof String | 'string' | 'String' | typeof Schema.Types.String;
  e***REMOVED***port type BooleanSchemaDefinition = typeof Boolean | 'boolean' | 'Boolean' | typeof Schema.Types.Boolean;
  e***REMOVED***port type DateSchemaDefinition = DateConstructor | 'date' | 'Date' | typeof Schema.Types.Date;
  e***REMOVED***port type ObjectIdSchemaDefinition = 'ObjectId' | 'ObjectID' | typeof Schema.Types.ObjectId;

  e***REMOVED***port type SchemaDefinitionWithBuiltInClass<T> = T e***REMOVED***tends number
    ? NumberSchemaDefinition
    : T e***REMOVED***tends string
      ? StringSchemaDefinition
      : T e***REMOVED***tends boolean
        ? BooleanSchemaDefinition
        : T e***REMOVED***tends NativeDate
          ? DateSchemaDefinition
          : (Function | string);

  e***REMOVED***port type SchemaDefinitionProperty<T = undefined, EnforcedDocType = any> = SchemaDefinitionWithBuiltInClass<T> |
  SchemaTypeOptions<T e***REMOVED***tends undefined ? any : T, EnforcedDocType> |
    typeof SchemaType |
  Schema<any, any, any> |
  Schema<any, any, any>[] |
  SchemaTypeOptions<T e***REMOVED***tends undefined ? any : Unpacked<T>, EnforcedDocType>[] |
  Function[] |
  SchemaDefinition<T, EnforcedDocType> |
  SchemaDefinition<Unpacked<T>, EnforcedDocType>[] |
    typeof Schema.Types.Mi***REMOVED***ed |
  Mi***REMOVED***edSchemaTypeOptions<EnforcedDocType>;

  e***REMOVED***port type SchemaDefinition<T = undefined, EnforcedDocType = any> = T e***REMOVED***tends undefined
    ? { [path: string]: SchemaDefinitionProperty; }
    : { [path in keyof T]?: SchemaDefinitionProperty<T[path], EnforcedDocType>; };

  e***REMOVED***port type AnyArray<T> = T[] | ReadonlyArray<T>;
  e***REMOVED***port type E***REMOVED***tractMongooseArray<T> = T e***REMOVED***tends Types.Array<any> ? AnyArray<Unpacked<T>> : T;

  e***REMOVED***port interface Mi***REMOVED***edSchemaTypeOptions<EnforcedDocType> e***REMOVED***tends SchemaTypeOptions<Schema.Types.Mi***REMOVED***ed, EnforcedDocType> {
    type: typeof Schema.Types.Mi***REMOVED***ed;
  }

  e***REMOVED***port type RefType =
    | number
    | string
    | Buffer
    | undefined
    | Types.ObjectId
    | Types.Buffer
    | typeof Schema.Types.Number
    | typeof Schema.Types.String
    | typeof Schema.Types.Buffer
    | typeof Schema.Types.ObjectId;


  e***REMOVED***port type InferId<T> = T e***REMOVED***tends { _id?: any } ? T['_id'] : Types.ObjectId;

  e***REMOVED***port interface VirtualTypeOptions<HydratedDocType = Document, DocType = unknown> {
    /** If `ref` is not nullish, this becomes a populated virtual. */
    ref?: string | Function;

    /** The local field to populate on if this is a populated virtual. */
    localField?: string | ((this: HydratedDocType, doc: HydratedDocType) => string);

    /** The foreign field to populate on if this is a populated virtual. */
    foreignField?: string | ((this: HydratedDocType, doc: HydratedDocType) => string);

    /**
     * By default, a populated virtual is an array. If you set `justOne`,
     * the populated virtual will be a single doc or `null`.
     */
    justOne?: boolean;

    /** If you set this to `true`, Mongoose will call any custom getters you defined on this virtual. */
    getters?: boolean;

    /**
     * If you set this to `true`, `populate()` will set this virtual to the number of populated
     * documents, as opposed to the documents themselves, using `Query#countDocuments()`.
     */
    count?: boolean;

    /** Add an e***REMOVED***tra match condition to `populate()`. */
    match?: FilterQuery<any> | ((doc: Record<string, any>, virtual?: this) => Record<string, any> | null);

    /** Add a default `limit` to the `populate()` query. */
    limit?: number;

    /** Add a default `skip` to the `populate()` query. */
    skip?: number;

    /**
     * For legacy reasons, `limit` with `populate()` may give incorrect results because it only
     * e***REMOVED***ecutes a single query for every document being populated. If you set `perDocumentLimit`,
     * Mongoose will ensure correct `limit` per document by e***REMOVED***ecuting a separate query for each
     * document to `populate()`. For e***REMOVED***ample, `.find().populate({ path: 'test', perDocumentLimit: 2 })`
     * will e***REMOVED***ecute 2 additional queries if `.find()` returns 2 documents.
     */
    perDocumentLimit?: number;

    /** Additional options like `limit` and `lean`. */
    options?: QueryOptions<DocType> & { match?: AnyObject };

    /** If true and the given `name` is a direct child of an array, apply the virtual to the array rather than the elements. */
    applyToArray?: boolean;

    /** Additional options for plugins */
    [e***REMOVED***tra: string]: any;
  }

  e***REMOVED***port class VirtualType<HydratedDocType> {
    /** Applies getters to `value`. */
    applyGetters(value: any, doc: Document): any;

    /** Applies setters to `value`. */
    applySetters(value: any, doc: Document): any;

    /** Adds a custom getter to this virtual. */
    get<T = HydratedDocType>(fn: (this: T, value: any, virtualType: VirtualType<T>, doc: T) => any): this;

    /** Adds a custom setter to this virtual. */
    set<T = HydratedDocType>(fn: (this: T, value: any, virtualType: VirtualType<T>, doc: T) => void): this;
  }

  e***REMOVED***port type ReturnsNewDoc = { new: true } | { returnOriginal: false } | { returnDocument: 'after' };

  e***REMOVED***port type ProjectionElementType = number | string;
  e***REMOVED***port type ProjectionType<T> = { [P in keyof T]?: ProjectionElementType } | AnyObject | string;

  e***REMOVED***port type SortValues = SortOrder;

  e***REMOVED***port type SortOrder = -1 | 1 | 'asc' | 'ascending' | 'desc' | 'descending';

  type _UpdateQuery<TSchema, AdditionalProperties = AnyObject> = {
    /** @see https://www.mongodb.com/docs/manual/reference/operator/update-field/ */
    $currentDate?: AnyKeys<TSchema> & AdditionalProperties;
    $inc?: AnyKeys<TSchema> & AdditionalProperties;
    $min?: AnyKeys<TSchema> & AdditionalProperties;
    $ma***REMOVED***?: AnyKeys<TSchema> & AdditionalProperties;
    $mul?: AnyKeys<TSchema> & AdditionalProperties;
    $rename?: Record<string, string>;
    $set?: AnyKeys<TSchema> & AdditionalProperties;
    $setOnInsert?: AnyKeys<TSchema> & AdditionalProperties;
    $unset?: AnyKeys<TSchema> & AdditionalProperties;

    /** @see https://www.mongodb.com/docs/manual/reference/operator/update-array/ */
    $addToSet?: AnyKeys<TSchema> & AdditionalProperties;
    $pop?: AnyKeys<TSchema> & AdditionalProperties;
    $pull?: AnyKeys<TSchema> & AdditionalProperties;
    $push?: AnyKeys<TSchema> & AdditionalProperties;
    $pullAll?: AnyKeys<TSchema> & AdditionalProperties;

    /** @see https://www.mongodb.com/docs/manual/reference/operator/update-bitwise/ */
    $bit?: AnyKeys<TSchema>;
  };

  e***REMOVED***port type UpdateWithAggregationPipeline = UpdateAggregationStage[];
  e***REMOVED***port type UpdateAggregationStage = { $addFields: any } |
  { $set: any } |
  { $project: any } |
  { $unset: any } |
  { $replaceRoot: any } |
  { $replaceWith: any };

  /**
   * Update query command to perform on the document
   * @e***REMOVED***ample
   * ```js
   * { age: 30 }
   * ```
   */
  e***REMOVED***port type UpdateQuery<T> = AnyKeys<T> & _UpdateQuery<T> & AnyObject;

  /**
   * A more strict form of UpdateQuery that enforces updating only
   * known top-level properties.
   * @e***REMOVED***ample
   * ```ts
   * function updateUser(_id: mongoose.Types.ObjectId, update: UpdateQueryKnownOnly<IUser>) {
   *   return User.updateOne({ _id }, update);
   * }
   * ```
   */
  e***REMOVED***port type UpdateQueryKnownOnly<T> = _UpdateQuery<T, {}>;

  e***REMOVED***port type FlattenMaps<T> = {
    [K in keyof T]: FlattenProperty<T[K]>;
  };

  /**
   * Converts any Buffer properties into mongodb.Binary instances, which is what `lean()` returns
   */
  e***REMOVED***port type BufferToBinary<T> = T e***REMOVED***tends TreatAsPrimitives ? T : T e***REMOVED***tends Record<string, any> ? {
    [K in keyof T]: T[K] e***REMOVED***tends Buffer
      ? mongodb.Binary
      : T[K] e***REMOVED***tends (Buffer | null | undefined)
        ? mongodb.Binary | null | undefined
        : T[K] e***REMOVED***tends Types.DocumentArray<infer ItemType>
            ? Types.DocumentArray<BufferToBinary<ItemType>>
            : T[K] e***REMOVED***tends Types.Subdocument<unknown, unknown, infer SubdocType>
              ? HydratedSingleSubdocument<SubdocType>
              : BufferToBinary<T[K]>;
  } : T;

  /**
   * Converts any Buffer properties into { type: 'buffer', data: [1, 2, 3] } format for JSON serialization
   */
  e***REMOVED***port type BufferToJSON<T> = T e***REMOVED***tends TreatAsPrimitives ? T : T e***REMOVED***tends Record<string, any> ? {
    [K in keyof T]: T[K] e***REMOVED***tends Buffer
      ? { type: 'buffer', data: number[] }
      : T[K] e***REMOVED***tends (Buffer | null | undefined)
        ? { type: 'buffer', data: number[] } | null | undefined
        : T[K] e***REMOVED***tends Types.DocumentArray<infer ItemType>
            ? Types.DocumentArray<BufferToBinary<ItemType>>
            : T[K] e***REMOVED***tends Types.Subdocument<unknown, unknown, infer SubdocType>
              ? HydratedSingleSubdocument<SubdocType>
              : BufferToBinary<T[K]>;
  } : T;

  /**
   * Converts any ObjectId properties into strings for JSON serialization
   */
  e***REMOVED***port type ObjectIdToString<T> = T e***REMOVED***tends TreatAsPrimitives ? T : T e***REMOVED***tends Record<string, any> ? {
    [K in keyof T]: T[K] e***REMOVED***tends mongodb.ObjectId
      ? string
      : T[K] e***REMOVED***tends (mongodb.ObjectId | null | undefined)
        ? string | null | undefined
        : T[K] e***REMOVED***tends Types.DocumentArray<infer ItemType>
            ? Types.DocumentArray<ObjectIdToString<ItemType>>
            : T[K] e***REMOVED***tends Types.Subdocument<unknown, unknown, infer SubdocType>
              ? HydratedSingleSubdocument<ObjectIdToString<SubdocType>>
              : ObjectIdToString<T[K]>;
  } : T;

  /**
   * Converts any Date properties into strings for JSON serialization
   */
  e***REMOVED***port type DateToString<T> = T e***REMOVED***tends TreatAsPrimitives ? T : T e***REMOVED***tends Record<string, any> ? {
    [K in keyof T]: T[K] e***REMOVED***tends NativeDate
      ? string
      : T[K] e***REMOVED***tends (NativeDate | null | undefined)
        ? string | null | undefined
        : T[K] e***REMOVED***tends Types.DocumentArray<infer ItemType>
            ? Types.DocumentArray<DateToString<ItemType>>
            : T[K] e***REMOVED***tends Types.Subdocument<unknown, unknown, infer SubdocType>
              ? HydratedSingleSubdocument<DateToString<SubdocType>>
              : DateToString<T[K]>;
  } : T;

  /**
   * Converts any Mongoose subdocuments (single nested or doc arrays) into POJO equivalents
   */
  e***REMOVED***port type SubdocsToPOJOs<T> = T e***REMOVED***tends TreatAsPrimitives ? T : T e***REMOVED***tends Record<string, any> ? {
    [K in keyof T]: T[K] e***REMOVED***tends NativeDate
      ? string
      : T[K] e***REMOVED***tends (NativeDate | null | undefined)
        ? string | null | undefined
        : T[K] e***REMOVED***tends Types.DocumentArray<infer ItemType>
            ? ItemType[]
            : T[K] e***REMOVED***tends Types.Subdocument<unknown, unknown, infer SubdocType>
              ? SubdocType
              : SubdocsToPOJOs<T[K]>;
  } : T;

  e***REMOVED***port type JSONSerialized<T> = SubdocsToPOJOs<
    FlattenMaps<
      BufferToJSON<
        ObjectIdToString<
          DateToString<T>
        >
      >
    >
  >;

  /**
   * Separate type is needed for properties of union type (for e***REMOVED***ample, Types.DocumentArray | undefined) to apply conditional check to each member of it
   * https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types
   */
  type FlattenProperty<T> = T e***REMOVED***tends Map<any, infer V>
    ? Record<string, V> : T e***REMOVED***tends TreatAsPrimitives
      ? T : T e***REMOVED***tends Types.DocumentArray<infer ItemType>
        ? Types.DocumentArray<FlattenMaps<ItemType>> : FlattenMaps<T>;

  e***REMOVED***port type actualPrimitives = string | boolean | number | bigint | symbol | null | undefined;
  e***REMOVED***port type TreatAsPrimitives = actualPrimitives | NativeDate | RegE***REMOVED***p | symbol | Error | BigInt | Types.ObjectId | Buffer | Function | mongodb.Binary;

  e***REMOVED***port type SchemaDefinitionType<T> = T e***REMOVED***tends Document ? Omit<T, E***REMOVED***clude<keyof Document, '_id' | 'id' | '__v'>> : T;

  /**
   * Helper to choose the best option between two type helpers
   */
  e***REMOVED***port type _pickObject<T1, T2, Fallback> = T1 e***REMOVED***tends false ? T2 e***REMOVED***tends false ? Fallback : T2 : T1;

  /* for ts-mongoose */
  e***REMOVED***port class mquery { }

  e***REMOVED***port function overwriteMiddlewareResult(val: any): Kareem.OverwriteMiddlewareResult;

  e***REMOVED***port function skipMiddlewareFunction(val: any): Kareem.SkipWrappedFunction;

  e***REMOVED***port default mongoose;
}
