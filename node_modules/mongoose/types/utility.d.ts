declare module 'mongoose' {
  type IfAny<IFTYPE, THENTYPE, ELSETYPE = IFTYPE> = 0 e***REMOVED***tends (1 & IFTYPE) ? THENTYPE : ELSETYPE;
  type IfUnknown<IFTYPE, THENTYPE> = unknown e***REMOVED***tends IFTYPE ? THENTYPE : IFTYPE;

  type WithLevel1NestedPaths<T, K e***REMOVED***tends keyof T = keyof T> = {
    [P in K | NestedPaths<Required<T>, K>]: P e***REMOVED***tends K
      ? T[P]
      : P e***REMOVED***tends `${infer Key}.${infer Rest}`
        ? Key e***REMOVED***tends keyof T
          ? Rest e***REMOVED***tends keyof NonNullable<T[Key]>
            ? NonNullable<T[Key]>[Rest]
            : never
          : never
        : never;
  };

  type NestedPaths<T, K e***REMOVED***tends keyof T> = K e***REMOVED***tends string
    ? T[K] e***REMOVED***tends Record<string, any> | null | undefined
      ? `${K}.${keyof NonNullable<T[K]> & string}`
      : never
    : never;

  type WithoutUndefined<T> = T e***REMOVED***tends undefined ? never : T;

  /**
    * @summary Removes keys from a type
    * @description It helps to e***REMOVED***clude keys from a type
    * @param {T} T A generic type to be checked.
    * @param {K} K Keys from T that are to be e***REMOVED***cluded from the generic type
    * @returns T with the keys in K e***REMOVED***cluded
    */
  type E***REMOVED***cludeKeys<T, K e***REMOVED***tends keyof T> = {
    [P in keyof T as P e***REMOVED***tends K ? never : P]: T[P];
  };

  type Unpacked<T> = T e***REMOVED***tends (infer U)[] ?
    U :
    T e***REMOVED***tends ReadonlyArray<infer U> ? U : T;

  type UnpackedIntersection<T, U> = T e***REMOVED***tends null ? null : T e***REMOVED***tends (infer A)[]
    ? (Omit<A, keyof U> & U)[]
    : keyof U e***REMOVED***tends never
      ? T
      : Omit<T, keyof U> & U;

  type MergeType<A, B> = Omit<A, keyof B> & B;

  /**
   * @summary Converts Unions to one record "object".
   * @description It makes intellisense dialog bo***REMOVED*** easier to read as a single object instead of showing that in multiple object unions.
   * @param {T} T The type to be converted.
   */
  type FlatRecord<T> = { [K in keyof T]: T[K] };

  /**
    * @summary Checks if a type is "Record" or "any".
    * @description It Helps to check if user has provided schema type "EnforcedDocType"
    * @param {T} T A generic type to be checked.
    * @returns true if {@link T} is Record OR false if {@link T} is of any type.
    */
  type IsItRecordAndNotAny<T> = IfEquals<T, any, false, T e***REMOVED***tends Record<any, any> ? true : false>;

/**
 * @summary Checks if two types are identical.
 * @param {T} T The first type to be compared with {@link U}.
 * @param {U} U The seconde type to be compared with {@link T}.
 * @param {Y} Y A type to be returned if {@link T} &  {@link U} are identical.
 * @param {N} N A type to be returned if {@link T} &  {@link U} are not identical.
 */
type IfEquals<T, U, Y = true, N = false> =
    (<G>() => G e***REMOVED***tends T ? 1 : 0) e***REMOVED***tends
    (<G>() => G e***REMOVED***tends U ? 1 : 0) ? Y : N;

/**
 * @summary E***REMOVED***tracts 'this' parameter from a function, if it e***REMOVED***ists. Otherwise, returns fallback.
 * @param {T} T Function type to e***REMOVED***tract 'this' parameter from.
 * @param {F} F Fallback type to return if 'this' parameter does not e***REMOVED***ist.
 */
type ThisParameter<T, F> = T e***REMOVED***tends { (this: infer This): void }
  ? This
  : F;

/**
 * @summary Decorates all functions in an object with 'this' parameter.
 * @param {T} T Object with functions as values to add 'D' parameter to as 'this'. {@link D}
 * @param {D} D The type to be added as 'this' parameter to all functions in {@link T}.
 */
type AddThisParameter<T, D> = {
  [K in keyof T]: T[K] e***REMOVED***tends (...args: infer A) => infer R
    ? ThisParameter<T[K], unknown> e***REMOVED***tends unknown
      ? (this: D, ...args: A) => R
      : T[K]
    : T[K];
};

}
