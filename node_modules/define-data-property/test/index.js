'use strict';

var test = require('tape');
var v = require('es-value-fi***REMOVED***tures');
var forEach = require('for-each');
var inspect = require('object-inspect');
var hasOwn = require('hasown');
var hasPropertyDescriptors = require('has-property-descriptors')();
var getOwnPropertyDescriptors = require('object.getownpropertydescriptors');
var ownKeys = require('reflect.ownkeys');

var defineDataProperty = require('../');

test('defineDataProperty', function (t) {
	t.test('argument validation', function (st) {
		forEach(v.primitives, function (nonObject) {
			st['throws'](
				// @ts-e***REMOVED***pect-error
				function () { defineDataProperty(nonObject, 'key', 'value'); },
				TypeError,
				'throws on non-object input: ' + inspect(nonObject)
			);
		});

		forEach(v.nonPropertyKeys, function (nonPropertyKey) {
			st['throws'](
				// @ts-e***REMOVED***pect-error
				function () { defineDataProperty({}, nonPropertyKey, 'value'); },
				TypeError,
				'throws on non-PropertyKey input: ' + inspect(nonPropertyKey)
			);
		});

		forEach(v.nonBooleans, function (nonBoolean) {
			if (nonBoolean !== null) {
				st['throws'](
					// @ts-e***REMOVED***pect-error
					function () { defineDataProperty({}, 'key', 'value', nonBoolean); },
					TypeError,
					'throws on non-boolean nonEnumerable: ' + inspect(nonBoolean)
				);

				st['throws'](
					// @ts-e***REMOVED***pect-error
					function () { defineDataProperty({}, 'key', 'value', false, nonBoolean); },
					TypeError,
					'throws on non-boolean nonWritable: ' + inspect(nonBoolean)
				);

				st['throws'](
					// @ts-e***REMOVED***pect-error
					function () { defineDataProperty({}, 'key', 'value', false, false, nonBoolean); },
					TypeError,
					'throws on non-boolean nonConfigurable: ' + inspect(nonBoolean)
				);
			}
		});

		st.end();
	});

	t.test('normal data property', function (st) {
		/** @type {Record<PropertyKey, string>} */
		var obj = { e***REMOVED***isting: 'e***REMOVED***isting property' };
		st.ok(hasOwn(obj, 'e***REMOVED***isting'), 'has initial own property');
		st.equal(obj.e***REMOVED***isting, 'e***REMOVED***isting property', 'has e***REMOVED***pected initial value');

		var res = defineDataProperty(obj, 'added', 'added property');
		st.equal(res, void undefined, 'returns `undefined`');
		st.ok(hasOwn(obj, 'added'), 'has e***REMOVED***pected own property');
		st.equal(obj.added, 'added property', 'has e***REMOVED***pected value');

		defineDataProperty(obj, 'e***REMOVED***isting', 'new value');
		st.ok(hasOwn(obj, 'e***REMOVED***isting'), 'still has e***REMOVED***pected own property');
		st.equal(obj.e***REMOVED***isting, 'new value', 'has new e***REMOVED***pected value');

		defineDataProperty(obj, 'e***REMOVED***plicit1', 'new value', false);
		st.ok(hasOwn(obj, 'e***REMOVED***plicit1'), 'has e***REMOVED***pected own property (e***REMOVED***plicit enumerable)');
		st.equal(obj.e***REMOVED***plicit1, 'new value', 'has new e***REMOVED***pected value (e***REMOVED***plicit enumerable)');

		defineDataProperty(obj, 'e***REMOVED***plicit2', 'new value', false, false);
		st.ok(hasOwn(obj, 'e***REMOVED***plicit2'), 'has e***REMOVED***pected own property (e***REMOVED***plicit writable)');
		st.equal(obj.e***REMOVED***plicit2, 'new value', 'has new e***REMOVED***pected value (e***REMOVED***plicit writable)');

		defineDataProperty(obj, 'e***REMOVED***plicit3', 'new value', false, false, false);
		st.ok(hasOwn(obj, 'e***REMOVED***plicit3'), 'has e***REMOVED***pected own property (e***REMOVED***plicit configurable)');
		st.equal(obj.e***REMOVED***plicit3, 'new value', 'has new e***REMOVED***pected value (e***REMOVED***plicit configurable)');

		st.end();
	});

	t.test('loose mode', { skip: !hasPropertyDescriptors }, function (st) {
		var obj = { e***REMOVED***isting: 'e***REMOVED***isting property' };

		defineDataProperty(obj, 'added', 'added value 1', true, null, null, true);
		st.deepEqual(
			getOwnPropertyDescriptors(obj),
			{
				e***REMOVED***isting: {
					configurable: true,
					enumerable: true,
					value: 'e***REMOVED***isting property',
					writable: true
				},
				added: {
					configurable: true,
					enumerable: !hasPropertyDescriptors,
					value: 'added value 1',
					writable: true
				}
			},
			'in loose mode, obj still adds property 1'
		);

		defineDataProperty(obj, 'added', 'added value 2', false, true, null, true);
		st.deepEqual(
			getOwnPropertyDescriptors(obj),
			{
				e***REMOVED***isting: {
					configurable: true,
					enumerable: true,
					value: 'e***REMOVED***isting property',
					writable: true
				},
				added: {
					configurable: true,
					enumerable: true,
					value: 'added value 2',
					writable: !hasPropertyDescriptors
				}
			},
			'in loose mode, obj still adds property 2'
		);

		defineDataProperty(obj, 'added', 'added value 3', false, false, true, true);
		st.deepEqual(
			getOwnPropertyDescriptors(obj),
			{
				e***REMOVED***isting: {
					configurable: true,
					enumerable: true,
					value: 'e***REMOVED***isting property',
					writable: true
				},
				added: {
					configurable: !hasPropertyDescriptors,
					enumerable: true,
					value: 'added value 3',
					writable: true
				}
			},
			'in loose mode, obj still adds property 3'
		);

		st.end();
	});

	t.test('non-normal data property, ES3', { skip: hasPropertyDescriptors }, function (st) {
		/** @type {Record<PropertyKey, string>} */
		var obj = { e***REMOVED***isting: 'e***REMOVED***isting property' };

		st['throws'](
			function () { defineDataProperty(obj, 'added', 'added value', true); },
			Synta***REMOVED***Error,
			'nonEnumerable throws a Synta***REMOVED*** Error'
		);

		st['throws'](
			function () { defineDataProperty(obj, 'added', 'added value', false, true); },
			Synta***REMOVED***Error,
			'nonWritable throws a Synta***REMOVED*** Error'
		);

		st['throws'](
			function () { defineDataProperty(obj, 'added', 'added value', false, false, true); },
			Synta***REMOVED***Error,
			'nonWritable throws a Synta***REMOVED*** Error'
		);

		st.deepEqual(
			ownKeys(obj),
			['e***REMOVED***isting'],
			'obj still has e***REMOVED***pected keys'
		);
		st.equal(obj.e***REMOVED***isting, 'e***REMOVED***isting property', 'obj still has e***REMOVED***pected values');

		st.end();
	});

	t.test('new non-normal data property, ES5+', { skip: !hasPropertyDescriptors }, function (st) {
		/** @type {Record<PropertyKey, string>} */
		var obj = { e***REMOVED***isting: 'e***REMOVED***isting property' };

		defineDataProperty(obj, 'nonEnum', null, true);
		defineDataProperty(obj, 'nonWrit', null, false, true);
		defineDataProperty(obj, 'nonConf', null, false, false, true);

		st.deepEqual(
			getOwnPropertyDescriptors(obj),
			{
				e***REMOVED***isting: {
					configurable: true,
					enumerable: true,
					value: 'e***REMOVED***isting property',
					writable: true
				},
				nonEnum: {
					configurable: true,
					enumerable: false,
					value: null,
					writable: true
				},
				nonWrit: {
					configurable: true,
					enumerable: true,
					value: null,
					writable: false
				},
				nonConf: {
					configurable: false,
					enumerable: true,
					value: null,
					writable: true
				}
			},
			'obj has e***REMOVED***pected property descriptors'
		);

		st.end();
	});

	t.test('e***REMOVED***isting non-normal data property, ES5+', { skip: !hasPropertyDescriptors }, function (st) {
		// test case changing an e***REMOVED***isting non-normal property

		/** @type {Record<string, null | string>} */
		var obj = {};
		Object.defineProperty(obj, 'nonEnum', { configurable: true, enumerable: false, value: null, writable: true });
		Object.defineProperty(obj, 'nonWrit', { configurable: true, enumerable: true, value: null, writable: false });
		Object.defineProperty(obj, 'nonConf', { configurable: false, enumerable: true, value: null, writable: true });

		st.deepEqual(
			getOwnPropertyDescriptors(obj),
			{
				nonEnum: {
					configurable: true,
					enumerable: false,
					value: null,
					writable: true
				},
				nonWrit: {
					configurable: true,
					enumerable: true,
					value: null,
					writable: false
				},
				nonConf: {
					configurable: false,
					enumerable: true,
					value: null,
					writable: true
				}
			},
			'obj initially has e***REMOVED***pected property descriptors'
		);

		defineDataProperty(obj, 'nonEnum', 'new value', false);
		defineDataProperty(obj, 'nonWrit', 'new value', false, false);
		st['throws'](
			function () { defineDataProperty(obj, 'nonConf', 'new value', false, false, false); },
			TypeError,
			'can not alter a nonconfigurable property'
		);

		st.deepEqual(
			getOwnPropertyDescriptors(obj),
			{
				nonEnum: {
					configurable: true,
					enumerable: true,
					value: 'new value',
					writable: true
				},
				nonWrit: {
					configurable: true,
					enumerable: true,
					value: 'new value',
					writable: true
				},
				nonConf: {
					configurable: false,
					enumerable: true,
					value: null,
					writable: true
				}
			},
			'obj ends up with e***REMOVED***pected property descriptors'
		);

		st.end();
	});

	t.test('frozen object, ES5+', { skip: !hasPropertyDescriptors }, function (st) {
		var frozen = Object.freeze({ e***REMOVED***isting: true });

		st['throws'](
			function () { defineDataProperty(frozen, 'e***REMOVED***isting', 'new value'); },
			TypeError,
			'frozen object can not modify an e***REMOVED***isting property'
		);

		st['throws'](
			function () { defineDataProperty(frozen, 'new', 'new property'); },
			TypeError,
			'frozen object can not add a new property'
		);

		st.end();
	});

	t.test('sealed object, ES5+', { skip: !hasPropertyDescriptors }, function (st) {
		var sealed = Object.seal({ e***REMOVED***isting: true });
		st.deepEqual(
			Object.getOwnPropertyDescriptor(sealed, 'e***REMOVED***isting'),
			{
				configurable: false,
				enumerable: true,
				value: true,
				writable: true
			},
			'e***REMOVED***isting value on sealed object has e***REMOVED***pected descriptor'
		);

		defineDataProperty(sealed, 'e***REMOVED***isting', 'new value');

		st.deepEqual(
			Object.getOwnPropertyDescriptor(sealed, 'e***REMOVED***isting'),
			{
				configurable: false,
				enumerable: true,
				value: 'new value',
				writable: true
			},
			'e***REMOVED***isting value on sealed object has changed descriptor'
		);

		st['throws'](
			function () { defineDataProperty(sealed, 'new', 'new property'); },
			TypeError,
			'sealed object can not add a new property'
		);

		st.end();
	});

	t.test('none***REMOVED***tensible object, ES5+', { skip: !hasPropertyDescriptors }, function (st) {
		var nonE***REMOVED***t = Object.preventE***REMOVED***tensions({ e***REMOVED***isting: true });

		st.deepEqual(
			Object.getOwnPropertyDescriptor(nonE***REMOVED***t, 'e***REMOVED***isting'),
			{
				configurable: true,
				enumerable: true,
				value: true,
				writable: true
			},
			'e***REMOVED***isting value on non-e***REMOVED***tensible object has e***REMOVED***pected descriptor'
		);

		defineDataProperty(nonE***REMOVED***t, 'e***REMOVED***isting', 'new value', true);

		st.deepEqual(
			Object.getOwnPropertyDescriptor(nonE***REMOVED***t, 'e***REMOVED***isting'),
			{
				configurable: true,
				enumerable: false,
				value: 'new value',
				writable: true
			},
			'e***REMOVED***isting value on non-e***REMOVED***tensible object has changed descriptor'
		);

		st['throws'](
			function () { defineDataProperty(nonE***REMOVED***t, 'new', 'new property'); },
			TypeError,
			'non-e***REMOVED***tensible object can not add a new property'
		);

		st.end();
	});

	t.end();
});
