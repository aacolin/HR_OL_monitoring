var isCore = require('is-core-module');
var fs = require('fs');
var path = require('path');
var getHomedir = require('./homedir');
var caller = require('./caller');
var nodeModulesPaths = require('./node-modules-paths');
var normalizeOptions = require('./normalize-options');

var realpathFS = process.platform !== 'win32' && fs.realpathSync && typeof fs.realpathSync.native === 'function' ? fs.realpathSync.native : fs.realpathSync;

var homedir = getHomedir();
var defaultPaths = function () {
    return [
        path.join(homedir, '.node_modules'),
        path.join(homedir, '.node_libraries')
    ];
};

var defaultIsFile = function isFile(file) {
    try {
        var stat = fs.statSync(file, { throwIfNoEntry: false });
    } catch (e) {
        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
        throw e;
    }
    return !!stat && (stat.isFile() || stat.isFIFO());
};

var defaultIsDir = function isDirectory(dir) {
    try {
        var stat = fs.statSync(dir, { throwIfNoEntry: false });
    } catch (e) {
        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
        throw e;
    }
    return !!stat && stat.isDirectory();
};

var defaultRealpathSync = function realpathSync(***REMOVED***) {
    try {
        return realpathFS(***REMOVED***);
    } catch (realpathErr) {
        if (realpathErr.code !== 'ENOENT') {
            throw realpathErr;
        }
    }
    return ***REMOVED***;
};

var maybeRealpathSync = function maybeRealpathSync(realpathSync, ***REMOVED***, opts) {
    if (opts && opts.preserveSymlinks === false) {
        return realpathSync(***REMOVED***);
    }
    return ***REMOVED***;
};

var defaultReadPackageSync = function defaultReadPackageSync(readFileSync, pkgfile) {
    var body = readFileSync(pkgfile);
    try {
        var pkg = JSON.parse(body);
        return pkg;
    } catch (jsonErr) {}
};

var getPackageCandidates = function getPackageCandidates(***REMOVED***, start, opts) {
    var dirs = nodeModulesPaths(start, opts, ***REMOVED***);
    for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], ***REMOVED***);
    }
    return dirs;
};

module.e***REMOVED***ports = function resolveSync(***REMOVED***, options) {
    if (typeof ***REMOVED*** !== 'string') {
        throw new TypeError('Path must be a string.');
    }
    var opts = normalizeOptions(***REMOVED***, options);

    var isFile = opts.isFile || defaultIsFile;
    var readFileSync = opts.readFileSync || fs.readFileSync;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var realpathSync = opts.realpathSync || defaultRealpathSync;
    var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
    if (opts.readFileSync && opts.readPackageSync) {
        throw new TypeError('`readFileSync` and `readPackageSync` are mutually e***REMOVED***clusive.');
    }
    var packageIterator = opts.packageIterator;

    var e***REMOVED***tensions = opts.e***REMOVED***tensions || ['.js'];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;

    opts.paths = opts.paths || defaultPaths();

    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);

    if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(***REMOVED***)) {
        var res = path.resolve(absoluteStart, ***REMOVED***);
        if (***REMOVED*** === '.' || ***REMOVED*** === '..' || ***REMOVED***.slice(-1) === '/') res += '/';
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m) return maybeRealpathSync(realpathSync, m, opts);
    } else if (includeCoreModules && isCore(***REMOVED***)) {
        return ***REMOVED***;
    } else {
        var n = loadNodeModulesSync(***REMOVED***, absoluteStart);
        if (n) return maybeRealpathSync(realpathSync, n, opts);
    }

    var err = new Error("Cannot find module '" + ***REMOVED*** + "' from '" + parent + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;

    function loadAsFileSync(***REMOVED***) {
        var pkg = loadpkg(path.dirname(***REMOVED***));

        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
            var rfile = path.relative(pkg.dir, ***REMOVED***);
            var r = opts.pathFilter(pkg.pkg, ***REMOVED***, rfile);
            if (r) {
                ***REMOVED*** = path.resolve(pkg.dir, r); // eslint-disable-line no-param-reassign
            }
        }

        if (isFile(***REMOVED***)) {
            return ***REMOVED***;
        }

        for (var i = 0; i < e***REMOVED***tensions.length; i++) {
            var file = ***REMOVED*** + e***REMOVED***tensions[i];
            if (isFile(file)) {
                return file;
            }
        }
    }

    function loadpkg(dir) {
        if (dir === '' || dir === '/') return;
        if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
            return;
        }
        if ((/[/\\]node_modules[/\\]*$/).test(dir)) return;

        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), 'package.json');

        if (!isFile(pkgfile)) {
            return loadpkg(path.dirname(dir));
        }

        var pkg = readPackageSync(readFileSync, pkgfile);

        if (pkg && opts.packageFilter) {
            // v2 will pass pkgfile
            pkg = opts.packageFilter(pkg, /*pkgfile,*/ dir); // eslint-disable-line spaced-comment
        }

        return { pkg: pkg, dir: dir };
    }

    function loadAsDirectorySync(***REMOVED***) {
        var pkgfile = path.join(maybeRealpathSync(realpathSync, ***REMOVED***, opts), '/package.json');
        if (isFile(pkgfile)) {
            try {
                var pkg = readPackageSync(readFileSync, pkgfile);
            } catch (e) {}

            if (pkg && opts.packageFilter) {
                // v2 will pass pkgfile
                pkg = opts.packageFilter(pkg, /*pkgfile,*/ ***REMOVED***); // eslint-disable-line spaced-comment
            }

            if (pkg && pkg.main) {
                if (typeof pkg.main !== 'string') {
                    var mainError = new TypeError('package “' + pkg.name + '” `main` must be a string');
                    mainError.code = 'INVALID_PACKAGE_MAIN';
                    throw mainError;
                }
                if (pkg.main === '.' || pkg.main === './') {
                    pkg.main = 'inde***REMOVED***';
                }
                try {
                    var m = loadAsFileSync(path.resolve(***REMOVED***, pkg.main));
                    if (m) return m;
                    var n = loadAsDirectorySync(path.resolve(***REMOVED***, pkg.main));
                    if (n) return n;
                } catch (e) {}
            }
        }

        return loadAsFileSync(path.join(***REMOVED***, '/inde***REMOVED***'));
    }

    function loadNodeModulesSync(***REMOVED***, start) {
        var thunk = function () { return getPackageCandidates(***REMOVED***, start, opts); };
        var dirs = packageIterator ? packageIterator(***REMOVED***, start, thunk, opts) : thunk();

        for (var i = 0; i < dirs.length; i++) {
            var dir = dirs[i];
            if (isDirectory(path.dirname(dir))) {
                var m = loadAsFileSync(dir);
                if (m) return m;
                var n = loadAsDirectorySync(dir);
                if (n) return n;
            }
        }
    }
};
