'use strict';

var assert = require('assert');
var isE***REMOVED***pression = require('is-e***REMOVED***pression');
var characterParser = require('character-parser');
var error = require('pug-error');

module.e***REMOVED***ports = le***REMOVED***;
module.e***REMOVED***ports.Le***REMOVED***er = Le***REMOVED***er;
function le***REMOVED***(str, options) {
  var le***REMOVED***er = new Le***REMOVED***er(str, options);
  return JSON.parse(JSON.stringify(le***REMOVED***er.getTokens()));
}

/**
 * Initialize `Le***REMOVED***er` with the given `str`.
 *
 * @param {String} str
 * @param {String} filename
 * @api private
 */

function Le***REMOVED***er(str, options) {
  options = options || {};
  if (typeof str !== 'string') {
    throw new Error(
      'E***REMOVED***pected source code to be a string but got "' + typeof str + '"'
    );
  }
  if (typeof options !== 'object') {
    throw new Error(
      'E***REMOVED***pected "options" to be an object but got "' + typeof options + '"'
    );
  }
  //Strip any UTF-8 BOM off of the start of `str`, if it e***REMOVED***ists.
  str = str.replace(/^\uFEFF/, '');
  this.input = str.replace(/\r\n|\r/g, '\n');
  this.originalInput = this.input;
  this.filename = options.filename;
  this.interpolated = options.interpolated || false;
  this.lineno = options.startingLine || 1;
  this.colno = options.startingColumn || 1;
  this.plugins = options.plugins || [];
  this.indentStack = [0];
  this.indentRe = null;
  // If #{}, !{} or #[] synta***REMOVED*** is allowed when adding te***REMOVED***t
  this.interpolationAllowed = true;
  this.whitespaceRe = /[ \n\t]/;

  this.tokens = [];
  this.ended = false;
}

/**
 * Le***REMOVED***er prototype.
 */

Le***REMOVED***er.prototype = {
  constructor: Le***REMOVED***er,

  error: function(code, message) {
    var err = error(code, message, {
      line: this.lineno,
      column: this.colno,
      filename: this.filename,
      src: this.originalInput,
    });
    throw err;
  },

  assert: function(value, message) {
    if (!value) this.error('ASSERT_FAILED', message);
  },

  isE***REMOVED***pression: function(e***REMOVED***p) {
    return isE***REMOVED***pression(e***REMOVED***p, {
      throw: true,
    });
  },

  assertE***REMOVED***pression: function(e***REMOVED***p, noThrow) {
    //this verifies that a JavaScript e***REMOVED***pression is valid
    try {
      this.callLe***REMOVED***erFunction('isE***REMOVED***pression', e***REMOVED***p);
      return true;
    } catch (e***REMOVED***) {
      if (noThrow) return false;

      // not coming from acorn
      if (!e***REMOVED***.loc) throw e***REMOVED***;

      this.incrementLine(e***REMOVED***.loc.line - 1);
      this.incrementColumn(e***REMOVED***.loc.column);
      var msg =
        'Synta***REMOVED*** Error: ' + e***REMOVED***.message.replace(/ \([0-9]+:[0-9]+\)$/, '');
      this.error('SYNTAX_ERROR', msg);
    }
  },

  assertNestingCorrect: function(e***REMOVED***p) {
    //this verifies that code is properly nested, but allows
    //invalid JavaScript such as the contents of `attributes`
    var res = characterParser(e***REMOVED***p);
    if (res.isNesting()) {
      this.error(
        'INCORRECT_NESTING',
        'Nesting must match on e***REMOVED***pression `' + e***REMOVED***p + '`'
      );
    }
  },

  /**
   * Construct a token with the given `type` and `val`.
   *
   * @param {String} type
   * @param {String} val
   * @return {Object}
   * @api private
   */

  tok: function(type, val) {
    var res = {
      type: type,
      loc: {
        start: {
          line: this.lineno,
          column: this.colno,
        },
        filename: this.filename,
      },
    };

    if (val !== undefined) res.val = val;

    return res;
  },

  /**
   * Set the token's `loc.end` value.
   *
   * @param {Object} tok
   * @returns {Object}
   * @api private
   */

  tokEnd: function(tok) {
    tok.loc.end = {
      line: this.lineno,
      column: this.colno,
    };
    return tok;
  },

  /**
   * Increment `this.lineno` and reset `this.colno`.
   *
   * @param {Number} increment
   * @api private
   */

  incrementLine: function(increment) {
    this.lineno += increment;
    if (increment) this.colno = 1;
  },

  /**
   * Increment `this.colno`.
   *
   * @param {Number} increment
   * @api private
   */

  incrementColumn: function(increment) {
    this.colno += increment;
  },

  /**
   * Consume the given `len` of input.
   *
   * @param {Number} len
   * @api private
   */

  consume: function(len) {
    this.input = this.input.substr(len);
  },

  /**
   * Scan for `type` with the given `rege***REMOVED***p`.
   *
   * @param {String} type
   * @param {RegE***REMOVED***p} rege***REMOVED***p
   * @return {Object}
   * @api private
   */

  scan: function(rege***REMOVED***p, type) {
    var captures;
    if ((captures = rege***REMOVED***p.e***REMOVED***ec(this.input))) {
      var len = captures[0].length;
      var val = captures[1];
      var diff = len - (val ? val.length : 0);
      var tok = this.tok(type, val);
      this.consume(len);
      this.incrementColumn(diff);
      return tok;
    }
  },
  scanEndOfLine: function(rege***REMOVED***p, type) {
    var captures;
    if ((captures = rege***REMOVED***p.e***REMOVED***ec(this.input))) {
      var whitespaceLength = 0;
      var whitespace;
      var tok;
      if ((whitespace = /^([ ]+)([^ ]*)/.e***REMOVED***ec(captures[0]))) {
        whitespaceLength = whitespace[1].length;
        this.incrementColumn(whitespaceLength);
      }
      var newInput = this.input.substr(captures[0].length);
      if (newInput[0] === ':') {
        this.input = newInput;
        tok = this.tok(type, captures[1]);
        this.incrementColumn(captures[0].length - whitespaceLength);
        return tok;
      }
      if (/^[ \t]*(\n|$)/.test(newInput)) {
        this.input = newInput.substr(/^[ \t]*/.e***REMOVED***ec(newInput)[0].length);
        tok = this.tok(type, captures[1]);
        this.incrementColumn(captures[0].length - whitespaceLength);
        return tok;
      }
    }
  },

  /**
   * Return the inde***REMOVED***Of `(` or `{` or `[` / `)` or `}` or `]` delimiters.
   *
   * Make sure that when calling this function, colno is at the character
   * immediately before the beginning.
   *
   * @return {Number}
   * @api private
   */

  bracketE***REMOVED***pression: function(skip) {
    skip = skip || 0;
    var start = this.input[skip];
    assert(
      start === '(' || start === '{' || start === '[',
      'The start character should be "(", "{" or "["'
    );
    var end = characterParser.BRACKETS[start];
    var range;
    try {
      range = characterParser.parseUntil(this.input, end, {start: skip + 1});
    } catch (e***REMOVED***) {
      if (e***REMOVED***.inde***REMOVED*** !== undefined) {
        var id***REMOVED*** = e***REMOVED***.inde***REMOVED***;
        // starting from this.input[skip]
        var tmp = this.input.substr(skip).inde***REMOVED***Of('\n');
        // starting from this.input[0]
        var ne***REMOVED***tNewline = tmp + skip;
        var ptr = 0;
        while (id***REMOVED*** > ne***REMOVED***tNewline && tmp !== -1) {
          this.incrementLine(1);
          id***REMOVED*** -= ne***REMOVED***tNewline + 1;
          ptr += ne***REMOVED***tNewline + 1;
          tmp = ne***REMOVED***tNewline = this.input.substr(ptr).inde***REMOVED***Of('\n');
        }

        this.incrementColumn(id***REMOVED***);
      }
      if (e***REMOVED***.code === 'CHARACTER_PARSER:END_OF_STRING_REACHED') {
        this.error(
          'NO_END_BRACKET',
          'The end of the string reached with no closing bracket ' +
            end +
            ' found.'
        );
      } else if (e***REMOVED***.code === 'CHARACTER_PARSER:MISMATCHED_BRACKET') {
        this.error('BRACKET_MISMATCH', e***REMOVED***.message);
      }
      throw e***REMOVED***;
    }
    return range;
  },

  scanIndentation: function() {
    var captures, re;

    // established rege***REMOVED***p
    if (this.indentRe) {
      captures = this.indentRe.e***REMOVED***ec(this.input);
      // determine rege***REMOVED***p
    } else {
      // tabs
      re = /^\n(\t*) */;
      captures = re.e***REMOVED***ec(this.input);

      // spaces
      if (captures && !captures[1].length) {
        re = /^\n( *)/;
        captures = re.e***REMOVED***ec(this.input);
      }

      // established
      if (captures && captures[1].length) this.indentRe = re;
    }

    return captures;
  },

  /**
   * end-of-source.
   */

  eos: function() {
    if (this.input.length) return;
    if (this.interpolated) {
      this.error(
        'NO_END_BRACKET',
        'End of line was reached with no closing bracket for interpolation.'
      );
    }
    for (var i = 0; this.indentStack[i]; i++) {
      this.tokens.push(this.tokEnd(this.tok('outdent')));
    }
    this.tokens.push(this.tokEnd(this.tok('eos')));
    this.ended = true;
    return true;
  },

  /**
   * Blank line.
   */

  blank: function() {
    var captures;
    if ((captures = /^\n[ \t]*\n/.e***REMOVED***ec(this.input))) {
      this.consume(captures[0].length - 1);
      this.incrementLine(1);
      return true;
    }
  },

  /**
   * Comment.
   */

  comment: function() {
    var captures;
    if ((captures = /^\/\/(-)?([^\n]*)/.e***REMOVED***ec(this.input))) {
      this.consume(captures[0].length);
      var tok = this.tok('comment', captures[2]);
      tok.buffer = '-' != captures[1];
      this.interpolationAllowed = tok.buffer;
      this.tokens.push(tok);
      this.incrementColumn(captures[0].length);
      this.tokEnd(tok);
      this.callLe***REMOVED***erFunction('pipelessTe***REMOVED***t');
      return true;
    }
  },

  /**
   * Interpolated tag.
   */

  interpolation: function() {
    if (/^#\{/.test(this.input)) {
      var match = this.bracketE***REMOVED***pression(1);
      this.consume(match.end + 1);
      var tok = this.tok('interpolation', match.src);
      this.tokens.push(tok);
      this.incrementColumn(2); // '#{'
      this.assertE***REMOVED***pression(match.src);

      var splitted = match.src.split('\n');
      var lines = splitted.length - 1;
      this.incrementLine(lines);
      this.incrementColumn(splitted[lines].length + 1); // + 1 → '}'
      this.tokEnd(tok);
      return true;
    }
  },

  /**
   * Tag.
   */

  tag: function() {
    var captures;

    if ((captures = /^(\w(?:[-:\w]*\w)?)/.e***REMOVED***ec(this.input))) {
      var tok,
        name = captures[1],
        len = captures[0].length;
      this.consume(len);
      tok = this.tok('tag', name);
      this.tokens.push(tok);
      this.incrementColumn(len);
      this.tokEnd(tok);
      return true;
    }
  },

  /**
   * Filter.
   */

  filter: function(opts) {
    var tok = this.scan(/^:([\w\-]+)/, 'filter');
    var inInclude = opts && opts.inInclude;
    if (tok) {
      this.tokens.push(tok);
      this.incrementColumn(tok.val.length);
      this.tokEnd(tok);
      this.callLe***REMOVED***erFunction('attrs');
      if (!inInclude) {
        this.interpolationAllowed = false;
        this.callLe***REMOVED***erFunction('pipelessTe***REMOVED***t');
      }
      return true;
    }
  },

  /**
   * Doctype.
   */

  doctype: function() {
    var node = this.scanEndOfLine(/^doctype *([^\n]*)/, 'doctype');
    if (node) {
      this.tokens.push(this.tokEnd(node));
      return true;
    }
  },

  /**
   * Id.
   */

  id: function() {
    var tok = this.scan(/^#([\w-]+)/, 'id');
    if (tok) {
      this.tokens.push(tok);
      this.incrementColumn(tok.val.length);
      this.tokEnd(tok);
      return true;
    }
    if (/^#/.test(this.input)) {
      this.error(
        'INVALID_ID',
        '"' +
          /.[^ \t\(\#\.\:]*/.e***REMOVED***ec(this.input.substr(1))[0] +
          '" is not a valid ID.'
      );
    }
  },

  /**
   * Class.
   */

  className: function() {
    var tok = this.scan(/^\.([_a-z0-9\-]*[_a-z][_a-z0-9\-]*)/i, 'class');
    if (tok) {
      this.tokens.push(tok);
      this.incrementColumn(tok.val.length);
      this.tokEnd(tok);
      return true;
    }
    if (/^\.[_a-z0-9\-]+/i.test(this.input)) {
      this.error(
        'INVALID_CLASS_NAME',
        'Class names must contain at least one letter or underscore.'
      );
    }
    if (/^\./.test(this.input)) {
      this.error(
        'INVALID_CLASS_NAME',
        '"' +
          /.[^ \t\(\#\.\:]*/.e***REMOVED***ec(this.input.substr(1))[0] +
          '" is not a valid class name.  Class names can only contain "_", "-", a-z and 0-9, and must contain at least one of "_", or a-z'
      );
    }
  },

  /**
   * Te***REMOVED***t.
   */
  endInterpolation: function() {
    if (this.interpolated && this.input[0] === ']') {
      this.input = this.input.substr(1);
      this.ended = true;
      return true;
    }
  },
  addTe***REMOVED***t: function(type, value, prefi***REMOVED***, escaped) {
    var tok;
    if (value + prefi***REMOVED*** === '') return;
    prefi***REMOVED*** = prefi***REMOVED*** || '';
    escaped = escaped || 0;
    var inde***REMOVED***OfEnd = this.interpolated ? value.inde***REMOVED***Of(']') : -1;
    var inde***REMOVED***OfStart = this.interpolationAllowed ? value.inde***REMOVED***Of('#[') : -1;
    var inde***REMOVED***OfEscaped = this.interpolationAllowed ? value.inde***REMOVED***Of('\\#[') : -1;
    var matchOfStringInterp = /(\\)?([#!]){((?:.|\n)*)$/.e***REMOVED***ec(value);
    var inde***REMOVED***OfStringInterp =
      this.interpolationAllowed && matchOfStringInterp
        ? matchOfStringInterp.inde***REMOVED***
        : Infinity;

    if (inde***REMOVED***OfEnd === -1) inde***REMOVED***OfEnd = Infinity;
    if (inde***REMOVED***OfStart === -1) inde***REMOVED***OfStart = Infinity;
    if (inde***REMOVED***OfEscaped === -1) inde***REMOVED***OfEscaped = Infinity;

    if (
      inde***REMOVED***OfEscaped !== Infinity &&
      inde***REMOVED***OfEscaped < inde***REMOVED***OfEnd &&
      inde***REMOVED***OfEscaped < inde***REMOVED***OfStart &&
      inde***REMOVED***OfEscaped < inde***REMOVED***OfStringInterp
    ) {
      prefi***REMOVED*** = prefi***REMOVED*** + value.substring(0, inde***REMOVED***OfEscaped) + '#[';
      return this.addTe***REMOVED***t(
        type,
        value.substring(inde***REMOVED***OfEscaped + 3),
        prefi***REMOVED***,
        escaped + 1
      );
    }
    if (
      inde***REMOVED***OfStart !== Infinity &&
      inde***REMOVED***OfStart < inde***REMOVED***OfEnd &&
      inde***REMOVED***OfStart < inde***REMOVED***OfEscaped &&
      inde***REMOVED***OfStart < inde***REMOVED***OfStringInterp
    ) {
      tok = this.tok(type, prefi***REMOVED*** + value.substring(0, inde***REMOVED***OfStart));
      this.incrementColumn(prefi***REMOVED***.length + inde***REMOVED***OfStart + escaped);
      this.tokens.push(this.tokEnd(tok));
      tok = this.tok('start-pug-interpolation');
      this.incrementColumn(2);
      this.tokens.push(this.tokEnd(tok));
      var child = new this.constructor(value.substr(inde***REMOVED***OfStart + 2), {
        filename: this.filename,
        interpolated: true,
        startingLine: this.lineno,
        startingColumn: this.colno,
        plugins: this.plugins,
      });
      var interpolated;
      try {
        interpolated = child.getTokens();
      } catch (e***REMOVED***) {
        if (e***REMOVED***.code && /^PUG:/.test(e***REMOVED***.code)) {
          this.colno = e***REMOVED***.column;
          this.error(e***REMOVED***.code.substr(4), e***REMOVED***.msg);
        }
        throw e***REMOVED***;
      }
      this.colno = child.colno;
      this.tokens = this.tokens.concat(interpolated);
      tok = this.tok('end-pug-interpolation');
      this.incrementColumn(1);
      this.tokens.push(this.tokEnd(tok));
      this.addTe***REMOVED***t(type, child.input);
      return;
    }
    if (
      inde***REMOVED***OfEnd !== Infinity &&
      inde***REMOVED***OfEnd < inde***REMOVED***OfStart &&
      inde***REMOVED***OfEnd < inde***REMOVED***OfEscaped &&
      inde***REMOVED***OfEnd < inde***REMOVED***OfStringInterp
    ) {
      if (prefi***REMOVED*** + value.substring(0, inde***REMOVED***OfEnd)) {
        this.addTe***REMOVED***t(type, value.substring(0, inde***REMOVED***OfEnd), prefi***REMOVED***);
      }
      this.ended = true;
      this.input = value.substr(value.inde***REMOVED***Of(']') + 1) + this.input;
      return;
    }
    if (inde***REMOVED***OfStringInterp !== Infinity) {
      if (matchOfStringInterp[1]) {
        prefi***REMOVED*** =
          prefi***REMOVED*** +
          value.substring(0, inde***REMOVED***OfStringInterp) +
          matchOfStringInterp[2] +
          '{';
        return this.addTe***REMOVED***t(
          type,
          value.substring(inde***REMOVED***OfStringInterp + 3),
          prefi***REMOVED***,
          escaped + 1
        );
      }
      var before = value.substr(0, inde***REMOVED***OfStringInterp);
      if (prefi***REMOVED*** || before) {
        before = prefi***REMOVED*** + before;
        tok = this.tok(type, before);
        this.incrementColumn(before.length + escaped);
        this.tokens.push(this.tokEnd(tok));
      }

      var rest = matchOfStringInterp[3];
      var range;
      tok = this.tok('interpolated-code');
      this.incrementColumn(2);
      try {
        range = characterParser.parseUntil(rest, '}');
      } catch (e***REMOVED***) {
        if (e***REMOVED***.inde***REMOVED*** !== undefined) {
          this.incrementColumn(e***REMOVED***.inde***REMOVED***);
        }
        if (e***REMOVED***.code === 'CHARACTER_PARSER:END_OF_STRING_REACHED') {
          this.error(
            'NO_END_BRACKET',
            'End of line was reached with no closing bracket for interpolation.'
          );
        } else if (e***REMOVED***.code === 'CHARACTER_PARSER:MISMATCHED_BRACKET') {
          this.error('BRACKET_MISMATCH', e***REMOVED***.message);
        } else {
          throw e***REMOVED***;
        }
      }
      tok.mustEscape = matchOfStringInterp[2] === '#';
      tok.buffer = true;
      tok.val = range.src;
      this.assertE***REMOVED***pression(range.src);

      if (range.end + 1 < rest.length) {
        rest = rest.substr(range.end + 1);
        this.incrementColumn(range.end + 1);
        this.tokens.push(this.tokEnd(tok));
        this.addTe***REMOVED***t(type, rest);
      } else {
        this.incrementColumn(rest.length);
        this.tokens.push(this.tokEnd(tok));
      }
      return;
    }

    value = prefi***REMOVED*** + value;
    tok = this.tok(type, value);
    this.incrementColumn(value.length + escaped);
    this.tokens.push(this.tokEnd(tok));
  },

  te***REMOVED***t: function() {
    var tok =
      this.scan(/^(?:\| ?| )([^\n]+)/, 'te***REMOVED***t') ||
      this.scan(/^( )/, 'te***REMOVED***t') ||
      this.scan(/^\|( ?)/, 'te***REMOVED***t');
    if (tok) {
      this.addTe***REMOVED***t('te***REMOVED***t', tok.val);
      return true;
    }
  },

  te***REMOVED***tHtml: function() {
    var tok = this.scan(/^(<[^\n]*)/, 'te***REMOVED***t-html');
    if (tok) {
      this.addTe***REMOVED***t('te***REMOVED***t-html', tok.val);
      return true;
    }
  },

  /**
   * Dot.
   */

  dot: function() {
    var tok;
    if ((tok = this.scanEndOfLine(/^\./, 'dot'))) {
      this.tokens.push(this.tokEnd(tok));
      this.callLe***REMOVED***erFunction('pipelessTe***REMOVED***t');
      return true;
    }
  },

  /**
   * E***REMOVED***tends.
   */

  e***REMOVED***tends: function() {
    var tok = this.scan(/^e***REMOVED***tends?(?= |$|\n)/, 'e***REMOVED***tends');
    if (tok) {
      this.tokens.push(this.tokEnd(tok));
      if (!this.callLe***REMOVED***erFunction('path')) {
        this.error('NO_EXTENDS_PATH', 'missing path for e***REMOVED***tends');
      }
      return true;
    }
    if (this.scan(/^e***REMOVED***tends?\b/)) {
      this.error('MALFORMED_EXTENDS', 'malformed e***REMOVED***tends');
    }
  },

  /**
   * Block prepend.
   */

  prepend: function() {
    var captures;
    if ((captures = /^(?:block +)?prepend +([^\n]+)/.e***REMOVED***ec(this.input))) {
      var name = captures[1].trim();
      var comment = '';
      if (name.inde***REMOVED***Of('//') !== -1) {
        comment =
          '//' +
          name
            .split('//')
            .slice(1)
            .join('//');
        name = name.split('//')[0].trim();
      }
      if (!name) return;
      var tok = this.tok('block', name);
      var len = captures[0].length - comment.length;
      while (this.whitespaceRe.test(this.input.charAt(len - 1))) len--;
      this.incrementColumn(len);
      tok.mode = 'prepend';
      this.tokens.push(this.tokEnd(tok));
      this.consume(captures[0].length - comment.length);
      this.incrementColumn(captures[0].length - comment.length - len);
      return true;
    }
  },

  /**
   * Block append.
   */

  append: function() {
    var captures;
    if ((captures = /^(?:block +)?append +([^\n]+)/.e***REMOVED***ec(this.input))) {
      var name = captures[1].trim();
      var comment = '';
      if (name.inde***REMOVED***Of('//') !== -1) {
        comment =
          '//' +
          name
            .split('//')
            .slice(1)
            .join('//');
        name = name.split('//')[0].trim();
      }
      if (!name) return;
      var tok = this.tok('block', name);
      var len = captures[0].length - comment.length;
      while (this.whitespaceRe.test(this.input.charAt(len - 1))) len--;
      this.incrementColumn(len);
      tok.mode = 'append';
      this.tokens.push(this.tokEnd(tok));
      this.consume(captures[0].length - comment.length);
      this.incrementColumn(captures[0].length - comment.length - len);
      return true;
    }
  },

  /**
   * Block.
   */

  block: function() {
    var captures;
    if ((captures = /^block +([^\n]+)/.e***REMOVED***ec(this.input))) {
      var name = captures[1].trim();
      var comment = '';
      if (name.inde***REMOVED***Of('//') !== -1) {
        comment =
          '//' +
          name
            .split('//')
            .slice(1)
            .join('//');
        name = name.split('//')[0].trim();
      }
      if (!name) return;
      var tok = this.tok('block', name);
      var len = captures[0].length - comment.length;
      while (this.whitespaceRe.test(this.input.charAt(len - 1))) len--;
      this.incrementColumn(len);
      tok.mode = 'replace';
      this.tokens.push(this.tokEnd(tok));
      this.consume(captures[0].length - comment.length);
      this.incrementColumn(captures[0].length - comment.length - len);
      return true;
    }
  },

  /**
   * Mi***REMOVED***in Block.
   */

  mi***REMOVED***inBlock: function() {
    var tok;
    if ((tok = this.scanEndOfLine(/^block/, 'mi***REMOVED***in-block'))) {
      this.tokens.push(this.tokEnd(tok));
      return true;
    }
  },

  /**
   * Yield.
   */

  yield: function() {
    var tok = this.scanEndOfLine(/^yield/, 'yield');
    if (tok) {
      this.tokens.push(this.tokEnd(tok));
      return true;
    }
  },

  /**
   * Include.
   */

  include: function() {
    var tok = this.scan(/^include(?=:| |$|\n)/, 'include');
    if (tok) {
      this.tokens.push(this.tokEnd(tok));
      while (this.callLe***REMOVED***erFunction('filter', {inInclude: true}));
      if (!this.callLe***REMOVED***erFunction('path')) {
        if (/^[^ \n]+/.test(this.input)) {
          // if there is more te***REMOVED***t
          this.fail();
        } else {
          // if not
          this.error('NO_INCLUDE_PATH', 'missing path for include');
        }
      }
      return true;
    }
    if (this.scan(/^include\b/)) {
      this.error('MALFORMED_INCLUDE', 'malformed include');
    }
  },

  /**
   * Path
   */

  path: function() {
    var tok = this.scanEndOfLine(/^ ([^\n]+)/, 'path');
    if (tok && (tok.val = tok.val.trim())) {
      this.tokens.push(this.tokEnd(tok));
      return true;
    }
  },

  /**
   * Case.
   */

  case: function() {
    var tok = this.scanEndOfLine(/^case +([^\n]+)/, 'case');
    if (tok) {
      this.incrementColumn(-tok.val.length);
      this.assertE***REMOVED***pression(tok.val);
      this.incrementColumn(tok.val.length);
      this.tokens.push(this.tokEnd(tok));
      return true;
    }
    if (this.scan(/^case\b/)) {
      this.error('NO_CASE_EXPRESSION', 'missing e***REMOVED***pression for case');
    }
  },

  /**
   * When.
   */

  when: function() {
    var tok = this.scanEndOfLine(/^when +([^:\n]+)/, 'when');
    if (tok) {
      var parser = characterParser(tok.val);
      while (parser.isNesting() || parser.isString()) {
        var rest = /:([^:\n]+)/.e***REMOVED***ec(this.input);
        if (!rest) break;

        tok.val += rest[0];
        this.consume(rest[0].length);
        this.incrementColumn(rest[0].length);
        parser = characterParser(tok.val);
      }

      this.incrementColumn(-tok.val.length);
      this.assertE***REMOVED***pression(tok.val);
      this.incrementColumn(tok.val.length);
      this.tokens.push(this.tokEnd(tok));
      return true;
    }
    if (this.scan(/^when\b/)) {
      this.error('NO_WHEN_EXPRESSION', 'missing e***REMOVED***pression for when');
    }
  },

  /**
   * Default.
   */

  default: function() {
    var tok = this.scanEndOfLine(/^default/, 'default');
    if (tok) {
      this.tokens.push(this.tokEnd(tok));
      return true;
    }
    if (this.scan(/^default\b/)) {
      this.error(
        'DEFAULT_WITH_EXPRESSION',
        'default should not have an e***REMOVED***pression'
      );
    }
  },

  /**
   * Call mi***REMOVED***in.
   */

  call: function() {
    var tok, captures, increment;
    if ((captures = /^\+(\s*)(([-\w]+)|(#\{))/.e***REMOVED***ec(this.input))) {
      // try to consume simple or interpolated call
      if (captures[3]) {
        // simple call
        increment = captures[0].length;
        this.consume(increment);
        tok = this.tok('call', captures[3]);
      } else {
        // interpolated call
        var match = this.bracketE***REMOVED***pression(2 + captures[1].length);
        increment = match.end + 1;
        this.consume(increment);
        this.assertE***REMOVED***pression(match.src);
        tok = this.tok('call', '#{' + match.src + '}');
      }

      this.incrementColumn(increment);

      tok.args = null;
      // Check for args (not attributes)
      if ((captures = /^ *\(/.e***REMOVED***ec(this.input))) {
        var range = this.bracketE***REMOVED***pression(captures[0].length - 1);
        if (!/^\s*[-\w]+ *=/.test(range.src)) {
          // not attributes
          this.incrementColumn(1);
          this.consume(range.end + 1);
          tok.args = range.src;
          this.assertE***REMOVED***pression('[' + tok.args + ']');
          for (var i = 0; i <= tok.args.length; i++) {
            if (tok.args[i] === '\n') {
              this.incrementLine(1);
            } else {
              this.incrementColumn(1);
            }
          }
        }
      }
      this.tokens.push(this.tokEnd(tok));
      return true;
    }
  },

  /**
   * Mi***REMOVED***in.
   */

  mi***REMOVED***in: function() {
    var captures;
    if ((captures = /^mi***REMOVED***in +([-\w]+)(?: *\((.*)\))? */.e***REMOVED***ec(this.input))) {
      this.consume(captures[0].length);
      var tok = this.tok('mi***REMOVED***in', captures[1]);
      tok.args = captures[2] || null;
      this.incrementColumn(captures[0].length);
      this.tokens.push(this.tokEnd(tok));
      return true;
    }
  },

  /**
   * Conditional.
   */

  conditional: function() {
    var captures;
    if ((captures = /^(if|unless|else if|else)\b([^\n]*)/.e***REMOVED***ec(this.input))) {
      this.consume(captures[0].length);
      var type = captures[1].replace(/ /g, '-');
      var js = captures[2] && captures[2].trim();
      // type can be "if", "else-if" and "else"
      var tok = this.tok(type, js);
      this.incrementColumn(captures[0].length - js.length);

      switch (type) {
        case 'if':
        case 'else-if':
          this.assertE***REMOVED***pression(js);
          break;
        case 'unless':
          this.assertE***REMOVED***pression(js);
          tok.val = '!(' + js + ')';
          tok.type = 'if';
          break;
        case 'else':
          if (js) {
            this.error(
              'ELSE_CONDITION',
              '`else` cannot have a condition, perhaps you meant `else if`'
            );
          }
          break;
      }
      this.incrementColumn(js.length);
      this.tokens.push(this.tokEnd(tok));
      return true;
    }
  },

  /**
   * While.
   */

  while: function() {
    var captures, tok;
    if ((captures = /^while +([^\n]+)/.e***REMOVED***ec(this.input))) {
      this.consume(captures[0].length);
      this.assertE***REMOVED***pression(captures[1]);
      tok = this.tok('while', captures[1]);
      this.incrementColumn(captures[0].length);
      this.tokens.push(this.tokEnd(tok));
      return true;
    }
    if (this.scan(/^while\b/)) {
      this.error('NO_WHILE_EXPRESSION', 'missing e***REMOVED***pression for while');
    }
  },

  /**
   * Each.
   */

  each: function() {
    var captures;
    if (
      (captures = /^(?:each|for) +([a-zA-Z_$][\w$]*)(?: *, *([a-zA-Z_$][\w$]*))? * in *([^\n]+)/.e***REMOVED***ec(
        this.input
      ))
    ) {
      this.consume(captures[0].length);
      var tok = this.tok('each', captures[1]);
      tok.key = captures[2] || null;
      this.incrementColumn(captures[0].length - captures[3].length);
      this.assertE***REMOVED***pression(captures[3]);
      tok.code = captures[3];
      this.incrementColumn(captures[3].length);
      this.tokens.push(this.tokEnd(tok));
      return true;
    }
    const name = /^each\b/.e***REMOVED***ec(this.input) ? 'each' : 'for';
    if (this.scan(/^(?:each|for)\b/)) {
      this.error(
        'MALFORMED_EACH',
        'This `' +
          name +
          '` has a synta***REMOVED*** error. `' +
          name +
          '` statements should be of the form: `' +
          name +
          ' VARIABLE_NAME of JS_EXPRESSION`'
      );
    }
    if (
      (captures = /^- *(?:each|for) +([a-zA-Z_$][\w$]*)(?: *, *([a-zA-Z_$][\w$]*))? +in +([^\n]+)/.e***REMOVED***ec(
        this.input
      ))
    ) {
      this.error(
        'MALFORMED_EACH',
        'Pug each and for should no longer be prefi***REMOVED***ed with a dash ("-"). They are pug keywords and not part of JavaScript.'
      );
    }
  },

  /**
   * EachOf.
   */

  eachOf: function() {
    var captures;
    if ((captures = /^(?:each|for) (.*?) of *([^\n]+)/.e***REMOVED***ec(this.input))) {
      this.consume(captures[0].length);
      var tok = this.tok('eachOf', captures[1]);
      tok.value = captures[1];
      this.incrementColumn(captures[0].length - captures[2].length);
      this.assertE***REMOVED***pression(captures[2]);
      tok.code = captures[2];
      this.incrementColumn(captures[2].length);
      this.tokens.push(this.tokEnd(tok));

      if (
        !(
          /^[a-zA-Z_$][\w$]*$/.test(tok.value.trim()) ||
          /^\[ *[a-zA-Z_$][\w$]* *\, *[a-zA-Z_$][\w$]* *\]$/.test(
            tok.value.trim()
          )
        )
      ) {
        this.error(
          'MALFORMED_EACH_OF_LVAL',
          'The value variable for each must either be a valid identifier (e.g. `item`) or a pair of identifiers in square brackets (e.g. `[key, value]`).'
        );
      }

      return true;
    }
    if (
      (captures = /^- *(?:each|for) +([a-zA-Z_$][\w$]*)(?: *, *([a-zA-Z_$][\w$]*))? +of +([^\n]+)/.e***REMOVED***ec(
        this.input
      ))
    ) {
      this.error(
        'MALFORMED_EACH',
        'Pug each and for should not be prefi***REMOVED***ed with a dash ("-"). They are pug keywords and not part of JavaScript.'
      );
    }
  },

  /**
   * Code.
   */

  code: function() {
    var captures;
    if ((captures = /^(!?=|-)[ \t]*([^\n]+)/.e***REMOVED***ec(this.input))) {
      var flags = captures[1];
      var code = captures[2];
      var shortened = 0;
      if (this.interpolated) {
        var parsed;
        try {
          parsed = characterParser.parseUntil(code, ']');
        } catch (err) {
          if (err.inde***REMOVED*** !== undefined) {
            this.incrementColumn(captures[0].length - code.length + err.inde***REMOVED***);
          }
          if (err.code === 'CHARACTER_PARSER:END_OF_STRING_REACHED') {
            this.error(
              'NO_END_BRACKET',
              'End of line was reached with no closing bracket for interpolation.'
            );
          } else if (err.code === 'CHARACTER_PARSER:MISMATCHED_BRACKET') {
            this.error('BRACKET_MISMATCH', err.message);
          } else {
            throw err;
          }
        }
        shortened = code.length - parsed.end;
        code = parsed.src;
      }
      var consumed = captures[0].length - shortened;
      this.consume(consumed);
      var tok = this.tok('code', code);
      tok.mustEscape = flags.charAt(0) === '=';
      tok.buffer = flags.charAt(0) === '=' || flags.charAt(1) === '=';

      // p #[!=    abc] hey
      //     ^              original colno
      //     -------------- captures[0]
      //           -------- captures[2]
      //     ------         captures[0] - captures[2]
      //           ^        after colno

      // =   abc
      // ^                  original colno
      // -------            captures[0]
      //     ---            captures[2]
      // ----               captures[0] - captures[2]
      //     ^              after colno
      this.incrementColumn(captures[0].length - captures[2].length);
      if (tok.buffer) this.assertE***REMOVED***pression(code);
      this.tokens.push(tok);

      // p #[!=    abc] hey
      //           ^        original colno
      //              ----- shortened
      //           ---      code
      //              ^     after colno

      // =   abc
      //     ^              original colno
      //                    shortened
      //     ---            code
      //        ^           after colno
      this.incrementColumn(code.length);
      this.tokEnd(tok);
      return true;
    }
  },

  /**
   * Block code.
   */
  blockCode: function() {
    var tok;
    if ((tok = this.scanEndOfLine(/^-/, 'blockcode'))) {
      this.tokens.push(this.tokEnd(tok));
      this.interpolationAllowed = false;
      this.callLe***REMOVED***erFunction('pipelessTe***REMOVED***t');
      return true;
    }
  },

  /**
   * Attribute Name.
   */
  attribute: function(str) {
    var quote = '';
    var quoteRe = /['"]/;
    var key = '';
    var i;

    // consume all whitespace before the key
    for (i = 0; i < str.length; i++) {
      if (!this.whitespaceRe.test(str[i])) break;
      if (str[i] === '\n') {
        this.incrementLine(1);
      } else {
        this.incrementColumn(1);
      }
    }

    if (i === str.length) {
      return '';
    }

    var tok = this.tok('attribute');

    // quote?
    if (quoteRe.test(str[i])) {
      quote = str[i];
      this.incrementColumn(1);
      i++;
    }

    // start looping through the key
    for (; i < str.length; i++) {
      if (quote) {
        if (str[i] === quote) {
          this.incrementColumn(1);
          i++;
          break;
        }
      } else {
        if (
          this.whitespaceRe.test(str[i]) ||
          str[i] === '!' ||
          str[i] === '=' ||
          str[i] === ','
        ) {
          break;
        }
      }

      key += str[i];

      if (str[i] === '\n') {
        this.incrementLine(1);
      } else {
        this.incrementColumn(1);
      }
    }

    tok.name = key;

    var valueResponse = this.attributeValue(str.substr(i));

    if (valueResponse.val) {
      tok.val = valueResponse.val;
      tok.mustEscape = valueResponse.mustEscape;
    } else {
      // was a boolean attribute (e***REMOVED***: `input(disabled)`)
      tok.val = true;
      tok.mustEscape = true;
    }

    str = valueResponse.remainingSource;

    this.tokens.push(this.tokEnd(tok));

    for (i = 0; i < str.length; i++) {
      if (!this.whitespaceRe.test(str[i])) {
        break;
      }
      if (str[i] === '\n') {
        this.incrementLine(1);
      } else {
        this.incrementColumn(1);
      }
    }

    if (str[i] === ',') {
      this.incrementColumn(1);
      i++;
    }

    return str.substr(i);
  },

  /**
   * Attribute Value.
   */
  attributeValue: function(str) {
    var quoteRe = /['"]/;
    var val = '';
    var done, i, ***REMOVED***;
    var escapeAttr = true;
    var state = characterParser.defaultState();
    var col = this.colno;
    var line = this.lineno;

    // consume all whitespace before the equals sign
    for (i = 0; i < str.length; i++) {
      if (!this.whitespaceRe.test(str[i])) break;
      if (str[i] === '\n') {
        line++;
        col = 1;
      } else {
        col++;
      }
    }

    if (i === str.length) {
      return {remainingSource: str};
    }

    if (str[i] === '!') {
      escapeAttr = false;
      col++;
      i++;
      if (str[i] !== '=')
        this.error(
          'INVALID_KEY_CHARACTER',
          'Une***REMOVED***pected character ' + str[i] + ' e***REMOVED***pected `=`'
        );
    }

    if (str[i] !== '=') {
      // check for anti-pattern `div("foo"bar)`
      if (i === 0 && str && !this.whitespaceRe.test(str[0]) && str[0] !== ',') {
        this.error(
          'INVALID_KEY_CHARACTER',
          'Une***REMOVED***pected character ' + str[0] + ' e***REMOVED***pected `=`'
        );
      } else {
        return {remainingSource: str};
      }
    }

    this.lineno = line;
    this.colno = col + 1;
    i++;

    // consume all whitespace before the value
    for (; i < str.length; i++) {
      if (!this.whitespaceRe.test(str[i])) break;
      if (str[i] === '\n') {
        this.incrementLine(1);
      } else {
        this.incrementColumn(1);
      }
    }

    line = this.lineno;
    col = this.colno;

    // start looping through the value
    for (; i < str.length; i++) {
      // if the character is in a string or in parentheses/brackets/braces
      if (!(state.isNesting() || state.isString())) {
        if (this.whitespaceRe.test(str[i])) {
          done = false;

          // find the first non-whitespace character
          for (***REMOVED*** = i; ***REMOVED*** < str.length; ***REMOVED***++) {
            if (!this.whitespaceRe.test(str[***REMOVED***])) {
              // if it is a JavaScript punctuator, then assume that it is
              // a part of the value
              const isNotPunctuator = !characterParser.isPunctuator(str[***REMOVED***]);
              const isQuote = quoteRe.test(str[***REMOVED***]);
              const isColon = str[***REMOVED***] === ':';
              const isSpreadOperator =
                str[***REMOVED***] + str[***REMOVED*** + 1] + str[***REMOVED*** + 2] === '...';
              if (
                (isNotPunctuator || isQuote || isColon || isSpreadOperator) &&
                this.assertE***REMOVED***pression(val, true)
              ) {
                done = true;
              }
              break;
            }
          }

          // if everything else is whitespace, return now so last attribute
          // does not include trailing whitespace
          if (done || ***REMOVED*** === str.length) {
            break;
          }
        }

        // if there's no whitespace and the character is not ',', the
        // attribute did not end.
        if (str[i] === ',' && this.assertE***REMOVED***pression(val, true)) {
          break;
        }
      }

      state = characterParser.parseChar(str[i], state);
      val += str[i];

      if (str[i] === '\n') {
        line++;
        col = 1;
      } else {
        col++;
      }
    }

    this.assertE***REMOVED***pression(val);

    this.lineno = line;
    this.colno = col;

    return {val: val, mustEscape: escapeAttr, remainingSource: str.substr(i)};
  },

  /**
   * Attributes.
   */

  attrs: function() {
    var tok;

    if ('(' == this.input.charAt(0)) {
      tok = this.tok('start-attributes');
      var inde***REMOVED*** = this.bracketE***REMOVED***pression().end;
      var str = this.input.substr(1, inde***REMOVED*** - 1);

      this.incrementColumn(1);
      this.tokens.push(this.tokEnd(tok));
      this.assertNestingCorrect(str);
      this.consume(inde***REMOVED*** + 1);

      while (str) {
        str = this.attribute(str);
      }

      tok = this.tok('end-attributes');
      this.incrementColumn(1);
      this.tokens.push(this.tokEnd(tok));
      return true;
    }
  },

  /**
   * &attributes block
   */
  attributesBlock: function() {
    if (/^&attributes\b/.test(this.input)) {
      var consumed = 11;
      this.consume(consumed);
      var tok = this.tok('&attributes');
      this.incrementColumn(consumed);
      var args = this.bracketE***REMOVED***pression();
      consumed = args.end + 1;
      this.consume(consumed);
      tok.val = args.src;
      this.incrementColumn(consumed);
      this.tokens.push(this.tokEnd(tok));
      return true;
    }
  },

  /**
   * Indent | Outdent | Newline.
   */

  indent: function() {
    var captures = this.scanIndentation();
    var tok;

    if (captures) {
      var indents = captures[1].length;

      this.incrementLine(1);
      this.consume(indents + 1);

      if (' ' == this.input[0] || '\t' == this.input[0]) {
        this.error(
          'INVALID_INDENTATION',
          'Invalid indentation, you can use tabs or spaces but not both'
        );
      }

      // blank line
      if ('\n' == this.input[0]) {
        this.interpolationAllowed = true;
        return this.tokEnd(this.tok('newline'));
      }

      // outdent
      if (indents < this.indentStack[0]) {
        var outdent_count = 0;
        while (this.indentStack[0] > indents) {
          if (this.indentStack[1] < indents) {
            this.error(
              'INCONSISTENT_INDENTATION',
              'Inconsistent indentation. E***REMOVED***pecting either ' +
                this.indentStack[1] +
                ' or ' +
                this.indentStack[0] +
                ' spaces/tabs.'
            );
          }
          outdent_count++;
          this.indentStack.shift();
        }
        while (outdent_count--) {
          this.colno = 1;
          tok = this.tok('outdent');
          this.colno = this.indentStack[0] + 1;
          this.tokens.push(this.tokEnd(tok));
        }
        // indent
      } else if (indents && indents != this.indentStack[0]) {
        tok = this.tok('indent', indents);
        this.colno = 1 + indents;
        this.tokens.push(this.tokEnd(tok));
        this.indentStack.unshift(indents);
        // newline
      } else {
        tok = this.tok('newline');
        this.colno = 1 + Math.min(this.indentStack[0] || 0, indents);
        this.tokens.push(this.tokEnd(tok));
      }

      this.interpolationAllowed = true;
      return true;
    }
  },

  pipelessTe***REMOVED***t: function pipelessTe***REMOVED***t(indents) {
    while (this.callLe***REMOVED***erFunction('blank'));

    var captures = this.scanIndentation();

    indents = indents || (captures && captures[1].length);
    if (indents > this.indentStack[0]) {
      this.tokens.push(this.tokEnd(this.tok('start-pipeless-te***REMOVED***t')));
      var tokens = [];
      var token_indent = [];
      var isMatch;
      // Inde***REMOVED*** in this.input. Can't use this.consume because we might need to
      // retry le***REMOVED***ing the block.
      var stringPtr = 0;
      do {
        // te***REMOVED***t has `\n` as a prefi***REMOVED***
        var i = this.input.substr(stringPtr + 1).inde***REMOVED***Of('\n');
        if (-1 == i) i = this.input.length - stringPtr - 1;
        var str = this.input.substr(stringPtr + 1, i);
        var lineCaptures = this.indentRe.e***REMOVED***ec('\n' + str);
        var lineIndents = lineCaptures && lineCaptures[1].length;
        isMatch = lineIndents >= indents;
        token_indent.push(isMatch);
        isMatch = isMatch || !str.trim();
        if (isMatch) {
          // consume test along with `\n` prefi***REMOVED*** if match
          stringPtr += str.length + 1;
          tokens.push(str.substr(indents));
        } else if (lineIndents > this.indentStack[0]) {
          // line is indented less than the first line but is still indented
          // need to retry le***REMOVED***ing the te***REMOVED***t block
          this.tokens.pop();
          return pipelessTe***REMOVED***t.call(this, lineCaptures[1].length);
        }
      } while (this.input.length - stringPtr && isMatch);
      this.consume(stringPtr);
      while (this.input.length === 0 && tokens[tokens.length - 1] === '')
        tokens.pop();
      tokens.forEach(
        function(token, i) {
          var tok;
          this.incrementLine(1);
          if (i !== 0) tok = this.tok('newline');
          if (token_indent[i]) this.incrementColumn(indents);
          if (tok) this.tokens.push(this.tokEnd(tok));
          this.addTe***REMOVED***t('te***REMOVED***t', token);
        }.bind(this)
      );
      this.tokens.push(this.tokEnd(this.tok('end-pipeless-te***REMOVED***t')));
      return true;
    }
  },

  /**
   * Slash.
   */

  slash: function() {
    var tok = this.scan(/^\//, 'slash');
    if (tok) {
      this.tokens.push(this.tokEnd(tok));
      return true;
    }
  },

  /**
   * ':'
   */

  colon: function() {
    var tok = this.scan(/^: +/, ':');
    if (tok) {
      this.tokens.push(this.tokEnd(tok));
      return true;
    }
  },

  fail: function() {
    this.error(
      'UNEXPECTED_TEXT',
      'une***REMOVED***pected te***REMOVED***t "' + this.input.substr(0, 5) + '"'
    );
  },

  callLe***REMOVED***erFunction: function(func) {
    var rest = [];
    for (var i = 1; i < arguments.length; i++) {
      rest.push(arguments[i]);
    }
    var pluginArgs = [this].concat(rest);
    for (var i = 0; i < this.plugins.length; i++) {
      var plugin = this.plugins[i];
      if (plugin[func] && plugin[func].apply(plugin, pluginArgs)) {
        return true;
      }
    }
    return this[func].apply(this, rest);
  },

  /**
   * Move to the ne***REMOVED***t token
   *
   * @api private
   */

  advance: function() {
    return (
      this.callLe***REMOVED***erFunction('blank') ||
      this.callLe***REMOVED***erFunction('eos') ||
      this.callLe***REMOVED***erFunction('endInterpolation') ||
      this.callLe***REMOVED***erFunction('yield') ||
      this.callLe***REMOVED***erFunction('doctype') ||
      this.callLe***REMOVED***erFunction('interpolation') ||
      this.callLe***REMOVED***erFunction('case') ||
      this.callLe***REMOVED***erFunction('when') ||
      this.callLe***REMOVED***erFunction('default') ||
      this.callLe***REMOVED***erFunction('e***REMOVED***tends') ||
      this.callLe***REMOVED***erFunction('append') ||
      this.callLe***REMOVED***erFunction('prepend') ||
      this.callLe***REMOVED***erFunction('block') ||
      this.callLe***REMOVED***erFunction('mi***REMOVED***inBlock') ||
      this.callLe***REMOVED***erFunction('include') ||
      this.callLe***REMOVED***erFunction('mi***REMOVED***in') ||
      this.callLe***REMOVED***erFunction('call') ||
      this.callLe***REMOVED***erFunction('conditional') ||
      this.callLe***REMOVED***erFunction('eachOf') ||
      this.callLe***REMOVED***erFunction('each') ||
      this.callLe***REMOVED***erFunction('while') ||
      this.callLe***REMOVED***erFunction('tag') ||
      this.callLe***REMOVED***erFunction('filter') ||
      this.callLe***REMOVED***erFunction('blockCode') ||
      this.callLe***REMOVED***erFunction('code') ||
      this.callLe***REMOVED***erFunction('id') ||
      this.callLe***REMOVED***erFunction('dot') ||
      this.callLe***REMOVED***erFunction('className') ||
      this.callLe***REMOVED***erFunction('attrs') ||
      this.callLe***REMOVED***erFunction('attributesBlock') ||
      this.callLe***REMOVED***erFunction('indent') ||
      this.callLe***REMOVED***erFunction('te***REMOVED***t') ||
      this.callLe***REMOVED***erFunction('te***REMOVED***tHtml') ||
      this.callLe***REMOVED***erFunction('comment') ||
      this.callLe***REMOVED***erFunction('slash') ||
      this.callLe***REMOVED***erFunction('colon') ||
      this.fail()
    );
  },

  /**
   * Return an array of tokens for the current file
   *
   * @returns {Array.<Token>}
   * @api public
   */
  getTokens: function() {
    while (!this.ended) {
      this.callLe***REMOVED***erFunction('advance');
    }
    return this.tokens;
  },
};
