declare module 'pug-le***REMOVED***er' {
  namespace le***REMOVED*** {
    e***REMOVED***port interface Loc {
      start: {line: number; column: number};
      end: {line: number; column: number};
    }

    e***REMOVED***port type Le***REMOVED***TokenType =
      | ':'
      | '&attributes'
      | 'attribute'
      | 'block'
      | 'blockcode'
      | 'call'
      | 'case'
      | 'class'
      | 'code'
      | 'comment'
      | 'default'
      | 'doctype'
      | 'dot'
      | 'each'
      | 'eachOf'
      | 'else-if'
      | 'else'
      | 'end-attributes'
      | 'end-pipeless-te***REMOVED***t'
      | 'end-pug-interpolation'
      | 'eos'
      | 'e***REMOVED***tends'
      | 'filter'
      | 'id'
      | 'if'
      | 'include'
      | 'indent'
      | 'interpolated-code'
      | 'interpolation'
      | 'mi***REMOVED***in-block'
      | 'mi***REMOVED***in'
      | 'newline'
      | 'outdent'
      | 'path'
      | 'slash'
      | 'start-attributes'
      | 'start-pipeless-te***REMOVED***t'
      | 'start-pug-interpolation'
      | 'tag'
      | 'te***REMOVED***t-html'
      | 'te***REMOVED***t'
      | 'when'
      | 'while'
      | 'yield';

    e***REMOVED***port interface Le***REMOVED***Token<Type e***REMOVED***tends Le***REMOVED***TokenType> {
      type: Type;
      loc: Loc;
    }

    e***REMOVED***port interface TagToken e***REMOVED***tends Le***REMOVED***Token<'tag'> {
      val: string;
    }

    e***REMOVED***port type StartAttributesToken = Le***REMOVED***Token<'start-attributes'>;

    e***REMOVED***port interface AttributeToken e***REMOVED***tends Le***REMOVED***Token<'attribute'> {
      name: string;
      val: string | boolean;
      mustEscape: boolean;
    }

    e***REMOVED***port type EndAttributesToken = Le***REMOVED***Token<'end-attributes'>;

    e***REMOVED***port interface IndentToken e***REMOVED***tends Le***REMOVED***Token<'indent'> {
      val: number;
    }

    e***REMOVED***port interface ClassToken e***REMOVED***tends Le***REMOVED***Token<'class'> {
      val: string;
    }

    e***REMOVED***port type OutdentToken = Le***REMOVED***Token<'outdent'>;

    e***REMOVED***port type EosToken = Le***REMOVED***Token<'eos'>;

    e***REMOVED***port interface CommentToken e***REMOVED***tends Le***REMOVED***Token<'comment'> {
      val: string;
      buffer: boolean;
    }

    e***REMOVED***port type NewlineToken = Le***REMOVED***Token<'newline'>;

    e***REMOVED***port interface Te***REMOVED***tToken e***REMOVED***tends Le***REMOVED***Token<'te***REMOVED***t'> {
      val: string;
    }

    e***REMOVED***port interface InterpolatedCodeToken
      e***REMOVED***tends Le***REMOVED***Token<'interpolated-code'> {
      mustEscape: boolean;
      buffer: boolean;
      val: string;
    }

    e***REMOVED***port interface CodeToken e***REMOVED***tends Le***REMOVED***Token<'code'> {
      val: string;
      mustEscape: boolean;
      buffer: boolean;
    }

    e***REMOVED***port interface IdToken e***REMOVED***tends Le***REMOVED***Token<'id'> {
      val: string;
    }

    e***REMOVED***port type StartPipelessTe***REMOVED***tToken = Le***REMOVED***Token<'start-pipeless-te***REMOVED***t'>;

    e***REMOVED***port type EndPipelessTe***REMOVED***tToken = Le***REMOVED***Token<'end-pipeless-te***REMOVED***t'>;

    e***REMOVED***port interface DoctypeToken e***REMOVED***tends Le***REMOVED***Token<'doctype'> {
      val: string;
    }

    e***REMOVED***port type DotToken = Le***REMOVED***Token<'dot'>;

    e***REMOVED***port interface BlockToken e***REMOVED***tends Le***REMOVED***Token<'block'> {
      val: string;
      mode: 'replace' | 'prepend' | 'append';
    }

    e***REMOVED***port type E***REMOVED***tendsToken = Le***REMOVED***Token<'e***REMOVED***tends'>;

    e***REMOVED***port interface PathToken e***REMOVED***tends Le***REMOVED***Token<'path'> {
      val: string;
    }

    e***REMOVED***port type StartPugInterpolationToken = Le***REMOVED***Token<
      'start-pug-interpolation'
    >;

    e***REMOVED***port type EndPugInterpolationToken = Le***REMOVED***Token<'end-pug-interpolation'>;

    e***REMOVED***port interface InterpolationToken e***REMOVED***tends Le***REMOVED***Token<'interpolation'> {
      val: string;
    }

    e***REMOVED***port type IncludeToken = Le***REMOVED***Token<'include'>;

    e***REMOVED***port interface FilterToken e***REMOVED***tends Le***REMOVED***Token<'filter'> {
      val: string;
    }

    e***REMOVED***port interface CallToken e***REMOVED***tends Le***REMOVED***Token<'call'> {
      val: string;
      args: string;
    }

    e***REMOVED***port interface Mi***REMOVED***inToken e***REMOVED***tends Le***REMOVED***Token<'mi***REMOVED***in'> {
      val: string;
      args: string | null;
    }

    e***REMOVED***port interface IfToken e***REMOVED***tends Le***REMOVED***Token<'if'> {
      val: string;
    }

    e***REMOVED***port type Mi***REMOVED***inBlockToken = Le***REMOVED***Token<'mi***REMOVED***in-block'>;

    e***REMOVED***port interface ElseToken e***REMOVED***tends Le***REMOVED***Token<'else'> {
      val: string;
    }

    e***REMOVED***port interface AndAttributesToken e***REMOVED***tends Le***REMOVED***Token<'&attributes'> {
      val: string;
    }

    e***REMOVED***port interface Te***REMOVED***tHtmlToken e***REMOVED***tends Le***REMOVED***Token<'te***REMOVED***t-html'> {
      val: string;
    }

    e***REMOVED***port interface EachToken e***REMOVED***tends Le***REMOVED***Token<'each'> {
      val: string;
      key: string | null;
      code: string;
    }

    e***REMOVED***port interface EachOfToken e***REMOVED***tends Le***REMOVED***Token<'eachOf'> {
      val: string;
      value: string;
      code: string;
    }

    e***REMOVED***port interface WhileToken e***REMOVED***tends Le***REMOVED***Token<'while'> {
      val: string;
    }

    e***REMOVED***port interface CaseToken e***REMOVED***tends Le***REMOVED***Token<'case'> {
      val: string;
    }

    e***REMOVED***port interface WhenToken e***REMOVED***tends Le***REMOVED***Token<'when'> {
      val: string;
    }

    e***REMOVED***port type ColonToken = Le***REMOVED***Token<':'>;

    e***REMOVED***port type DefaultToken = Le***REMOVED***Token<'default'>;

    e***REMOVED***port interface ElseIfToken e***REMOVED***tends Le***REMOVED***Token<'else-if'> {
      val: string;
    }

    e***REMOVED***port type BlockcodeToken = Le***REMOVED***Token<'blockcode'>;

    e***REMOVED***port type YieldToken = Le***REMOVED***Token<'yield'>;

    e***REMOVED***port type SlashToken = Le***REMOVED***Token<'slash'>;

    e***REMOVED***port type Token =
      | AndAttributesToken
      | AttributeToken
      | BlockcodeToken
      | BlockToken
      | CallToken
      | CaseToken
      | ClassToken
      | CodeToken
      | ColonToken
      | CommentToken
      | DefaultToken
      | DoctypeToken
      | DotToken
      | EachToken
      | EachOfToken
      | ElseIfToken
      | ElseToken
      | EndAttributesToken
      | EndPipelessTe***REMOVED***tToken
      | EndPugInterpolationToken
      | EosToken
      | E***REMOVED***tendsToken
      | FilterToken
      | IdToken
      | IfToken
      | IncludeToken
      | IndentToken
      | InterpolatedCodeToken
      | InterpolationToken
      | Mi***REMOVED***inBlockToken
      | Mi***REMOVED***inToken
      | NewlineToken
      | OutdentToken
      | PathToken
      | SlashToken
      | StartAttributesToken
      | StartPipelessTe***REMOVED***tToken
      | StartPugInterpolationToken
      | TagToken
      | Te***REMOVED***tHtmlToken
      | Te***REMOVED***tToken
      | WhenToken
      | WhileToken
      | YieldToken;

    e***REMOVED***port type Le***REMOVED***erFunction = (type: string, e***REMOVED***p?: any) => boolean;
    e***REMOVED***port interface Le***REMOVED***erOptions {
      filename: string;
      interpolated?: boolean;
      startingLine?: number;
      startingColumn?: number;
      plugins?: Le***REMOVED***erFunction[];
    }
    e***REMOVED***port class Le***REMOVED***er {
      input: string;
      originalInput: string;
      filename?: string;
      interpolated: boolean;
      lineno: number;
      colno: number;
      plugins: Le***REMOVED***erFunction[];
      indentStack: number[];
      indentRe: RegE***REMOVED***p | null;
      interpolationAllowed: boolean;
      whitespaceRe: RegE***REMOVED***p;
      tokens: Token[];
      ended: boolean;
      constructor(str: string, options?: Le***REMOVED***erOptions);
      error(code: string, message: string): never;
      assert(value: any, message: string): void;
      isE***REMOVED***pression(e***REMOVED***p: string): boolean;
      assertE***REMOVED***pression(e***REMOVED***p: string, noThrow?: boolean): boolean;
      assertNestingCorrect(e***REMOVED***p: string): void;
      private tok<Type e***REMOVED***tends Le***REMOVED***TokenType>(
        type: Type,
        val?: any,
      ): Le***REMOVED***Token<Type>;
      private tokEnd<Type e***REMOVED***tends Le***REMOVED***TokenType>(
        tok: Le***REMOVED***Token<Type>,
      ): Le***REMOVED***Token<Type>;
      private incrementLine(increment: number): void;
      private incrementColumn(increment: number): void;
      private consume(len: number): void;
      private scan<Type e***REMOVED***tends Le***REMOVED***TokenType>(
        rege***REMOVED***p: RegE***REMOVED***p,
        type: Type,
      ): Le***REMOVED***Token<Type> | undefined;
      private scanEndOfLine<Type e***REMOVED***tends Le***REMOVED***TokenType>(
        rege***REMOVED***p: RegE***REMOVED***p,
        type: Type,
      ): Le***REMOVED***Token<Type> | undefined;
      private bracketE***REMOVED***pression(skip?: number): number;
      scanIndentation(): RegE***REMOVED***pE***REMOVED***ecArray | null;
      eos(): true | undefined;
      blank(): true | undefined;
      comment(): true | undefined;
      interpolation(): true | undefined;
      tag(): true | undefined;
      filter(): true | undefined;
      doctype(): true | undefined;
      id(): true | undefined;
      className(): true | undefined;
      endInterpolation(): true | undefined;
      addTe***REMOVED***t(
        type: Le***REMOVED***TokenType,
        value: string,
        prefi***REMOVED***?: string,
        escaped?: number,
      ): void;
      te***REMOVED***t(): true | undefined;
      te***REMOVED***tHtml(): true | undefined;
      dot(): true | undefined;
      e***REMOVED***tends(): true | undefined;
      prepend(): true | undefined;
      append(): true | undefined;
      block(): true | undefined;
      mi***REMOVED***inBlock(): true | undefined;
      yield(): true | undefined;
      include(): true | undefined;
      path(): true | undefined;
      case(): true | undefined;
      when(): true | undefined;
      default(): true | undefined;
      call(): true | undefined;
      mi***REMOVED***in(): true | undefined;
      conditional(): true | undefined;
      while(): true | undefined;
      each(): true | undefined;
      eachOf(): true | undefined;
      code(): true | undefined;
      blockCode(): true | undefined;
      attribute(): string;
      attributeValue(
        str: string,
      ): {val?: string; mustEscape?: boolean; remainingSource: string};
      attrs(): true | undefined;
      attributesBlock(): true | undefined;
      indent(): true | NewlineToken | undefined;
      pipelessTe***REMOVED***t(indents?: number): boolean | undefined;
      slash(): true | undefined;
      colon(): true | undefined;
      fail(): never;
      callLe***REMOVED***erFunction(func: string): boolean;
      private advance(): boolean;
      getTokens(): Token[];
    }
  }
  function le***REMOVED***(str: string, options?: le***REMOVED***.Le***REMOVED***erOptions): le***REMOVED***.Token[];
  e***REMOVED***port = le***REMOVED***;
}
