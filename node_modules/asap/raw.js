"use strict";

var domain; // The domain module is e***REMOVED***ecuted on demand
var hasSetImmediate = typeof setImmediate === "function";

// Use the fastest means possible to e***REMOVED***ecute a task in its own turn, with
// priority over other events including network IO events in Node.js.
//
// An e***REMOVED***ception thrown by a task will permanently interrupt the processing of
// subsequent tasks. The higher level `asap` function ensures that if an
// e***REMOVED***ception is thrown by a task, that the task queue will continue flushing as
// soon as possible, but if you use `rawAsap` directly, you are responsible to
// either ensure that no e***REMOVED***ceptions are thrown from your task, or to manually
// call `rawAsap.requestFlush` if an e***REMOVED***ception is thrown.
module.e***REMOVED***ports = rawAsap;
function rawAsap(task) {
    if (!queue.length) {
        requestFlush();
        flushing = true;
    }
    // Avoids a function call
    queue[queue.length] = task;
}

var queue = [];
// Once a flush has been requested, no further calls to `requestFlush` are
// necessary until the ne***REMOVED***t `flush` completes.
var flushing = false;
// The position of the ne***REMOVED***t task to e***REMOVED***ecute in the task queue. This is
// preserved between calls to `flush` so that it can be resumed if
// a task throws an e***REMOVED***ception.
var inde***REMOVED*** = 0;
// If a task schedules additional tasks recursively, the task queue can grow
// unbounded. To prevent memory e***REMOVED***caustion, the task queue will periodically
// truncate already-completed tasks.
var capacity = 1024;

// The flush function processes all tasks that have been scheduled with
// `rawAsap` unless and until one of those tasks throws an e***REMOVED***ception.
// If a task throws an e***REMOVED***ception, `flush` ensures that its state will remain
// consistent and will resume where it left off when called again.
// However, `flush` does not make any arrangements to be called again if an
// e***REMOVED***ception is thrown.
function flush() {
    while (inde***REMOVED*** < queue.length) {
        var currentInde***REMOVED*** = inde***REMOVED***;
        // Advance the inde***REMOVED*** before calling the task. This ensures that we will
        // begin flushing on the ne***REMOVED***t task the task throws an error.
        inde***REMOVED*** = inde***REMOVED*** + 1;
        queue[currentInde***REMOVED***].call();
        // Prevent leaking memory for long chains of recursive calls to `asap`.
        // If we call `asap` within tasks scheduled by `asap`, the queue will
        // grow, but to avoid an O(n) walk for every task we e***REMOVED***ecute, we don't
        // shift tasks off the queue after they have been e***REMOVED***ecuted.
        // Instead, we periodically shift 1024 tasks off the queue.
        if (inde***REMOVED*** > capacity) {
            // Manually shift all values starting at the inde***REMOVED*** back to the
            // beginning of the queue.
            for (var scan = 0, newLength = queue.length - inde***REMOVED***; scan < newLength; scan++) {
                queue[scan] = queue[scan + inde***REMOVED***];
            }
            queue.length -= inde***REMOVED***;
            inde***REMOVED*** = 0;
        }
    }
    queue.length = 0;
    inde***REMOVED*** = 0;
    flushing = false;
}

rawAsap.requestFlush = requestFlush;
function requestFlush() {
    // Ensure flushing is not bound to any domain.
    // It is not sufficient to e***REMOVED***it the domain, because domains e***REMOVED***ist on a stack.
    // To e***REMOVED***ecute code outside of any domain, the following dance is necessary.
    var parentDomain = process.domain;
    if (parentDomain) {
        if (!domain) {
            // Lazy e***REMOVED***ecute the domain module.
            // Only employed if the user elects to use domains.
            domain = require("domain");
        }
        domain.active = process.domain = null;
    }

    // `setImmediate` is slower that `process.ne***REMOVED***tTick`, but `process.ne***REMOVED***tTick`
    // cannot handle recursion.
    // `requestFlush` will only be called recursively from `asap.js`, to resume
    // flushing after an error is thrown into a domain.
    // Conveniently, `setImmediate` was introduced in the same version
    // `process.ne***REMOVED***tTick` started throwing recursion errors.
    if (flushing && hasSetImmediate) {
        setImmediate(flush);
    } else {
        process.ne***REMOVED***tTick(flush);
    }

    if (parentDomain) {
        domain.active = process.domain = parentDomain;
    }
}
