
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * E***REMOVED***pose `debug()` as the module.
 */

e***REMOVED***ports = module.e***REMOVED***ports = createDebug.debug = createDebug['default'] = createDebug;
e***REMOVED***ports.coerce = coerce;
e***REMOVED***ports.disable = disable;
e***REMOVED***ports.enable = enable;
e***REMOVED***ports.enabled = enabled;
e***REMOVED***ports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

e***REMOVED***ports.names = [];
e***REMOVED***ports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

e***REMOVED***ports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return e***REMOVED***ports.colors[Math.abs(hash) % e***REMOVED***ports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = e***REMOVED***ports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var inde***REMOVED*** = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array inde***REMOVED***
      if (match === '%%') return match;
      inde***REMOVED***++;
      var formatter = e***REMOVED***ports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[inde***REMOVED***];
        match = formatter.call(self, val);

        // now we need to remove `args[inde***REMOVED***]` since it's inlined in the `format`
        args.splice(inde***REMOVED***, 1);
        inde***REMOVED***--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    e***REMOVED***ports.formatArgs.call(self, args);

    var logFn = debug.log || e***REMOVED***ports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = e***REMOVED***ports.enabled(namespace);
  debug.useColors = e***REMOVED***ports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof e***REMOVED***ports.init) {
    e***REMOVED***ports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  e***REMOVED***ports.save(namespaces);

  e***REMOVED***ports.names = [];
  e***REMOVED***ports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      e***REMOVED***ports.skips.push(new RegE***REMOVED***p('^' + namespaces.substr(1) + '$'));
    } else {
      e***REMOVED***ports.names.push(new RegE***REMOVED***p('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  e***REMOVED***ports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = e***REMOVED***ports.skips.length; i < len; i++) {
    if (e***REMOVED***ports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = e***REMOVED***ports.names.length; i < len; i++) {
    if (e***REMOVED***ports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mi***REMOVED***ed} val
 * @return {Mi***REMOVED***ed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}
