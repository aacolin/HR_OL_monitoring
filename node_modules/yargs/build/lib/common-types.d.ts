/**
 * An object whose all properties have the same type.
 */
e***REMOVED***port declare type Dictionary<T = any> = {
    [key: string]: T;
};
/**
 * Returns the keys of T that match Dictionary<U> and are not arrays.
 */
e***REMOVED***port declare type DictionaryKeyof<T, U = any> = E***REMOVED***clude<KeyOf<T, Dictionary<U>>, KeyOf<T, any[]>>;
/**
 * Returns the keys of T that match U.
 */
e***REMOVED***port declare type KeyOf<T, U> = E***REMOVED***clude<{
    [K in keyof T]: T[K] e***REMOVED***tends U ? K : never;
}[keyof T], undefined>;
/**
 * An array whose first element is not undefined.
 */
e***REMOVED***port declare type NotEmptyArray<T = any> = [T, ...T[]];
/**
 * Returns the type of a Dictionary or array values.
 */
e***REMOVED***port declare type ValueOf<T> = T e***REMOVED***tends (infer U)[] ? U : T[keyof T];
/**
 * Typing wrapper around assert.notStrictEqual()
 */
e***REMOVED***port declare function assertNotStrictEqual<N, T>(actual: T | N, e***REMOVED***pected: N, message?: string | Error): asserts actual is E***REMOVED***clude<T, N>;
/**
 * Asserts actual is a single key, not a key array or a key map.
 */
e***REMOVED***port declare function assertSingleKey(actual: string | string[] | Dictionary): asserts actual is string;
/**
 * Typing wrapper around Object.keys()
 */
e***REMOVED***port declare function objectKeys<T>(object: T): (keyof T)[];
