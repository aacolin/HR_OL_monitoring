import {parseE***REMOVED***pression, ParserOptions} from '@babel/parser';
import * as b from '@babel/types';
import binaryOperation from './binaryOperation';

e***REMOVED***port {ParserOptions as BabylonOptions};

e***REMOVED***port interface E***REMOVED***pressionToConstantOptions {
  constants?: any;
}

e***REMOVED***port interface Options e***REMOVED***tends E***REMOVED***pressionToConstantOptions {
  babylon?: ParserOptions;
}
e***REMOVED***port function e***REMOVED***pressionToConstant(
  e***REMOVED***pression: b.E***REMOVED***pression,
  options: E***REMOVED***pressionToConstantOptions = {},
): {constant: true; result: any} | {constant: false; result?: void} {
  let constant = true;
  function toConstant(e***REMOVED***pression: b.E***REMOVED***pression): any {
    if (!constant) return;
    if (b.isArrayE***REMOVED***pression(e***REMOVED***pression)) {
      const result = [];
      for (let i = 0; constant && i < e***REMOVED***pression.elements.length; i++) {
        const element = e***REMOVED***pression.elements[i];
        if (b.isSpreadElement(element)) {
          const spread = toConstant(element.argument);
          if (!(isSpreadable(spread) && constant)) {
            constant = false;
          } else {
            result.push(...spread);
          }
        } else if (b.isE***REMOVED***pression(element)) {
          result.push(toConstant(element));
        } else {
          constant = false;
        }
      }
      return result;
    }
    if (b.isBinaryE***REMOVED***pression(e***REMOVED***pression)) {
      const left = toConstant(e***REMOVED***pression.left);
      const right = toConstant(e***REMOVED***pression.right);
      return constant && binaryOperation(e***REMOVED***pression.operator, left, right);
    }
    if (b.isBooleanLiteral(e***REMOVED***pression)) {
      return e***REMOVED***pression.value;
    }
    if (b.isCallE***REMOVED***pression(e***REMOVED***pression)) {
      const args = [];
      for (let i = 0; constant && i < e***REMOVED***pression.arguments.length; i++) {
        const arg = e***REMOVED***pression.arguments[i];
        if (b.isSpreadElement(arg)) {
          const spread = toConstant(arg.argument);
          if (!(isSpreadable(spread) && constant)) {
            constant = false;
          } else {
            args.push(...spread);
          }
        } else if (b.isE***REMOVED***pression(arg)) {
          args.push(toConstant(arg));
        } else {
          constant = false;
        }
      }
      if (!constant) return;
      if (b.isMemberE***REMOVED***pression(e***REMOVED***pression.callee)) {
        const object = toConstant(e***REMOVED***pression.callee.object);
        if (!object || !constant) {
          constant = false;
          return;
        }
        const member = e***REMOVED***pression.callee.computed
          ? toConstant(e***REMOVED***pression.callee.property)
          : b.isIdentifier(e***REMOVED***pression.callee.property)
          ? e***REMOVED***pression.callee.property.name
          : undefined;
        if (member === undefined && !e***REMOVED***pression.callee.computed) {
          constant = false;
        }
        if (!constant) return;
        if (canCallMethod(object, '' + member)) {
          return object[member].apply(object, args);
        }
      } else {
        if (!b.isE***REMOVED***pression(e***REMOVED***pression.callee)) {
          constant = false;
          return;
        }
        const callee = toConstant(e***REMOVED***pression.callee);
        if (!constant) return;
        return callee.apply(null, args);
      }
    }
    if (b.isConditionalE***REMOVED***pression(e***REMOVED***pression)) {
      const test = toConstant(e***REMOVED***pression.test);
      return test
        ? toConstant(e***REMOVED***pression.consequent)
        : toConstant(e***REMOVED***pression.alternate);
    }
    if (b.isIdentifier(e***REMOVED***pression)) {
      if (
        options.constants &&
        {}.hasOwnProperty.call(options.constants, e***REMOVED***pression.name)
      ) {
        return options.constants[e***REMOVED***pression.name];
      }
    }
    if (b.isLogicalE***REMOVED***pression(e***REMOVED***pression)) {
      const left = toConstant(e***REMOVED***pression.left);
      const right = toConstant(e***REMOVED***pression.right);
      if (constant && e***REMOVED***pression.operator === '&&') {
        return left && right;
      }
      if (constant && e***REMOVED***pression.operator === '||') {
        return left || right;
      }
    }
    if (b.isMemberE***REMOVED***pression(e***REMOVED***pression)) {
      const object = toConstant(e***REMOVED***pression.object);
      if (!object || !constant) {
        constant = false;
        return;
      }
      const member = e***REMOVED***pression.computed
        ? toConstant(e***REMOVED***pression.property)
        : b.isIdentifier(e***REMOVED***pression.property)
        ? e***REMOVED***pression.property.name
        : undefined;
      if (member === undefined && !e***REMOVED***pression.computed) {
        constant = false;
      }
      if (!constant) return;
      if ({}.hasOwnProperty.call(object, '' + member) && member[0] !== '_') {
        return object[member];
      }
    }
    if (b.isNullLiteral(e***REMOVED***pression)) {
      return null;
    }
    if (b.isNumericLiteral(e***REMOVED***pression)) {
      return e***REMOVED***pression.value;
    }
    if (b.isObjectE***REMOVED***pression(e***REMOVED***pression)) {
      const result: any = {};
      for (let i = 0; constant && i < e***REMOVED***pression.properties.length; i++) {
        const property = e***REMOVED***pression.properties[i];
        if (b.isObjectProperty(property)) {
          if (property.shorthand) {
            constant = false;
            return;
          }
          const key = property.computed
            ? toConstant(property.key)
            : b.isIdentifier(property.key)
            ? property.key.name
            : b.isStringLiteral(property.key)
            ? property.key.value
            : undefined;
          if (!key || key[0] === '_') {
            constant = false;
          }
          if (!constant) return;
          if (b.isE***REMOVED***pression(property.value)) {
            const value = toConstant(property.value);
            if (!constant) return;
            result[key] = value;
          } else {
            constant = false;
          }
        } else if (b.isObjectMethod(property)) {
          constant = false;
        } else if (b.isSpreadProperty(property)) {
          const argument = toConstant(property.argument);
          if (!argument) constant = false;
          if (!constant) return;
          Object.assign(result, argument);
        }
      }
      return result;
    }
    if (b.isParenthesizedE***REMOVED***pression(e***REMOVED***pression)) {
      return toConstant(e***REMOVED***pression.e***REMOVED***pression);
    }
    if (b.isRegE***REMOVED***pLiteral(e***REMOVED***pression)) {
      return new RegE***REMOVED***p(e***REMOVED***pression.pattern, e***REMOVED***pression.flags);
    }
    if (b.isSequenceE***REMOVED***pression(e***REMOVED***pression)) {
      for (let i = 0; i < e***REMOVED***pression.e***REMOVED***pressions.length - 1 && constant; i++) {
        toConstant(e***REMOVED***pression.e***REMOVED***pressions[i]);
      }
      return toConstant(
        e***REMOVED***pression.e***REMOVED***pressions[e***REMOVED***pression.e***REMOVED***pressions.length - 1],
      );
    }
    if (b.isStringLiteral(e***REMOVED***pression)) {
      return e***REMOVED***pression.value;
    }
    // TODO: TaggedTemplateE***REMOVED***pression
    if (b.isTemplateLiteral(e***REMOVED***pression)) {
      let result = '';
      for (let i = 0; i < e***REMOVED***pression.quasis.length; i++) {
        const quasi = e***REMOVED***pression.quasis[i];
        result += quasi.value.cooked;
        if (i < e***REMOVED***pression.e***REMOVED***pressions.length) {
          result += '' + toConstant(e***REMOVED***pression.e***REMOVED***pressions[i]);
        }
      }
      return result;
    }
    if (b.isUnaryE***REMOVED***pression(e***REMOVED***pression)) {
      const argument = toConstant(e***REMOVED***pression.argument);
      if (!constant) {
        return;
      }
      switch (e***REMOVED***pression.operator) {
        case '-':
          return -argument;
        case '+':
          return +argument;
        case '!':
          return !argument;
        case '~':
          return ~argument;
        case 'typeof':
          return typeof argument;
        case 'void':
          return void argument;
      }
    }
    constant = false;
  }
  const result = toConstant(e***REMOVED***pression);
  return constant ? {constant: true, result} : {constant: false};
}
function isSpreadable(value: any): boolean {
  return (
    typeof value === 'string' ||
    Array.isArray(value) ||
    (typeof Set !== 'undefined' && value instanceof Set) ||
    (typeof Map !== 'undefined' && value instanceof Map)
  );
}
function shallowEqual(a: any, b: any) {
  if (a === b) return true;
  if (a && b && typeof a === 'object' && typeof b === 'object') {
    for (let key in a) {
      if (a[key] !== b[key]) {
        return false;
      }
    }
    for (let key in b) {
      if (a[key] !== b[key]) {
        return false;
      }
    }
    return true;
  }
  return false;
}
function canCallMethod(object: any, member: string): boolean {
  switch (typeof object) {
    case 'boolean':
      switch (member) {
        case 'toString':
          return true;
        default:
          return false;
      }
    case 'number':
      switch (member) {
        case 'toE***REMOVED***ponential':
        case 'toFi***REMOVED***ed':
        case 'toPrecision':
        case 'toString':
          return true;
        default:
          return false;
      }
    case 'string':
      switch (member) {
        case 'charAt':
        case 'charCodeAt':
        case 'codePointAt':
        case 'concat':
        case 'endsWith':
        case 'includes':
        case 'inde***REMOVED***Of':
        case 'lastInde***REMOVED***Of':
        case 'match':
        case 'normalize':
        case 'padEnd':
        case 'padStart':
        case 'repeat':
        case 'replace':
        case 'search':
        case 'slice':
        case 'split':
        case 'startsWith':
        case 'substr':
        case 'substring':
        case 'toLowerCase':
        case 'toUpperCase':
        case 'trim':
          return true;
        default:
          return false;
      }
    default:
      if (object instanceof RegE***REMOVED***p) {
        switch (member) {
          case 'test':
          case 'e***REMOVED***ec':
            return true;
          default:
            return false;
        }
      }
      return {}.hasOwnProperty.call(object, member) && member[0] !== '_';
  }
}

const EMPTY_OBJECT = {};
let lastSrc = '';
let lastConstants = EMPTY_OBJECT;
let lastOptions = EMPTY_OBJECT;
let lastResult: any = null;
let lastWasConstant = false;
e***REMOVED***port function isConstant(
  src: string,
  constants: any = EMPTY_OBJECT,
  options: ParserOptions = EMPTY_OBJECT,
) {
  if (
    lastSrc === src &&
    shallowEqual(lastConstants, constants) &&
    shallowEqual(lastOptions, options)
  ) {
    return lastWasConstant;
  }
  lastSrc = src;
  lastConstants = constants;
  let ast: b.E***REMOVED***pression | void;
  try {
    ast = parseE***REMOVED***pression(src, options);
  } catch (e***REMOVED***) {
    return (lastWasConstant = false);
  }
  const {result, constant} = e***REMOVED***pressionToConstant(ast, {constants});
  lastResult = result;
  return (lastWasConstant = constant);
}
e***REMOVED***port function toConstant(
  src: string,
  constants: any = EMPTY_OBJECT,
  options: ParserOptions = EMPTY_OBJECT,
) {
  if (!isConstant(src, constants, options)) {
    throw new Error(JSON.stringify(src) + ' is not constant.');
  }
  return lastResult;
}

e***REMOVED***port default isConstant;

module.e***REMOVED***ports = isConstant;
module.e***REMOVED***ports.default = isConstant;
module.e***REMOVED***ports.e***REMOVED***pressionToConstant = e***REMOVED***pressionToConstant;
module.e***REMOVED***ports.isConstant = isConstant;
module.e***REMOVED***ports.toConstant = toConstant;
