e***REMOVED***port function merge(...sets) {
    if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        const ***REMOVED***l = sets.length - 1;
        for (let ***REMOVED*** = 1; ***REMOVED*** < ***REMOVED***l; ++***REMOVED***) {
            sets[***REMOVED***] = sets[***REMOVED***].slice(1, -1);
        }
        sets[***REMOVED***l] = sets[***REMOVED***l].slice(1);
        return sets.join('');
    }
    else {
        return sets[0];
    }
}
e***REMOVED***port function sube***REMOVED***p(str) {
    return "(?:" + str + ")";
}
e***REMOVED***port function typeOf(o) {
    return o === undefined ? "undefined" : (o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase());
}
e***REMOVED***port function toUpperCase(str) {
    return str.toUpperCase();
}
e***REMOVED***port function toArray(obj) {
    return obj !== undefined && obj !== null ? (obj instanceof Array ? obj : (typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj))) : [];
}
e***REMOVED***port function assign(target, source) {
    const obj = target;
    if (source) {
        for (const key in source) {
            obj[key] = source[key];
        }
    }
    return obj;
}
//# sourceMappingURL=util.js.map