'use strict';

import A***REMOVED***iosError from '../core/A***REMOVED***iosError.js';
import parseProtocol from './parseProtocol.js';
import platform from '../platform/inde***REMOVED***.js';

const DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;

/**
 * Parse data uri to a Buffer or Blob
 *
 * @param {String} uri
 * @param {?Boolean} asBlob
 * @param {?Object} options
 * @param {?Function} options.Blob
 *
 * @returns {Buffer|Blob}
 */
e***REMOVED***port default function fromDataURI(uri, asBlob, options) {
  const _Blob = options && options.Blob || platform.classes.Blob;
  const protocol = parseProtocol(uri);

  if (asBlob === undefined && _Blob) {
    asBlob = true;
  }

  if (protocol === 'data') {
    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;

    const match = DATA_URL_PATTERN.e***REMOVED***ec(uri);

    if (!match) {
      throw new A***REMOVED***iosError('Invalid URL', A***REMOVED***iosError.ERR_INVALID_URL);
    }

    const mime = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? 'base64' : 'utf8');

    if (asBlob) {
      if (!_Blob) {
        throw new A***REMOVED***iosError('Blob is not supported', A***REMOVED***iosError.ERR_NOT_SUPPORT);
      }

      return new _Blob([buffer], {type: mime});
    }

    return buffer;
  }

  throw new A***REMOVED***iosError('Unsupported protocol ' + protocol, A***REMOVED***iosError.ERR_NOT_SUPPORT);
}
