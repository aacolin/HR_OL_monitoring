"use strict";

function makeE***REMOVED***ception(ErrorType, message, options) {
  if (options.globals) {
    ErrorType = options.globals[ErrorType.name];
  }
  return new ErrorType(`${options.conte***REMOVED***t ? options.conte***REMOVED***t : "Value"} ${message}.`);
}

function toNumber(value, options) {
  if (typeof value === "bigint") {
    throw makeE***REMOVED***ception(TypeError, "is a BigInt which cannot be converted to a number", options);
  }
  if (!options.globals) {
    return Number(value);
  }
  return options.globals.Number(value);
}

// Round ***REMOVED*** to the nearest integer, choosing the even integer if it lies halfway between two.
function evenRound(***REMOVED***) {
  // There are four cases for numbers with fractional part being .5:
  //
  // case |     ***REMOVED***     | floor(***REMOVED***) | round(***REMOVED***) | e***REMOVED***pected | ***REMOVED*** <> 0 | ***REMOVED*** % 1 | ***REMOVED*** & 1 |   e***REMOVED***ample
  //   1  |  2n + 0.5 |  2n      |  2n + 1  |  2n      |   >    |  0.5  |   0   |  0.5 ->  0
  //   2  |  2n + 1.5 |  2n + 1  |  2n + 2  |  2n + 2  |   >    |  0.5  |   1   |  1.5 ->  2
  //   3  | -2n - 0.5 | -2n - 1  | -2n      | -2n      |   <    | -0.5  |   0   | -0.5 ->  0
  //   4  | -2n - 1.5 | -2n - 2  | -2n - 1  | -2n - 2  |   <    | -0.5  |   1   | -1.5 -> -2
  // (where n is a non-negative integer)
  //
  // Branch here for cases 1 and 4
  if ((***REMOVED*** > 0 && (***REMOVED*** % 1) === +0.5 && (***REMOVED*** & 1) === 0) ||
        (***REMOVED*** < 0 && (***REMOVED*** % 1) === -0.5 && (***REMOVED*** & 1) === 1)) {
    return censorNegativeZero(Math.floor(***REMOVED***));
  }

  return censorNegativeZero(Math.round(***REMOVED***));
}

function integerPart(n) {
  return censorNegativeZero(Math.trunc(n));
}

function sign(***REMOVED***) {
  return ***REMOVED*** < 0 ? -1 : 1;
}

function modulo(***REMOVED***, y) {
  // https://tc39.github.io/ecma262/#eqn-modulo
  // Note that http://stackoverflow.com/a/4467559/3191 does NOT work for large modulos
  const signMightNotMatch = ***REMOVED*** % y;
  if (sign(y) !== sign(signMightNotMatch)) {
    return signMightNotMatch + y;
  }
  return signMightNotMatch;
}

function censorNegativeZero(***REMOVED***) {
  return ***REMOVED*** === 0 ? 0 : ***REMOVED***;
}

function createIntegerConversion(bitLength, { unsigned }) {
  let lowerBound, upperBound;
  if (unsigned) {
    lowerBound = 0;
    upperBound = 2 ** bitLength - 1;
  } else {
    lowerBound = -(2 ** (bitLength - 1));
    upperBound = 2 ** (bitLength - 1) - 1;
  }

  const twoToTheBitLength = 2 ** bitLength;
  const twoToOneLessThanTheBitLength = 2 ** (bitLength - 1);

  return (value, options = {}) => {
    let ***REMOVED*** = toNumber(value, options);
    ***REMOVED*** = censorNegativeZero(***REMOVED***);

    if (options.enforceRange) {
      if (!Number.isFinite(***REMOVED***)) {
        throw makeE***REMOVED***ception(TypeError, "is not a finite number", options);
      }

      ***REMOVED*** = integerPart(***REMOVED***);

      if (***REMOVED*** < lowerBound || ***REMOVED*** > upperBound) {
        throw makeE***REMOVED***ception(
          TypeError,
          `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`,
          options
        );
      }

      return ***REMOVED***;
    }

    if (!Number.isNaN(***REMOVED***) && options.clamp) {
      ***REMOVED*** = Math.min(Math.ma***REMOVED***(***REMOVED***, lowerBound), upperBound);
      ***REMOVED*** = evenRound(***REMOVED***);
      return ***REMOVED***;
    }

    if (!Number.isFinite(***REMOVED***) || ***REMOVED*** === 0) {
      return 0;
    }
    ***REMOVED*** = integerPart(***REMOVED***);

    // Math.pow(2, 64) is not accurately representable in JavaScript, so try to avoid these per-spec operations if
    // possible. Hopefully it's an optimization for the non-64-bitLength cases too.
    if (***REMOVED*** >= lowerBound && ***REMOVED*** <= upperBound) {
      return ***REMOVED***;
    }

    // These will not work great for bitLength of 64, but oh well. See the README for more details.
    ***REMOVED*** = modulo(***REMOVED***, twoToTheBitLength);
    if (!unsigned && ***REMOVED*** >= twoToOneLessThanTheBitLength) {
      return ***REMOVED*** - twoToTheBitLength;
    }
    return ***REMOVED***;
  };
}

function createLongLongConversion(bitLength, { unsigned }) {
  const upperBound = Number.MAX_SAFE_INTEGER;
  const lowerBound = unsigned ? 0 : Number.MIN_SAFE_INTEGER;
  const asBigIntN = unsigned ? BigInt.asUintN : BigInt.asIntN;

  return (value, options = {}) => {
    let ***REMOVED*** = toNumber(value, options);
    ***REMOVED*** = censorNegativeZero(***REMOVED***);

    if (options.enforceRange) {
      if (!Number.isFinite(***REMOVED***)) {
        throw makeE***REMOVED***ception(TypeError, "is not a finite number", options);
      }

      ***REMOVED*** = integerPart(***REMOVED***);

      if (***REMOVED*** < lowerBound || ***REMOVED*** > upperBound) {
        throw makeE***REMOVED***ception(
          TypeError,
          `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`,
          options
        );
      }

      return ***REMOVED***;
    }

    if (!Number.isNaN(***REMOVED***) && options.clamp) {
      ***REMOVED*** = Math.min(Math.ma***REMOVED***(***REMOVED***, lowerBound), upperBound);
      ***REMOVED*** = evenRound(***REMOVED***);
      return ***REMOVED***;
    }

    if (!Number.isFinite(***REMOVED***) || ***REMOVED*** === 0) {
      return 0;
    }

    let ***REMOVED***BigInt = BigInt(integerPart(***REMOVED***));
    ***REMOVED***BigInt = asBigIntN(bitLength, ***REMOVED***BigInt);
    return Number(***REMOVED***BigInt);
  };
}

e***REMOVED***ports.any = value => {
  return value;
};

e***REMOVED***ports.undefined = () => {
  return undefined;
};

e***REMOVED***ports.boolean = value => {
  return Boolean(value);
};

e***REMOVED***ports.byte = createIntegerConversion(8, { unsigned: false });
e***REMOVED***ports.octet = createIntegerConversion(8, { unsigned: true });

e***REMOVED***ports.short = createIntegerConversion(16, { unsigned: false });
e***REMOVED***ports["unsigned short"] = createIntegerConversion(16, { unsigned: true });

e***REMOVED***ports.long = createIntegerConversion(32, { unsigned: false });
e***REMOVED***ports["unsigned long"] = createIntegerConversion(32, { unsigned: true });

e***REMOVED***ports["long long"] = createLongLongConversion(64, { unsigned: false });
e***REMOVED***ports["unsigned long long"] = createLongLongConversion(64, { unsigned: true });

e***REMOVED***ports.double = (value, options = {}) => {
  const ***REMOVED*** = toNumber(value, options);

  if (!Number.isFinite(***REMOVED***)) {
    throw makeE***REMOVED***ception(TypeError, "is not a finite floating-point value", options);
  }

  return ***REMOVED***;
};

e***REMOVED***ports["unrestricted double"] = (value, options = {}) => {
  const ***REMOVED*** = toNumber(value, options);

  return ***REMOVED***;
};

e***REMOVED***ports.float = (value, options = {}) => {
  const ***REMOVED*** = toNumber(value, options);

  if (!Number.isFinite(***REMOVED***)) {
    throw makeE***REMOVED***ception(TypeError, "is not a finite floating-point value", options);
  }

  if (Object.is(***REMOVED***, -0)) {
    return ***REMOVED***;
  }

  const y = Math.fround(***REMOVED***);

  if (!Number.isFinite(y)) {
    throw makeE***REMOVED***ception(TypeError, "is outside the range of a single-precision floating-point value", options);
  }

  return y;
};

e***REMOVED***ports["unrestricted float"] = (value, options = {}) => {
  const ***REMOVED*** = toNumber(value, options);

  if (isNaN(***REMOVED***)) {
    return ***REMOVED***;
  }

  if (Object.is(***REMOVED***, -0)) {
    return ***REMOVED***;
  }

  return Math.fround(***REMOVED***);
};

e***REMOVED***ports.DOMString = (value, options = {}) => {
  if (options.treatNullAsEmptyString && value === null) {
    return "";
  }

  if (typeof value === "symbol") {
    throw makeE***REMOVED***ception(TypeError, "is a symbol, which cannot be converted to a string", options);
  }

  const StringCtor = options.globals ? options.globals.String : String;
  return StringCtor(value);
};

e***REMOVED***ports.ByteString = (value, options = {}) => {
  const ***REMOVED*** = e***REMOVED***ports.DOMString(value, options);
  let c;
  for (let i = 0; (c = ***REMOVED***.codePointAt(i)) !== undefined; ++i) {
    if (c > 255) {
      throw makeE***REMOVED***ception(TypeError, "is not a valid ByteString", options);
    }
  }

  return ***REMOVED***;
};

e***REMOVED***ports.USVString = (value, options = {}) => {
  const S = e***REMOVED***ports.DOMString(value, options);
  const n = S.length;
  const U = [];
  for (let i = 0; i < n; ++i) {
    const c = S.charCodeAt(i);
    if (c < 0***REMOVED***D800 || c > 0***REMOVED***DFFF) {
      U.push(String.fromCodePoint(c));
    } else if (0***REMOVED***DC00 <= c && c <= 0***REMOVED***DFFF) {
      U.push(String.fromCodePoint(0***REMOVED***FFFD));
    } else if (i === n - 1) {
      U.push(String.fromCodePoint(0***REMOVED***FFFD));
    } else {
      const d = S.charCodeAt(i + 1);
      if (0***REMOVED***DC00 <= d && d <= 0***REMOVED***DFFF) {
        const a = c & 0***REMOVED***3FF;
        const b = d & 0***REMOVED***3FF;
        U.push(String.fromCodePoint((2 << 15) + ((2 << 9) * a) + b));
        ++i;
      } else {
        U.push(String.fromCodePoint(0***REMOVED***FFFD));
      }
    }
  }

  return U.join("");
};

e***REMOVED***ports.object = (value, options = {}) => {
  if (value === null || (typeof value !== "object" && typeof value !== "function")) {
    throw makeE***REMOVED***ception(TypeError, "is not an object", options);
  }

  return value;
};

const abByteLengthGetter =
    Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
const sabByteLengthGetter =
    typeof SharedArrayBuffer === "function" ?
      Object.getOwnPropertyDescriptor(SharedArrayBuffer.prototype, "byteLength").get :
      null;

function isNonSharedArrayBuffer(value) {
  try {
    // This will throw on SharedArrayBuffers, but not detached ArrayBuffers.
    // (The spec says it should throw, but the spec conflicts with implementations: https://github.com/tc39/ecma262/issues/678)
    abByteLengthGetter.call(value);

    return true;
  } catch {
    return false;
  }
}

function isSharedArrayBuffer(value) {
  try {
    sabByteLengthGetter.call(value);
    return true;
  } catch {
    return false;
  }
}

function isArrayBufferDetached(value) {
  try {
    // eslint-disable-ne***REMOVED***t-line no-new
    new Uint8Array(value);
    return false;
  } catch {
    return true;
  }
}

e***REMOVED***ports.ArrayBuffer = (value, options = {}) => {
  if (!isNonSharedArrayBuffer(value)) {
    if (options.allowShared && !isSharedArrayBuffer(value)) {
      throw makeE***REMOVED***ception(TypeError, "is not an ArrayBuffer or SharedArrayBuffer", options);
    }
    throw makeE***REMOVED***ception(TypeError, "is not an ArrayBuffer", options);
  }
  if (isArrayBufferDetached(value)) {
    throw makeE***REMOVED***ception(TypeError, "is a detached ArrayBuffer", options);
  }

  return value;
};

const dvByteLengthGetter =
    Object.getOwnPropertyDescriptor(DataView.prototype, "byteLength").get;
e***REMOVED***ports.DataView = (value, options = {}) => {
  try {
    dvByteLengthGetter.call(value);
  } catch (e) {
    throw makeE***REMOVED***ception(TypeError, "is not a DataView", options);
  }

  if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
    throw makeE***REMOVED***ception(TypeError, "is backed by a SharedArrayBuffer, which is not allowed", options);
  }
  if (isArrayBufferDetached(value.buffer)) {
    throw makeE***REMOVED***ception(TypeError, "is backed by a detached ArrayBuffer", options);
  }

  return value;
};

// Returns the unforgeable `TypedArray` constructor name or `undefined`,
// if the `this` value isn't a valid `TypedArray` object.
//
// https://tc39.es/ecma262/#sec-get-%typedarray%.prototype-@@tostringtag
const typedArrayNameGetter = Object.getOwnPropertyDescriptor(
  Object.getPrototypeOf(Uint8Array).prototype,
  Symbol.toStringTag
).get;
[
  Int8Array,
  Int16Array,
  Int32Array,
  Uint8Array,
  Uint16Array,
  Uint32Array,
  Uint8ClampedArray,
  Float32Array,
  Float64Array
].forEach(func => {
  const { name } = func;
  const article = /^[AEIOU]/u.test(name) ? "an" : "a";
  e***REMOVED***ports[name] = (value, options = {}) => {
    if (!ArrayBuffer.isView(value) || typedArrayNameGetter.call(value) !== name) {
      throw makeE***REMOVED***ception(TypeError, `is not ${article} ${name} object`, options);
    }
    if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
      throw makeE***REMOVED***ception(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
    }
    if (isArrayBufferDetached(value.buffer)) {
      throw makeE***REMOVED***ception(TypeError, "is a view on a detached ArrayBuffer", options);
    }

    return value;
  };
});

// Common definitions

e***REMOVED***ports.ArrayBufferView = (value, options = {}) => {
  if (!ArrayBuffer.isView(value)) {
    throw makeE***REMOVED***ception(TypeError, "is not a view on an ArrayBuffer or SharedArrayBuffer", options);
  }

  if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
    throw makeE***REMOVED***ception(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
  }

  if (isArrayBufferDetached(value.buffer)) {
    throw makeE***REMOVED***ception(TypeError, "is a view on a detached ArrayBuffer", options);
  }
  return value;
};

e***REMOVED***ports.BufferSource = (value, options = {}) => {
  if (ArrayBuffer.isView(value)) {
    if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
      throw makeE***REMOVED***ception(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
    }

    if (isArrayBufferDetached(value.buffer)) {
      throw makeE***REMOVED***ception(TypeError, "is a view on a detached ArrayBuffer", options);
    }
    return value;
  }

  if (!options.allowShared && !isNonSharedArrayBuffer(value)) {
    throw makeE***REMOVED***ception(TypeError, "is not an ArrayBuffer or a view on one", options);
  }
  if (options.allowShared && !isSharedArrayBuffer(value) && !isNonSharedArrayBuffer(value)) {
    throw makeE***REMOVED***ception(TypeError, "is not an ArrayBuffer, SharedArrayBuffer, or a view on one", options);
  }
  if (isArrayBufferDetached(value)) {
    throw makeE***REMOVED***ception(TypeError, "is a detached ArrayBuffer", options);
  }

  return value;
};

e***REMOVED***ports.DOMTimeStamp = e***REMOVED***ports["unsigned long long"];
