'use strict';

var parseUrl = require('url').parse;

var DEFAULT_PORTS = {
  ftp: 21,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443,
};

var stringEndsWith = String.prototype.endsWith || function(s) {
  return s.length <= this.length &&
    this.inde***REMOVED***Of(s, this.length - s.length) !== -1;
};

/**
 * @param {string|object} url - The URL, or the result from url.parse.
 * @return {string} The URL of the pro***REMOVED***y that should handle the request to the
 *  given URL. If no pro***REMOVED***y is set, this will be an empty string.
 */
function getPro***REMOVED***yForUrl(url) {
  var parsedUrl = typeof url === 'string' ? parseUrl(url) : url || {};
  var proto = parsedUrl.protocol;
  var hostname = parsedUrl.host;
  var port = parsedUrl.port;
  if (typeof hostname !== 'string' || !hostname || typeof proto !== 'string') {
    return '';  // Don't pro***REMOVED***y URLs without a valid scheme or host.
  }

  proto = proto.split(':', 1)[0];
  // Stripping ports in this way instead of using parsedUrl.hostname to make
  // sure that the brackets around IPv6 addresses are kept.
  hostname = hostname.replace(/:\d*$/, '');
  port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
  if (!shouldPro***REMOVED***y(hostname, port)) {
    return '';  // Don't pro***REMOVED***y URLs that match NO_PROXY.
  }

  var pro***REMOVED***y =
    getEnv('npm_config_' + proto + '_pro***REMOVED***y') ||
    getEnv(proto + '_pro***REMOVED***y') ||
    getEnv('npm_config_pro***REMOVED***y') ||
    getEnv('all_pro***REMOVED***y');
  if (pro***REMOVED***y && pro***REMOVED***y.inde***REMOVED***Of('://') === -1) {
    // Missing scheme in pro***REMOVED***y, default to the requested URL's scheme.
    pro***REMOVED***y = proto + '://' + pro***REMOVED***y;
  }
  return pro***REMOVED***y;
}

/**
 * Determines whether a given URL should be pro***REMOVED***ied.
 *
 * @param {string} hostname - The host name of the URL.
 * @param {number} port - The effective port of the URL.
 * @returns {boolean} Whether the given URL should be pro***REMOVED***ied.
 * @private
 */
function shouldPro***REMOVED***y(hostname, port) {
  var NO_PROXY =
    (getEnv('npm_config_no_pro***REMOVED***y') || getEnv('no_pro***REMOVED***y')).toLowerCase();
  if (!NO_PROXY) {
    return true;  // Always pro***REMOVED***y if NO_PROXY is not set.
  }
  if (NO_PROXY === '*') {
    return false;  // Never pro***REMOVED***y if wildcard is set.
  }

  return NO_PROXY.split(/[,\s]/).every(function(pro***REMOVED***y) {
    if (!pro***REMOVED***y) {
      return true;  // Skip zero-length hosts.
    }
    var parsedPro***REMOVED***y = pro***REMOVED***y.match(/^(.+):(\d+)$/);
    var parsedPro***REMOVED***yHostname = parsedPro***REMOVED***y ? parsedPro***REMOVED***y[1] : pro***REMOVED***y;
    var parsedPro***REMOVED***yPort = parsedPro***REMOVED***y ? parseInt(parsedPro***REMOVED***y[2]) : 0;
    if (parsedPro***REMOVED***yPort && parsedPro***REMOVED***yPort !== port) {
      return true;  // Skip if ports don't match.
    }

    if (!/^[.*]/.test(parsedPro***REMOVED***yHostname)) {
      // No wildcards, so stop pro***REMOVED***ying if there is an e***REMOVED***act match.
      return hostname !== parsedPro***REMOVED***yHostname;
    }

    if (parsedPro***REMOVED***yHostname.charAt(0) === '*') {
      // Remove leading wildcard.
      parsedPro***REMOVED***yHostname = parsedPro***REMOVED***yHostname.slice(1);
    }
    // Stop pro***REMOVED***ying if the hostname ends with the no_pro***REMOVED***y host.
    return !stringEndsWith.call(hostname, parsedPro***REMOVED***yHostname);
  });
}

/**
 * Get the value for an environment variable.
 *
 * @param {string} key - The name of the environment variable.
 * @return {string} The value of the environment variable.
 * @private
 */
function getEnv(key) {
  return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || '';
}

e***REMOVED***ports.getPro***REMOVED***yForUrl = getPro***REMOVED***yForUrl;
