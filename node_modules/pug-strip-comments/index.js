'use strict';

var error = require('pug-error');

module.e***REMOVED***ports = stripComments;

function une***REMOVED***pectedToken(type, occasion, filename, line) {
  var msg = '`' + type + '` encountered when ' + occasion;
  throw error('UNEXPECTED_TOKEN', msg, {filename: filename, line: line});
}

function stripComments(input, options) {
  options = options || {};

  // Default: strip unbuffered comments and leave buffered ones alone
  var stripUnbuffered = options.stripUnbuffered !== false;
  var stripBuffered = options.stripBuffered === true;
  var filename = options.filename;

  var out = [];
  // If we have encountered a comment token and are not sure if we have gotten
  // out of the comment or not
  var inComment = false;
  // If we are sure that we are in a block comment and all tokens e***REMOVED***cept
  // `end-pipeless-te***REMOVED***t` should be ignored
  var inPipelessTe***REMOVED***t = false;

  return input.filter(function(tok) {
    switch (tok.type) {
      case 'comment':
        if (inComment) {
          une***REMOVED***pectedToken(
            'comment',
            'already in a comment',
            filename,
            tok.line
          );
        } else {
          inComment = tok.buffer ? stripBuffered : stripUnbuffered;
          return !inComment;
        }
      case 'start-pipeless-te***REMOVED***t':
        if (!inComment) return true;
        if (inPipelessTe***REMOVED***t) {
          une***REMOVED***pectedToken(
            'start-pipeless-te***REMOVED***t',
            'already in pipeless te***REMOVED***t mode',
            filename,
            tok.line
          );
        }
        inPipelessTe***REMOVED***t = true;
        return false;
      case 'end-pipeless-te***REMOVED***t':
        if (!inComment) return true;
        if (!inPipelessTe***REMOVED***t) {
          une***REMOVED***pectedToken(
            'end-pipeless-te***REMOVED***t',
            'not in pipeless te***REMOVED***t mode',
            filename,
            tok.line
          );
        }
        inPipelessTe***REMOVED***t = false;
        inComment = false;
        return false;
      // There might be a `te***REMOVED***t` right after `comment` but before
      // `start-pipeless-te***REMOVED***t`. Treat it accordingly.
      case 'te***REMOVED***t':
        return !inComment;
      default:
        if (inPipelessTe***REMOVED***t) return false;
        inComment = false;
        return true;
    }
  });
}
