(function(nacl) {
'use strict';

// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
//
// Implementation derived from TweetNaCl version 20140427.
// See for details: http://tweetnacl.cr.yp.to/

var u64 = function(h, l) { this.hi = h|0 >>> 0; this.lo = l|0 >>> 0; };
var gf = function(init) {
  var i, r = new Float64Array(16);
  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
  return r;
};

//  Pluggable, initialized in high-level API below.
var randombytes = function(/* ***REMOVED***, n */) { throw new Error('no PRNG'); };

var _0 = new Uint8Array(16);
var _9 = new Uint8Array(32); _9[0] = 9;

var gf0 = gf(),
    gf1 = gf([1]),
    _121665 = gf([0***REMOVED***db41, 1]),
    D = gf([0***REMOVED***78a3, 0***REMOVED***1359, 0***REMOVED***4dca, 0***REMOVED***75eb, 0***REMOVED***d8ab, 0***REMOVED***4141, 0***REMOVED***0a4d, 0***REMOVED***0070, 0***REMOVED***e898, 0***REMOVED***7779, 0***REMOVED***4079, 0***REMOVED***8cc7, 0***REMOVED***fe73, 0***REMOVED***2b6f, 0***REMOVED***6cee, 0***REMOVED***5203]),
    D2 = gf([0***REMOVED***f159, 0***REMOVED***26b2, 0***REMOVED***9b94, 0***REMOVED***ebd6, 0***REMOVED***b156, 0***REMOVED***8283, 0***REMOVED***149a, 0***REMOVED***00e0, 0***REMOVED***d130, 0***REMOVED***eef3, 0***REMOVED***80f2, 0***REMOVED***198e, 0***REMOVED***fce7, 0***REMOVED***56df, 0***REMOVED***d9dc, 0***REMOVED***2406]),
    X = gf([0***REMOVED***d51a, 0***REMOVED***8f25, 0***REMOVED***2d60, 0***REMOVED***c956, 0***REMOVED***a7b2, 0***REMOVED***9525, 0***REMOVED***c760, 0***REMOVED***692c, 0***REMOVED***dc5c, 0***REMOVED***fdd6, 0***REMOVED***e231, 0***REMOVED***c0a4, 0***REMOVED***53fe, 0***REMOVED***cd6e, 0***REMOVED***36d3, 0***REMOVED***2169]),
    Y = gf([0***REMOVED***6658, 0***REMOVED***6666, 0***REMOVED***6666, 0***REMOVED***6666, 0***REMOVED***6666, 0***REMOVED***6666, 0***REMOVED***6666, 0***REMOVED***6666, 0***REMOVED***6666, 0***REMOVED***6666, 0***REMOVED***6666, 0***REMOVED***6666, 0***REMOVED***6666, 0***REMOVED***6666, 0***REMOVED***6666, 0***REMOVED***6666]),
    I = gf([0***REMOVED***a0b0, 0***REMOVED***4a0e, 0***REMOVED***1b27, 0***REMOVED***c4ee, 0***REMOVED***e478, 0***REMOVED***ad2f, 0***REMOVED***1806, 0***REMOVED***2f43, 0***REMOVED***d7a7, 0***REMOVED***3dfb, 0***REMOVED***0099, 0***REMOVED***2b4d, 0***REMOVED***df0b, 0***REMOVED***4fc1, 0***REMOVED***2480, 0***REMOVED***2b83]);

function L32(***REMOVED***, c) { return (***REMOVED*** << c) | (***REMOVED*** >>> (32 - c)); }

function ld32(***REMOVED***, i) {
  var u = ***REMOVED***[i+3] & 0***REMOVED***ff;
  u = (u<<8)|(***REMOVED***[i+2] & 0***REMOVED***ff);
  u = (u<<8)|(***REMOVED***[i+1] & 0***REMOVED***ff);
  return (u<<8)|(***REMOVED***[i+0] & 0***REMOVED***ff);
}

function dl64(***REMOVED***, i) {
  var h = (***REMOVED***[i] << 24) | (***REMOVED***[i+1] << 16) | (***REMOVED***[i+2] << 8) | ***REMOVED***[i+3];
  var l = (***REMOVED***[i+4] << 24) | (***REMOVED***[i+5] << 16) | (***REMOVED***[i+6] << 8) | ***REMOVED***[i+7];
  return new u64(h, l);
}

function st32(***REMOVED***, j, u) {
  var i;
  for (i = 0; i < 4; i++) { ***REMOVED***[j+i] = u & 255; u >>>= 8; }
}

function ts64(***REMOVED***, i, u) {
  ***REMOVED***[i]   = (u.hi >> 24) & 0***REMOVED***ff;
  ***REMOVED***[i+1] = (u.hi >> 16) & 0***REMOVED***ff;
  ***REMOVED***[i+2] = (u.hi >>  8) & 0***REMOVED***ff;
  ***REMOVED***[i+3] = u.hi & 0***REMOVED***ff;
  ***REMOVED***[i+4] = (u.lo >> 24)  & 0***REMOVED***ff;
  ***REMOVED***[i+5] = (u.lo >> 16)  & 0***REMOVED***ff;
  ***REMOVED***[i+6] = (u.lo >>  8)  & 0***REMOVED***ff;
  ***REMOVED***[i+7] = u.lo & 0***REMOVED***ff;
}

function vn(***REMOVED***, ***REMOVED***i, y, yi, n) {
  var i,d = 0;
  for (i = 0; i < n; i++) d |= ***REMOVED***[***REMOVED***i+i]^y[yi+i];
  return (1 & ((d - 1) >>> 8)) - 1;
}

function crypto_verify_16(***REMOVED***, ***REMOVED***i, y, yi) {
  return vn(***REMOVED***,***REMOVED***i,y,yi,16);
}

function crypto_verify_32(***REMOVED***, ***REMOVED***i, y, yi) {
  return vn(***REMOVED***,***REMOVED***i,y,yi,32);
}

function core(out,inp,k,c,h) {
  var w = new Uint32Array(16), ***REMOVED*** = new Uint32Array(16),
      y = new Uint32Array(16), t = new Uint32Array(4);
  var i, j, m;

  for (i = 0; i < 4; i++) {
    ***REMOVED***[5*i] = ld32(c, 4*i);
    ***REMOVED***[1+i] = ld32(k, 4*i);
    ***REMOVED***[6+i] = ld32(inp, 4*i);
    ***REMOVED***[11+i] = ld32(k, 16+4*i);
  }

  for (i = 0; i < 16; i++) y[i] = ***REMOVED***[i];

  for (i = 0; i < 20; i++) {
    for (j = 0; j < 4; j++) {
      for (m = 0; m < 4; m++) t[m] = ***REMOVED***[(5*j+4*m)%16];
      t[1] ^= L32((t[0]+t[3])|0, 7);
      t[2] ^= L32((t[1]+t[0])|0, 9);
      t[3] ^= L32((t[2]+t[1])|0,13);
      t[0] ^= L32((t[3]+t[2])|0,18);
      for (m = 0; m < 4; m++) w[4*j+(j+m)%4] = t[m];
    }
    for (m = 0; m < 16; m++) ***REMOVED***[m] = w[m];
  }

  if (h) {
    for (i = 0; i < 16; i++) ***REMOVED***[i] = (***REMOVED***[i] + y[i]) | 0;
    for (i = 0; i < 4; i++) {
      ***REMOVED***[5*i] = (***REMOVED***[5*i] - ld32(c, 4*i)) | 0;
      ***REMOVED***[6+i] = (***REMOVED***[6+i] - ld32(inp, 4*i)) | 0;
    }
    for (i = 0; i < 4; i++) {
      st32(out,4*i,***REMOVED***[5*i]);
      st32(out,16+4*i,***REMOVED***[6+i]);
    }
  } else {
    for (i = 0; i < 16; i++) st32(out, 4 * i, (***REMOVED***[i] + y[i]) | 0);
  }
}

function crypto_core_salsa20(out,inp,k,c) {
  core(out,inp,k,c,false);
  return 0;
}

function crypto_core_hsalsa20(out,inp,k,c) {
  core(out,inp,k,c,true);
  return 0;
}

var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
            // "e***REMOVED***pand 32-byte k"

function crypto_stream_salsa20_***REMOVED***or(c,cpos,m,mpos,b,n,k) {
  var z = new Uint8Array(16), ***REMOVED*** = new Uint8Array(64);
  var u, i;
  if (!b) return 0;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(***REMOVED***,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = (m?m[mpos+i]:0) ^ ***REMOVED***[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0***REMOVED***ff) | 0;
      z[i] = u & 0***REMOVED***ff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
    if (m) mpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(***REMOVED***,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = (m?m[mpos+i]:0) ^ ***REMOVED***[i];
  }
  return 0;
}

function crypto_stream_salsa20(c,cpos,d,n,k) {
  return crypto_stream_salsa20_***REMOVED***or(c,cpos,null,0,d,n,k);
}

function crypto_stream(c,cpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  return crypto_stream_salsa20(c,cpos,d,n.subarray(16),s);
}

function crypto_stream_***REMOVED***or(c,cpos,m,mpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  return crypto_stream_salsa20_***REMOVED***or(c,cpos,m,mpos,d,n.subarray(16),s);
}

function add1305(h, c) {
  var j, u = 0;
  for (j = 0; j < 17; j++) {
    u = (u + ((h[j] + c[j]) | 0)) | 0;
    h[j] = u & 255;
    u >>>= 8;
  }
}

var minusp = new Uint32Array([
  5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 252
]);

function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
  var s, i, j, u;
  var ***REMOVED*** = new Uint32Array(17), r = new Uint32Array(17),
      h = new Uint32Array(17), c = new Uint32Array(17),
      g = new Uint32Array(17);
  for (j = 0; j < 17; j++) r[j]=h[j]=0;
  for (j = 0; j < 16; j++) r[j]=k[j];
  r[3]&=15;
  r[4]&=252;
  r[7]&=15;
  r[8]&=252;
  r[11]&=15;
  r[12]&=252;
  r[15]&=15;

  while (n > 0) {
    for (j = 0; j < 17; j++) c[j] = 0;
    for (j = 0; (j < 16) && (j < n); ++j) c[j] = m[mpos+j];
    c[j] = 1;
    mpos += j; n -= j;
    add1305(h,c);
    for (i = 0; i < 17; i++) {
      ***REMOVED***[i] = 0;
      for (j = 0; j < 17; j++) ***REMOVED***[i] = (***REMOVED***[i] + (h[j] * ((j <= i) ? r[i - j] : ((320 * r[i + 17 - j])|0))) | 0) | 0;
    }
    for (i = 0; i < 17; i++) h[i] = ***REMOVED***[i];
    u = 0;
    for (j = 0; j < 16; j++) {
      u = (u + h[j]) | 0;
      h[j] = u & 255;
      u >>>= 8;
    }
    u = (u + h[16]) | 0; h[16] = u & 3;
    u = (5 * (u >>> 2)) | 0;
    for (j = 0; j < 16; j++) {
      u = (u + h[j]) | 0;
      h[j] = u & 255;
      u >>>= 8;
    }
    u = (u + h[16]) | 0; h[16] = u;
  }

  for (j = 0; j < 17; j++) g[j] = h[j];
  add1305(h,minusp);
  s = (-(h[16] >>> 7) | 0);
  for (j = 0; j < 17; j++) h[j] ^= s & (g[j] ^ h[j]);

  for (j = 0; j < 16; j++) c[j] = k[j + 16];
  c[16] = 0;
  add1305(h,c);
  for (j = 0; j < 16; j++) out[outpos+j] = h[j];
  return 0;
}

function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
  var ***REMOVED*** = new Uint8Array(16);
  crypto_onetimeauth(***REMOVED***,0,m,mpos,n,k);
  return crypto_verify_16(h,hpos,***REMOVED***,0);
}

function crypto_secretbo***REMOVED***(c,m,d,n,k) {
  var i;
  if (d < 32) return -1;
  crypto_stream_***REMOVED***or(c,0,m,0,d,n,k);
  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
  for (i = 0; i < 16; i++) c[i] = 0;
  return 0;
}

function crypto_secretbo***REMOVED***_open(m,c,d,n,k) {
  var i;
  var ***REMOVED*** = new Uint8Array(32);
  if (d < 32) return -1;
  crypto_stream(***REMOVED***,0,32,n,k);
  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,***REMOVED***) !== 0) return -1;
  crypto_stream_***REMOVED***or(m,0,c,0,d,n,k);
  for (i = 0; i < 32; i++) m[i] = 0;
  return 0;
}

function set25519(r, a) {
  var i;
  for (i = 0; i < 16; i++) r[i] = a[i]|0;
}

function car25519(o) {
  var c;
  var i;
  for (i = 0; i < 16; i++) {
      o[i] += 65536;
      c = Math.floor(o[i] / 65536);
      o[(i+1)*(i<15?1:0)] += c - 1 + 37 * (c-1) * (i===15?1:0);
      o[i] -= (c * 65536);
  }
}

function sel25519(p, q, b) {
  var t, c = ~(b-1);
  for (var i = 0; i < 16; i++) {
    t = c & (p[i] ^ q[i]);
    p[i] ^= t;
    q[i] ^= t;
  }
}

function pack25519(o, n) {
  var i, j, b;
  var m = gf(), t = gf();
  for (i = 0; i < 16; i++) t[i] = n[i];
  car25519(t);
  car25519(t);
  car25519(t);
  for (j = 0; j < 2; j++) {
    m[0] = t[0] - 0***REMOVED***ffed;
    for (i = 1; i < 15; i++) {
      m[i] = t[i] - 0***REMOVED***ffff - ((m[i-1]>>16) & 1);
      m[i-1] &= 0***REMOVED***ffff;
    }
    m[15] = t[15] - 0***REMOVED***7fff - ((m[14]>>16) & 1);
    b = (m[15]>>16) & 1;
    m[14] &= 0***REMOVED***ffff;
    sel25519(t, m, 1-b);
  }
  for (i = 0; i < 16; i++) {
    o[2*i] = t[i] & 0***REMOVED***ff;
    o[2*i+1] = t[i]>>8;
  }
}

function neq25519(a, b) {
  var c = new Uint8Array(32), d = new Uint8Array(32);
  pack25519(c, a);
  pack25519(d, b);
  return crypto_verify_32(c, 0, d, 0);
}

function par25519(a) {
  var d = new Uint8Array(32);
  pack25519(d, a);
  return d[0] & 1;
}

function unpack25519(o, n) {
  var i;
  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
  o[15] &= 0***REMOVED***7fff;
}

function A(o, a, b) {
  var i;
  for (i = 0; i < 16; i++) o[i] = (a[i] + b[i])|0;
}

function Z(o, a, b) {
  var i;
  for (i = 0; i < 16; i++) o[i] = (a[i] - b[i])|0;
}

function M(o, a, b) {
  var i, j, t = new Float64Array(31);
  for (i = 0; i < 31; i++) t[i] = 0;
  for (i = 0; i < 16; i++) {
    for (j = 0; j < 16; j++) {
      t[i+j] += a[i] * b[j];
    }
  }
  for (i = 0; i < 15; i++) {
    t[i] += 38 * t[i+16];
  }
  for (i = 0; i < 16; i++) o[i] = t[i];
  car25519(o);
  car25519(o);
}

function S(o, a) {
  M(o, a, a);
}

function inv25519(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 253; a >= 0; a--) {
    S(c, c);
    if(a !== 2 && a !== 4) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function pow2523(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 250; a >= 0; a--) {
      S(c, c);
      if(a !== 1) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function crypto_scalarmult(q, n, p) {
  var z = new Uint8Array(32);
  var ***REMOVED*** = new Float64Array(80), r, i;
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf();
  for (i = 0; i < 31; i++) z[i] = n[i];
  z[31]=(n[31]&127)|64;
  z[0]&=248;
  unpack25519(***REMOVED***,p);
  for (i = 0; i < 16; i++) {
    b[i]=***REMOVED***[i];
    d[i]=a[i]=c[i]=0;
  }
  a[0]=d[0]=1;
  for (i=254; i>=0; --i) {
    r=(z[i>>>3]>>>(i&7))&1;
    sel25519(a,b,r);
    sel25519(c,d,r);
    A(e,a,c);
    Z(a,a,c);
    A(c,b,d);
    Z(b,b,d);
    S(d,e);
    S(f,a);
    M(a,c,a);
    M(c,b,e);
    A(e,a,c);
    Z(a,a,c);
    S(b,a);
    Z(c,d,f);
    M(a,c,_121665);
    A(a,a,d);
    M(c,c,a);
    M(a,d,f);
    M(d,b,***REMOVED***);
    S(b,e);
    sel25519(a,b,r);
    sel25519(c,d,r);
  }
  for (i = 0; i < 16; i++) {
    ***REMOVED***[i+16]=a[i];
    ***REMOVED***[i+32]=c[i];
    ***REMOVED***[i+48]=b[i];
    ***REMOVED***[i+64]=d[i];
  }
  var ***REMOVED***32 = ***REMOVED***.subarray(32);
  var ***REMOVED***16 = ***REMOVED***.subarray(16);
  inv25519(***REMOVED***32,***REMOVED***32);
  M(***REMOVED***16,***REMOVED***16,***REMOVED***32);
  pack25519(q,***REMOVED***16);
  return 0;
}

function crypto_scalarmult_base(q, n) {
  return crypto_scalarmult(q, n, _9);
}

function crypto_bo***REMOVED***_keypair(y, ***REMOVED***) {
  randombytes(***REMOVED***, 32);
  return crypto_scalarmult_base(y, ***REMOVED***);
}

function crypto_bo***REMOVED***_beforenm(k, y, ***REMOVED***) {
  var s = new Uint8Array(32);
  crypto_scalarmult(s, ***REMOVED***, y);
  return crypto_core_hsalsa20(k, _0, s, sigma);
}

var crypto_bo***REMOVED***_afternm = crypto_secretbo***REMOVED***;
var crypto_bo***REMOVED***_open_afternm = crypto_secretbo***REMOVED***_open;

function crypto_bo***REMOVED***(c, m, d, n, y, ***REMOVED***) {
  var k = new Uint8Array(32);
  crypto_bo***REMOVED***_beforenm(k, y, ***REMOVED***);
  return crypto_bo***REMOVED***_afternm(c, m, d, n, k);
}

function crypto_bo***REMOVED***_open(m, c, d, n, y, ***REMOVED***) {
  var k = new Uint8Array(32);
  crypto_bo***REMOVED***_beforenm(k, y, ***REMOVED***);
  return crypto_bo***REMOVED***_open_afternm(m, c, d, n, k);
}

function add64() {
  var a = 0, b = 0, c = 0, d = 0, m16 = 65535, l, h, i;
  for (i = 0; i < arguments.length; i++) {
    l = arguments[i].lo;
    h = arguments[i].hi;
    a += (l & m16); b += (l >>> 16);
    c += (h & m16); d += (h >>> 16);
  }

  b += (a >>> 16);
  c += (b >>> 16);
  d += (c >>> 16);

  return new u64((c & m16) | (d << 16), (a & m16) | (b << 16));
}

function shr64(***REMOVED***, c) {
  return new u64((***REMOVED***.hi >>> c), (***REMOVED***.lo >>> c) | (***REMOVED***.hi << (32 - c)));
}

function ***REMOVED***or64() {
  var l = 0, h = 0, i;
  for (i = 0; i < arguments.length; i++) {
    l ^= arguments[i].lo;
    h ^= arguments[i].hi;
  }
  return new u64(h, l);
}

function R(***REMOVED***, c) {
  var h, l, c1 = 32 - c;
  if (c < 32) {
    h = (***REMOVED***.hi >>> c) | (***REMOVED***.lo << c1);
    l = (***REMOVED***.lo >>> c) | (***REMOVED***.hi << c1);
  } else if (c < 64) {
    h = (***REMOVED***.lo >>> c) | (***REMOVED***.hi << c1);
    l = (***REMOVED***.hi >>> c) | (***REMOVED***.lo << c1);
  }
  return new u64(h, l);
}

function Ch(***REMOVED***, y, z) {
  var h = (***REMOVED***.hi & y.hi) ^ (~***REMOVED***.hi & z.hi),
      l = (***REMOVED***.lo & y.lo) ^ (~***REMOVED***.lo & z.lo);
  return new u64(h, l);
}

function Maj(***REMOVED***, y, z) {
  var h = (***REMOVED***.hi & y.hi) ^ (***REMOVED***.hi & z.hi) ^ (y.hi & z.hi),
      l = (***REMOVED***.lo & y.lo) ^ (***REMOVED***.lo & z.lo) ^ (y.lo & z.lo);
  return new u64(h, l);
}

function Sigma0(***REMOVED***) { return ***REMOVED***or64(R(***REMOVED***,28), R(***REMOVED***,34), R(***REMOVED***,39)); }
function Sigma1(***REMOVED***) { return ***REMOVED***or64(R(***REMOVED***,14), R(***REMOVED***,18), R(***REMOVED***,41)); }
function sigma0(***REMOVED***) { return ***REMOVED***or64(R(***REMOVED***, 1), R(***REMOVED***, 8), shr64(***REMOVED***,7)); }
function sigma1(***REMOVED***) { return ***REMOVED***or64(R(***REMOVED***,19), R(***REMOVED***,61), shr64(***REMOVED***,6)); }

var K = [
  new u64(0***REMOVED***428a2f98, 0***REMOVED***d728ae22), new u64(0***REMOVED***71374491, 0***REMOVED***23ef65cd),
  new u64(0***REMOVED***b5c0fbcf, 0***REMOVED***ec4d3b2f), new u64(0***REMOVED***e9b5dba5, 0***REMOVED***8189dbbc),
  new u64(0***REMOVED***3956c25b, 0***REMOVED***f348b538), new u64(0***REMOVED***59f111f1, 0***REMOVED***b605d019),
  new u64(0***REMOVED***923f82a4, 0***REMOVED***af194f9b), new u64(0***REMOVED***ab1c5ed5, 0***REMOVED***da6d8118),
  new u64(0***REMOVED***d807aa98, 0***REMOVED***a3030242), new u64(0***REMOVED***12835b01, 0***REMOVED***45706fbe),
  new u64(0***REMOVED***243185be, 0***REMOVED***4ee4b28c), new u64(0***REMOVED***550c7dc3, 0***REMOVED***d5ffb4e2),
  new u64(0***REMOVED***72be5d74, 0***REMOVED***f27b896f), new u64(0***REMOVED***80deb1fe, 0***REMOVED***3b1696b1),
  new u64(0***REMOVED***9bdc06a7, 0***REMOVED***25c71235), new u64(0***REMOVED***c19bf174, 0***REMOVED***cf692694),
  new u64(0***REMOVED***e49b69c1, 0***REMOVED***9ef14ad2), new u64(0***REMOVED***efbe4786, 0***REMOVED***384f25e3),
  new u64(0***REMOVED***0fc19dc6, 0***REMOVED***8b8cd5b5), new u64(0***REMOVED***240ca1cc, 0***REMOVED***77ac9c65),
  new u64(0***REMOVED***2de92c6f, 0***REMOVED***592b0275), new u64(0***REMOVED***4a7484aa, 0***REMOVED***6ea6e483),
  new u64(0***REMOVED***5cb0a9dc, 0***REMOVED***bd41fbd4), new u64(0***REMOVED***76f988da, 0***REMOVED***831153b5),
  new u64(0***REMOVED***983e5152, 0***REMOVED***ee66dfab), new u64(0***REMOVED***a831c66d, 0***REMOVED***2db43210),
  new u64(0***REMOVED***b00327c8, 0***REMOVED***98fb213f), new u64(0***REMOVED***bf597fc7, 0***REMOVED***beef0ee4),
  new u64(0***REMOVED***c6e00bf3, 0***REMOVED***3da88fc2), new u64(0***REMOVED***d5a79147, 0***REMOVED***930aa725),
  new u64(0***REMOVED***06ca6351, 0***REMOVED***e003826f), new u64(0***REMOVED***14292967, 0***REMOVED***0a0e6e70),
  new u64(0***REMOVED***27b70a85, 0***REMOVED***46d22ffc), new u64(0***REMOVED***2e1b2138, 0***REMOVED***5c26c926),
  new u64(0***REMOVED***4d2c6dfc, 0***REMOVED***5ac42aed), new u64(0***REMOVED***53380d13, 0***REMOVED***9d95b3df),
  new u64(0***REMOVED***650a7354, 0***REMOVED***8baf63de), new u64(0***REMOVED***766a0abb, 0***REMOVED***3c77b2a8),
  new u64(0***REMOVED***81c2c92e, 0***REMOVED***47edaee6), new u64(0***REMOVED***92722c85, 0***REMOVED***1482353b),
  new u64(0***REMOVED***a2bfe8a1, 0***REMOVED***4cf10364), new u64(0***REMOVED***a81a664b, 0***REMOVED***bc423001),
  new u64(0***REMOVED***c24b8b70, 0***REMOVED***d0f89791), new u64(0***REMOVED***c76c51a3, 0***REMOVED***0654be30),
  new u64(0***REMOVED***d192e819, 0***REMOVED***d6ef5218), new u64(0***REMOVED***d6990624, 0***REMOVED***5565a910),
  new u64(0***REMOVED***f40e3585, 0***REMOVED***5771202a), new u64(0***REMOVED***106aa070, 0***REMOVED***32bbd1b8),
  new u64(0***REMOVED***19a4c116, 0***REMOVED***b8d2d0c8), new u64(0***REMOVED***1e376c08, 0***REMOVED***5141ab53),
  new u64(0***REMOVED***2748774c, 0***REMOVED***df8eeb99), new u64(0***REMOVED***34b0bcb5, 0***REMOVED***e19b48a8),
  new u64(0***REMOVED***391c0cb3, 0***REMOVED***c5c95a63), new u64(0***REMOVED***4ed8aa4a, 0***REMOVED***e3418acb),
  new u64(0***REMOVED***5b9cca4f, 0***REMOVED***7763e373), new u64(0***REMOVED***682e6ff3, 0***REMOVED***d6b2b8a3),
  new u64(0***REMOVED***748f82ee, 0***REMOVED***5defb2fc), new u64(0***REMOVED***78a5636f, 0***REMOVED***43172f60),
  new u64(0***REMOVED***84c87814, 0***REMOVED***a1f0ab72), new u64(0***REMOVED***8cc70208, 0***REMOVED***1a6439ec),
  new u64(0***REMOVED***90befffa, 0***REMOVED***23631e28), new u64(0***REMOVED***a4506ceb, 0***REMOVED***de82bde9),
  new u64(0***REMOVED***bef9a3f7, 0***REMOVED***b2c67915), new u64(0***REMOVED***c67178f2, 0***REMOVED***e372532b),
  new u64(0***REMOVED***ca273ece, 0***REMOVED***ea26619c), new u64(0***REMOVED***d186b8c7, 0***REMOVED***21c0c207),
  new u64(0***REMOVED***eada7dd6, 0***REMOVED***cde0eb1e), new u64(0***REMOVED***f57d4f7f, 0***REMOVED***ee6ed178),
  new u64(0***REMOVED***06f067aa, 0***REMOVED***72176fba), new u64(0***REMOVED***0a637dc5, 0***REMOVED***a2c898a6),
  new u64(0***REMOVED***113f9804, 0***REMOVED***bef90dae), new u64(0***REMOVED***1b710b35, 0***REMOVED***131c471b),
  new u64(0***REMOVED***28db77f5, 0***REMOVED***23047d84), new u64(0***REMOVED***32caab7b, 0***REMOVED***40c72493),
  new u64(0***REMOVED***3c9ebe0a, 0***REMOVED***15c9bebc), new u64(0***REMOVED***431d67c4, 0***REMOVED***9c100d4c),
  new u64(0***REMOVED***4cc5d4be, 0***REMOVED***cb3e42b6), new u64(0***REMOVED***597f299c, 0***REMOVED***fc657e2a),
  new u64(0***REMOVED***5fcb6fab, 0***REMOVED***3ad6faec), new u64(0***REMOVED***6c44198c, 0***REMOVED***4a475817)
];

function crypto_hashblocks(***REMOVED***, m, n) {
  var z = [], b = [], a = [], w = [], t, i, j;

  for (i = 0; i < 8; i++) z[i] = a[i] = dl64(***REMOVED***, 8*i);

  var pos = 0;
  while (n >= 128) {
    for (i = 0; i < 16; i++) w[i] = dl64(m, 8*i+pos);
    for (i = 0; i < 80; i++) {
      for (j = 0; j < 8; j++) b[j] = a[j];
      t = add64(a[7], Sigma1(a[4]), Ch(a[4], a[5], a[6]), K[i], w[i%16]);
      b[7] = add64(t, Sigma0(a[0]), Maj(a[0], a[1], a[2]));
      b[3] = add64(b[3], t);
      for (j = 0; j < 8; j++) a[(j+1)%8] = b[j];
      if (i%16 === 15) {
        for (j = 0; j < 16; j++) {
          w[j] = add64(w[j], w[(j+9)%16], sigma0(w[(j+1)%16]), sigma1(w[(j+14)%16]));
        }
      }
    }

    for (i = 0; i < 8; i++) {
      a[i] = add64(a[i], z[i]);
      z[i] = a[i];
    }

    pos += 128;
    n -= 128;
  }

  for (i = 0; i < 8; i++) ts64(***REMOVED***, 8*i, z[i]);
  return n;
}

var iv = new Uint8Array([
  0***REMOVED***6a,0***REMOVED***09,0***REMOVED***e6,0***REMOVED***67,0***REMOVED***f3,0***REMOVED***bc,0***REMOVED***c9,0***REMOVED***08,
  0***REMOVED***bb,0***REMOVED***67,0***REMOVED***ae,0***REMOVED***85,0***REMOVED***84,0***REMOVED***ca,0***REMOVED***a7,0***REMOVED***3b,
  0***REMOVED***3c,0***REMOVED***6e,0***REMOVED***f3,0***REMOVED***72,0***REMOVED***fe,0***REMOVED***94,0***REMOVED***f8,0***REMOVED***2b,
  0***REMOVED***a5,0***REMOVED***4f,0***REMOVED***f5,0***REMOVED***3a,0***REMOVED***5f,0***REMOVED***1d,0***REMOVED***36,0***REMOVED***f1,
  0***REMOVED***51,0***REMOVED***0e,0***REMOVED***52,0***REMOVED***7f,0***REMOVED***ad,0***REMOVED***e6,0***REMOVED***82,0***REMOVED***d1,
  0***REMOVED***9b,0***REMOVED***05,0***REMOVED***68,0***REMOVED***8c,0***REMOVED***2b,0***REMOVED***3e,0***REMOVED***6c,0***REMOVED***1f,
  0***REMOVED***1f,0***REMOVED***83,0***REMOVED***d9,0***REMOVED***ab,0***REMOVED***fb,0***REMOVED***41,0***REMOVED***bd,0***REMOVED***6b,
  0***REMOVED***5b,0***REMOVED***e0,0***REMOVED***cd,0***REMOVED***19,0***REMOVED***13,0***REMOVED***7e,0***REMOVED***21,0***REMOVED***79
]);

function crypto_hash(out, m, n) {
  var h = new Uint8Array(64), ***REMOVED*** = new Uint8Array(256);
  var i, b = n;

  for (i = 0; i < 64; i++) h[i] = iv[i];

  crypto_hashblocks(h, m, n);
  n %= 128;

  for (i = 0; i < 256; i++) ***REMOVED***[i] = 0;
  for (i = 0; i < n; i++) ***REMOVED***[i] = m[b-n+i];
  ***REMOVED***[n] = 128;

  n = 256-128*(n<112?1:0);
  ***REMOVED***[n-9] = 0;
  ts64(***REMOVED***, n-8, new u64((b / 0***REMOVED***20000000) | 0, b << 3));
  crypto_hashblocks(h, ***REMOVED***, n);

  for (i = 0; i < 64; i++) out[i] = h[i];

  return 0;
}

function add(p, q) {
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf(),
      g = gf(), h = gf(), t = gf();

  Z(a, p[1], p[0]);
  Z(t, q[1], q[0]);
  M(a, a, t);
  A(b, p[0], p[1]);
  A(t, q[0], q[1]);
  M(b, b, t);
  M(c, p[3], q[3]);
  M(c, c, D2);
  M(d, p[2], q[2]);
  A(d, d, d);
  Z(e, b, a);
  Z(f, d, c);
  A(g, d, c);
  A(h, b, a);

  M(p[0], e, f);
  M(p[1], h, g);
  M(p[2], g, f);
  M(p[3], e, h);
}

function cswap(p, q, b) {
  var i;
  for (i = 0; i < 4; i++) {
    sel25519(p[i], q[i], b);
  }
}

function pack(r, p) {
  var t***REMOVED*** = gf(), ty = gf(), zi = gf();
  inv25519(zi, p[2]);
  M(t***REMOVED***, p[0], zi);
  M(ty, p[1], zi);
  pack25519(r, ty);
  r[31] ^= par25519(t***REMOVED***) << 7;
}

function scalarmult(p, q, s) {
  var b, i;
  set25519(p[0], gf0);
  set25519(p[1], gf1);
  set25519(p[2], gf1);
  set25519(p[3], gf0);
  for (i = 255; i >= 0; --i) {
    b = (s[(i/8)|0] >> (i&7)) & 1;
    cswap(p, q, b);
    add(q, p);
    add(p, p);
    cswap(p, q, b);
  }
}

function scalarbase(p, s) {
  var q = [gf(), gf(), gf(), gf()];
  set25519(q[0], X);
  set25519(q[1], Y);
  set25519(q[2], gf1);
  M(q[3], X, Y);
  scalarmult(p, q, s);
}

function crypto_sign_keypair(pk, sk, seeded) {
  var d = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()];
  var i;

  if (!seeded) randombytes(sk, 32);
  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  scalarbase(p, d);
  pack(pk, p);

  for (i = 0; i < 32; i++) sk[i+32] = pk[i];
  return 0;
}

var L = new Float64Array([0***REMOVED***ed, 0***REMOVED***d3, 0***REMOVED***f5, 0***REMOVED***5c, 0***REMOVED***1a, 0***REMOVED***63, 0***REMOVED***12, 0***REMOVED***58, 0***REMOVED***d6, 0***REMOVED***9c, 0***REMOVED***f7, 0***REMOVED***a2, 0***REMOVED***de, 0***REMOVED***f9, 0***REMOVED***de, 0***REMOVED***14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0***REMOVED***10]);

function modL(r, ***REMOVED***) {
  var carry, i, j, k;
  for (i = 63; i >= 32; --i) {
    carry = 0;
    for (j = i - 32, k = i - 12; j < k; ++j) {
      ***REMOVED***[j] += carry - 16 * ***REMOVED***[i] * L[j - (i - 32)];
      carry = (***REMOVED***[j] + 128) >> 8;
      ***REMOVED***[j] -= carry * 256;
    }
    ***REMOVED***[j] += carry;
    ***REMOVED***[i] = 0;
  }
  carry = 0;
  for (j = 0; j < 32; j++) {
    ***REMOVED***[j] += carry - (***REMOVED***[31] >> 4) * L[j];
    carry = ***REMOVED***[j] >> 8;
    ***REMOVED***[j] &= 255;
  }
  for (j = 0; j < 32; j++) ***REMOVED***[j] -= carry * L[j];
  for (i = 0; i < 32; i++) {
    ***REMOVED***[i+1] += ***REMOVED***[i] >> 8;
    r[i] = ***REMOVED***[i] & 255;
  }
}

function reduce(r) {
  var ***REMOVED*** = new Float64Array(64), i;
  for (i = 0; i < 64; i++) ***REMOVED***[i] = r[i];
  for (i = 0; i < 64; i++) r[i] = 0;
  modL(r, ***REMOVED***);
}

// Note: difference from C - smlen returned, not passed as argument.
function crypto_sign(sm, m, n, sk) {
  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
  var i, j, ***REMOVED*** = new Float64Array(64);
  var p = [gf(), gf(), gf(), gf()];

  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  var smlen = n + 64;
  for (i = 0; i < n; i++) sm[64 + i] = m[i];
  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

  crypto_hash(r, sm.subarray(32), n+32);
  reduce(r);
  scalarbase(p, r);
  pack(sm, p);

  for (i = 32; i < 64; i++) sm[i] = sk[i];
  crypto_hash(h, sm, n + 64);
  reduce(h);

  for (i = 0; i < 64; i++) ***REMOVED***[i] = 0;
  for (i = 0; i < 32; i++) ***REMOVED***[i] = r[i];
  for (i = 0; i < 32; i++) {
    for (j = 0; j < 32; j++) {
      ***REMOVED***[i+j] += h[i] * d[j];
    }
  }

  modL(sm.subarray(32), ***REMOVED***);
  return smlen;
}

function unpackneg(r, p) {
  var t = gf(), chk = gf(), num = gf(),
      den = gf(), den2 = gf(), den4 = gf(),
      den6 = gf();

  set25519(r[2], gf1);
  unpack25519(r[1], p);
  S(num, r[1]);
  M(den, num, D);
  Z(num, num, r[2]);
  A(den, r[2], den);

  S(den2, den);
  S(den4, den2);
  M(den6, den4, den2);
  M(t, den6, num);
  M(t, t, den);

  pow2523(t, t);
  M(t, t, num);
  M(t, t, den);
  M(t, t, den);
  M(r[0], t, den);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) M(r[0], r[0], I);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) return -1;

  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

  M(r[3], r[0], r[1]);
  return 0;
}

function crypto_sign_open(m, sm, n, pk) {
  var i, mlen;
  var t = new Uint8Array(32), h = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()],
      q = [gf(), gf(), gf(), gf()];

  mlen = -1;
  if (n < 64) return -1;

  if (unpackneg(q, pk)) return -1;

  for (i = 0; i < n; i++) m[i] = sm[i];
  for (i = 0; i < 32; i++) m[i+32] = pk[i];
  crypto_hash(h, m, n);
  reduce(h);
  scalarmult(p, q, h);

  scalarbase(q, sm.subarray(32));
  add(p, q);
  pack(t, p);

  n -= 64;
  if (crypto_verify_32(sm, 0, t, 0)) {
    for (i = 0; i < n; i++) m[i] = 0;
    return -1;
  }

  for (i = 0; i < n; i++) m[i] = sm[i + 64];
  mlen = n;
  return mlen;
}

var crypto_secretbo***REMOVED***_KEYBYTES = 32,
    crypto_secretbo***REMOVED***_NONCEBYTES = 24,
    crypto_secretbo***REMOVED***_ZEROBYTES = 32,
    crypto_secretbo***REMOVED***_BOXZEROBYTES = 16,
    crypto_scalarmult_BYTES = 32,
    crypto_scalarmult_SCALARBYTES = 32,
    crypto_bo***REMOVED***_PUBLICKEYBYTES = 32,
    crypto_bo***REMOVED***_SECRETKEYBYTES = 32,
    crypto_bo***REMOVED***_BEFORENMBYTES = 32,
    crypto_bo***REMOVED***_NONCEBYTES = crypto_secretbo***REMOVED***_NONCEBYTES,
    crypto_bo***REMOVED***_ZEROBYTES = crypto_secretbo***REMOVED***_ZEROBYTES,
    crypto_bo***REMOVED***_BOXZEROBYTES = crypto_secretbo***REMOVED***_BOXZEROBYTES,
    crypto_sign_BYTES = 64,
    crypto_sign_PUBLICKEYBYTES = 32,
    crypto_sign_SECRETKEYBYTES = 64,
    crypto_sign_SEEDBYTES = 32,
    crypto_hash_BYTES = 64;

nacl.lowlevel = {
  crypto_core_hsalsa20: crypto_core_hsalsa20,
  crypto_stream_***REMOVED***or: crypto_stream_***REMOVED***or,
  crypto_stream: crypto_stream,
  crypto_stream_salsa20_***REMOVED***or: crypto_stream_salsa20_***REMOVED***or,
  crypto_stream_salsa20: crypto_stream_salsa20,
  crypto_onetimeauth: crypto_onetimeauth,
  crypto_onetimeauth_verify: crypto_onetimeauth_verify,
  crypto_verify_16: crypto_verify_16,
  crypto_verify_32: crypto_verify_32,
  crypto_secretbo***REMOVED***: crypto_secretbo***REMOVED***,
  crypto_secretbo***REMOVED***_open: crypto_secretbo***REMOVED***_open,
  crypto_scalarmult: crypto_scalarmult,
  crypto_scalarmult_base: crypto_scalarmult_base,
  crypto_bo***REMOVED***_beforenm: crypto_bo***REMOVED***_beforenm,
  crypto_bo***REMOVED***_afternm: crypto_bo***REMOVED***_afternm,
  crypto_bo***REMOVED***: crypto_bo***REMOVED***,
  crypto_bo***REMOVED***_open: crypto_bo***REMOVED***_open,
  crypto_bo***REMOVED***_keypair: crypto_bo***REMOVED***_keypair,
  crypto_hash: crypto_hash,
  crypto_sign: crypto_sign,
  crypto_sign_keypair: crypto_sign_keypair,
  crypto_sign_open: crypto_sign_open,

  crypto_secretbo***REMOVED***_KEYBYTES: crypto_secretbo***REMOVED***_KEYBYTES,
  crypto_secretbo***REMOVED***_NONCEBYTES: crypto_secretbo***REMOVED***_NONCEBYTES,
  crypto_secretbo***REMOVED***_ZEROBYTES: crypto_secretbo***REMOVED***_ZEROBYTES,
  crypto_secretbo***REMOVED***_BOXZEROBYTES: crypto_secretbo***REMOVED***_BOXZEROBYTES,
  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
  crypto_bo***REMOVED***_PUBLICKEYBYTES: crypto_bo***REMOVED***_PUBLICKEYBYTES,
  crypto_bo***REMOVED***_SECRETKEYBYTES: crypto_bo***REMOVED***_SECRETKEYBYTES,
  crypto_bo***REMOVED***_BEFORENMBYTES: crypto_bo***REMOVED***_BEFORENMBYTES,
  crypto_bo***REMOVED***_NONCEBYTES: crypto_bo***REMOVED***_NONCEBYTES,
  crypto_bo***REMOVED***_ZEROBYTES: crypto_bo***REMOVED***_ZEROBYTES,
  crypto_bo***REMOVED***_BOXZEROBYTES: crypto_bo***REMOVED***_BOXZEROBYTES,
  crypto_sign_BYTES: crypto_sign_BYTES,
  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
  crypto_hash_BYTES: crypto_hash_BYTES
};

/* High-level API */

function checkLengths(k, n) {
  if (k.length !== crypto_secretbo***REMOVED***_KEYBYTES) throw new Error('bad key size');
  if (n.length !== crypto_secretbo***REMOVED***_NONCEBYTES) throw new Error('bad nonce size');
}

function checkBo***REMOVED***Lengths(pk, sk) {
  if (pk.length !== crypto_bo***REMOVED***_PUBLICKEYBYTES) throw new Error('bad public key size');
  if (sk.length !== crypto_bo***REMOVED***_SECRETKEYBYTES) throw new Error('bad secret key size');
}

function checkArrayTypes() {
  var t, i;
  for (i = 0; i < arguments.length; i++) {
     if ((t = Object.prototype.toString.call(arguments[i])) !== '[object Uint8Array]')
       throw new TypeError('une***REMOVED***pected type ' + t + ', use Uint8Array');
  }
}

function cleanup(arr) {
  for (var i = 0; i < arr.length; i++) arr[i] = 0;
}

// TODO: Completely remove this in v0.15.
if (!nacl.util) {
  nacl.util = {};
  nacl.util.decodeUTF8 = nacl.util.encodeUTF8 = nacl.util.encodeBase64 = nacl.util.decodeBase64 = function() {
    throw new Error('nacl.util moved into separate package: https://github.com/dchest/tweetnacl-util-js');
  };
}

nacl.randomBytes = function(n) {
  var b = new Uint8Array(n);
  randombytes(b, n);
  return b;
};

nacl.secretbo***REMOVED*** = function(msg, nonce, key) {
  checkArrayTypes(msg, nonce, key);
  checkLengths(key, nonce);
  var m = new Uint8Array(crypto_secretbo***REMOVED***_ZEROBYTES + msg.length);
  var c = new Uint8Array(m.length);
  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbo***REMOVED***_ZEROBYTES] = msg[i];
  crypto_secretbo***REMOVED***(c, m, m.length, nonce, key);
  return c.subarray(crypto_secretbo***REMOVED***_BOXZEROBYTES);
};

nacl.secretbo***REMOVED***.open = function(bo***REMOVED***, nonce, key) {
  checkArrayTypes(bo***REMOVED***, nonce, key);
  checkLengths(key, nonce);
  var c = new Uint8Array(crypto_secretbo***REMOVED***_BOXZEROBYTES + bo***REMOVED***.length);
  var m = new Uint8Array(c.length);
  for (var i = 0; i < bo***REMOVED***.length; i++) c[i+crypto_secretbo***REMOVED***_BOXZEROBYTES] = bo***REMOVED***[i];
  if (c.length < 32) return false;
  if (crypto_secretbo***REMOVED***_open(m, c, c.length, nonce, key) !== 0) return false;
  return m.subarray(crypto_secretbo***REMOVED***_ZEROBYTES);
};

nacl.secretbo***REMOVED***.keyLength = crypto_secretbo***REMOVED***_KEYBYTES;
nacl.secretbo***REMOVED***.nonceLength = crypto_secretbo***REMOVED***_NONCEBYTES;
nacl.secretbo***REMOVED***.overheadLength = crypto_secretbo***REMOVED***_BOXZEROBYTES;

nacl.scalarMult = function(n, p) {
  checkArrayTypes(n, p);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult(q, n, p);
  return q;
};

nacl.scalarMult.base = function(n) {
  checkArrayTypes(n);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult_base(q, n);
  return q;
};

nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

nacl.bo***REMOVED*** = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.bo***REMOVED***.before(publicKey, secretKey);
  return nacl.secretbo***REMOVED***(msg, nonce, k);
};

nacl.bo***REMOVED***.before = function(publicKey, secretKey) {
  checkArrayTypes(publicKey, secretKey);
  checkBo***REMOVED***Lengths(publicKey, secretKey);
  var k = new Uint8Array(crypto_bo***REMOVED***_BEFORENMBYTES);
  crypto_bo***REMOVED***_beforenm(k, publicKey, secretKey);
  return k;
};

nacl.bo***REMOVED***.after = nacl.secretbo***REMOVED***;

nacl.bo***REMOVED***.open = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.bo***REMOVED***.before(publicKey, secretKey);
  return nacl.secretbo***REMOVED***.open(msg, nonce, k);
};

nacl.bo***REMOVED***.open.after = nacl.secretbo***REMOVED***.open;

nacl.bo***REMOVED***.keyPair = function() {
  var pk = new Uint8Array(crypto_bo***REMOVED***_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_bo***REMOVED***_SECRETKEYBYTES);
  crypto_bo***REMOVED***_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.bo***REMOVED***.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_bo***REMOVED***_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_bo***REMOVED***_PUBLICKEYBYTES);
  crypto_scalarmult_base(pk, secretKey);
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.bo***REMOVED***.publicKeyLength = crypto_bo***REMOVED***_PUBLICKEYBYTES;
nacl.bo***REMOVED***.secretKeyLength = crypto_bo***REMOVED***_SECRETKEYBYTES;
nacl.bo***REMOVED***.sharedKeyLength = crypto_bo***REMOVED***_BEFORENMBYTES;
nacl.bo***REMOVED***.nonceLength = crypto_bo***REMOVED***_NONCEBYTES;
nacl.bo***REMOVED***.overheadLength = nacl.secretbo***REMOVED***.overheadLength;

nacl.sign = function(msg, secretKey) {
  checkArrayTypes(msg, secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
  crypto_sign(signedMsg, msg, msg.length, secretKey);
  return signedMsg;
};

nacl.sign.open = function(signedMsg, publicKey) {
  if (arguments.length !== 2)
    throw new Error('nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?');
  checkArrayTypes(signedMsg, publicKey);
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var tmp = new Uint8Array(signedMsg.length);
  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
  if (mlen < 0) return null;
  var m = new Uint8Array(mlen);
  for (var i = 0; i < m.length; i++) m[i] = tmp[i];
  return m;
};

nacl.sign.detached = function(msg, secretKey) {
  var signedMsg = nacl.sign(msg, secretKey);
  var sig = new Uint8Array(crypto_sign_BYTES);
  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
  return sig;
};

nacl.sign.detached.verify = function(msg, sig, publicKey) {
  checkArrayTypes(msg, sig, publicKey);
  if (sig.length !== crypto_sign_BYTES)
    throw new Error('bad signature size');
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
  var m = new Uint8Array(crypto_sign_BYTES + msg.length);
  var i;
  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
};

nacl.sign.keyPair = function() {
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  crypto_sign_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.sign.keyPair.fromSeed = function(seed) {
  checkArrayTypes(seed);
  if (seed.length !== crypto_sign_SEEDBYTES)
    throw new Error('bad seed size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  for (var i = 0; i < 32; i++) sk[i] = seed[i];
  crypto_sign_keypair(pk, sk, true);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
nacl.sign.seedLength = crypto_sign_SEEDBYTES;
nacl.sign.signatureLength = crypto_sign_BYTES;

nacl.hash = function(msg) {
  checkArrayTypes(msg);
  var h = new Uint8Array(crypto_hash_BYTES);
  crypto_hash(h, msg, msg.length);
  return h;
};

nacl.hash.hashLength = crypto_hash_BYTES;

nacl.verify = function(***REMOVED***, y) {
  checkArrayTypes(***REMOVED***, y);
  // Zero length arguments are considered not equal.
  if (***REMOVED***.length === 0 || y.length === 0) return false;
  if (***REMOVED***.length !== y.length) return false;
  return (vn(***REMOVED***, 0, y, 0, ***REMOVED***.length) === 0) ? true : false;
};

nacl.setPRNG = function(fn) {
  randombytes = fn;
};

(function() {
  // Initialize PRNG if environment provides CSPRNG.
  // If not, methods calling randombytes will throw.
  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
  if (crypto && crypto.getRandomValues) {
    // Browsers.
    var QUOTA = 65536;
    nacl.setPRNG(function(***REMOVED***, n) {
      var i, v = new Uint8Array(n);
      for (i = 0; i < n; i += QUOTA) {
        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
      }
      for (i = 0; i < n; i++) ***REMOVED***[i] = v[i];
      cleanup(v);
    });
  } else if (typeof require !== 'undefined') {
    // Node.js.
    crypto = require('crypto');
    if (crypto && crypto.randomBytes) {
      nacl.setPRNG(function(***REMOVED***, n) {
        var i, v = crypto.randomBytes(n);
        for (i = 0; i < n; i++) ***REMOVED***[i] = v[i];
        cleanup(v);
      });
    }
  }
})();

})(typeof module !== 'undefined' && module.e***REMOVED***ports ? module.e***REMOVED***ports : (self.nacl = self.nacl || {}));
