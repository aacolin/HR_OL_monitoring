// jscs:disable requireUseStrict

var test = require('tape');

var functionBind = require('../implementation');
var getCurrentConte***REMOVED***t = function () { return this; };

test('functionBind is a function', function (t) {
    t.equal(typeof functionBind, 'function');
    t.end();
});

test('non-functions', function (t) {
    var nonFunctions = [true, false, [], {}, 42, 'foo', NaN, /a/g];
    t.plan(nonFunctions.length);
    for (var i = 0; i < nonFunctions.length; ++i) {
        try { functionBind.call(nonFunctions[i]); } catch (e***REMOVED***) {
            t.ok(e***REMOVED*** instanceof TypeError, 'throws when given ' + String(nonFunctions[i]));
        }
    }
    t.end();
});

test('without a conte***REMOVED***t', function (t) {
    t.test('binds properly', function (st) {
        var args, conte***REMOVED***t;
        var namespace = {
            func: functionBind.call(function () {
                args = Array.prototype.slice.call(arguments);
                conte***REMOVED***t = this;
            })
        };
        namespace.func(1, 2, 3);
        st.deepEqual(args, [1, 2, 3]);
        st.equal(conte***REMOVED***t, getCurrentConte***REMOVED***t.call());
        st.end();
    });

    t.test('binds properly, and still supplies bound arguments', function (st) {
        var args, conte***REMOVED***t;
        var namespace = {
            func: functionBind.call(function () {
                args = Array.prototype.slice.call(arguments);
                conte***REMOVED***t = this;
            }, undefined, 1, 2, 3)
        };
        namespace.func(4, 5, 6);
        st.deepEqual(args, [1, 2, 3, 4, 5, 6]);
        st.equal(conte***REMOVED***t, getCurrentConte***REMOVED***t.call());
        st.end();
    });

    t.test('returns properly', function (st) {
        var args;
        var namespace = {
            func: functionBind.call(function () {
                args = Array.prototype.slice.call(arguments);
                return this;
            }, null)
        };
        var conte***REMOVED***t = namespace.func(1, 2, 3);
        st.equal(conte***REMOVED***t, getCurrentConte***REMOVED***t.call(), 'returned conte***REMOVED***t is namespaced conte***REMOVED***t');
        st.deepEqual(args, [1, 2, 3], 'passed arguments are correct');
        st.end();
    });

    t.test('returns properly with bound arguments', function (st) {
        var args;
        var namespace = {
            func: functionBind.call(function () {
                args = Array.prototype.slice.call(arguments);
                return this;
            }, null, 1, 2, 3)
        };
        var conte***REMOVED***t = namespace.func(4, 5, 6);
        st.equal(conte***REMOVED***t, getCurrentConte***REMOVED***t.call(), 'returned conte***REMOVED***t is namespaced conte***REMOVED***t');
        st.deepEqual(args, [1, 2, 3, 4, 5, 6], 'passed arguments are correct');
        st.end();
    });

    t.test('called as a constructor', function (st) {
        var thunkify = function (value) {
            return function () { return value; };
        };
        st.test('returns object value', function (sst) {
            var e***REMOVED***pectedReturnValue = [1, 2, 3];
            var Constructor = functionBind.call(thunkify(e***REMOVED***pectedReturnValue), null);
            var result = new Constructor();
            sst.equal(result, e***REMOVED***pectedReturnValue);
            sst.end();
        });

        st.test('does not return primitive value', function (sst) {
            var Constructor = functionBind.call(thunkify(42), null);
            var result = new Constructor();
            sst.notEqual(result, 42);
            sst.end();
        });

        st.test('object from bound constructor is instance of original and bound constructor', function (sst) {
            var A = function (***REMOVED***) {
                this.name = ***REMOVED*** || 'A';
            };
            var B = functionBind.call(A, null, 'B');

            var result = new B();
            sst.ok(result instanceof B, 'result is instance of bound constructor');
            sst.ok(result instanceof A, 'result is instance of original constructor');
            sst.end();
        });

        st.end();
    });

    t.end();
});

test('with a conte***REMOVED***t', function (t) {
    t.test('with no bound arguments', function (st) {
        var args, conte***REMOVED***t;
        var boundConte***REMOVED***t = {};
        var namespace = {
            func: functionBind.call(function () {
                args = Array.prototype.slice.call(arguments);
                conte***REMOVED***t = this;
            }, boundConte***REMOVED***t)
        };
        namespace.func(1, 2, 3);
        st.equal(conte***REMOVED***t, boundConte***REMOVED***t, 'binds a conte***REMOVED***t properly');
        st.deepEqual(args, [1, 2, 3], 'supplies passed arguments');
        st.end();
    });

    t.test('with bound arguments', function (st) {
        var args, conte***REMOVED***t;
        var boundConte***REMOVED***t = {};
        var namespace = {
            func: functionBind.call(function () {
                args = Array.prototype.slice.call(arguments);
                conte***REMOVED***t = this;
            }, boundConte***REMOVED***t, 1, 2, 3)
        };
        namespace.func(4, 5, 6);
        st.equal(conte***REMOVED***t, boundConte***REMOVED***t, 'binds a conte***REMOVED***t properly');
        st.deepEqual(args, [1, 2, 3, 4, 5, 6], 'supplies bound and passed arguments');
        st.end();
    });

    t.test('returns properly', function (st) {
        var boundConte***REMOVED***t = {};
        var args;
        var namespace = {
            func: functionBind.call(function () {
                args = Array.prototype.slice.call(arguments);
                return this;
            }, boundConte***REMOVED***t)
        };
        var conte***REMOVED***t = namespace.func(1, 2, 3);
        st.equal(conte***REMOVED***t, boundConte***REMOVED***t, 'returned conte***REMOVED***t is bound conte***REMOVED***t');
        st.notEqual(conte***REMOVED***t, getCurrentConte***REMOVED***t.call(), 'returned conte***REMOVED***t is not le***REMOVED***ical conte***REMOVED***t');
        st.deepEqual(args, [1, 2, 3], 'passed arguments are correct');
        st.end();
    });

    t.test('returns properly with bound arguments', function (st) {
        var boundConte***REMOVED***t = {};
        var args;
        var namespace = {
            func: functionBind.call(function () {
                args = Array.prototype.slice.call(arguments);
                return this;
            }, boundConte***REMOVED***t, 1, 2, 3)
        };
        var conte***REMOVED***t = namespace.func(4, 5, 6);
        st.equal(conte***REMOVED***t, boundConte***REMOVED***t, 'returned conte***REMOVED***t is bound conte***REMOVED***t');
        st.notEqual(conte***REMOVED***t, getCurrentConte***REMOVED***t.call(), 'returned conte***REMOVED***t is not le***REMOVED***ical conte***REMOVED***t');
        st.deepEqual(args, [1, 2, 3, 4, 5, 6], 'passed arguments are correct');
        st.end();
    });

    t.test('passes the correct arguments when called as a constructor', function (st) {
        var e***REMOVED***pected = { name: 'Correct' };
        var namespace = {
            Func: functionBind.call(function (arg) {
                return arg;
            }, { name: 'Incorrect' })
        };
        var returned = new namespace.Func(e***REMOVED***pected);
        st.equal(returned, e***REMOVED***pected, 'returns the right arg when called as a constructor');
        st.end();
    });

    t.test('has the new instance\'s conte***REMOVED***t when called as a constructor', function (st) {
        var actualConte***REMOVED***t;
        var e***REMOVED***pectedConte***REMOVED***t = { foo: 'bar' };
        var namespace = {
            Func: functionBind.call(function () {
                actualConte***REMOVED***t = this;
            }, e***REMOVED***pectedConte***REMOVED***t)
        };
        var result = new namespace.Func();
        st.equal(result instanceof namespace.Func, true);
        st.notEqual(actualConte***REMOVED***t, e***REMOVED***pectedConte***REMOVED***t);
        st.end();
    });

    t.end();
});

test('bound function length', function (t) {
    t.test('sets a correct length without thisArg', function (st) {
        var subject = functionBind.call(function (a, b, c) { return a + b + c; });
        st.equal(subject.length, 3);
        st.equal(subject(1, 2, 3), 6);
        st.end();
    });

    t.test('sets a correct length with thisArg', function (st) {
        var subject = functionBind.call(function (a, b, c) { return a + b + c; }, {});
        st.equal(subject.length, 3);
        st.equal(subject(1, 2, 3), 6);
        st.end();
    });

    t.test('sets a correct length without thisArg and first argument', function (st) {
        var subject = functionBind.call(function (a, b, c) { return a + b + c; }, undefined, 1);
        st.equal(subject.length, 2);
        st.equal(subject(2, 3), 6);
        st.end();
    });

    t.test('sets a correct length with thisArg and first argument', function (st) {
        var subject = functionBind.call(function (a, b, c) { return a + b + c; }, {}, 1);
        st.equal(subject.length, 2);
        st.equal(subject(2, 3), 6);
        st.end();
    });

    t.test('sets a correct length without thisArg and too many arguments', function (st) {
        var subject = functionBind.call(function (a, b, c) { return a + b + c; }, undefined, 1, 2, 3, 4);
        st.equal(subject.length, 0);
        st.equal(subject(), 6);
        st.end();
    });

    t.test('sets a correct length with thisArg and too many arguments', function (st) {
        var subject = functionBind.call(function (a, b, c) { return a + b + c; }, {}, 1, 2, 3, 4);
        st.equal(subject.length, 0);
        st.equal(subject(), 6);
        st.end();
    });
});
