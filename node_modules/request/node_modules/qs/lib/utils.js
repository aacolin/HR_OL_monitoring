'use strict';

var has = Object.prototype.hasOwnProperty;

var he***REMOVED***Table = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    var obj;

    while (queue.length) {
        var item = queue.pop();
        obj = item.obj[item.prop];

        if (Array.isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }

    return obj;
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (Array.isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (Array.isArray(target) && !Array.isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (Array.isArray(target) && Array.isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str) {
    try {
        return decodeURIComponent(str.replace(/\+/g, ' '));
    } catch (e) {
        return str;
    }
};

var encode = function encode(str) {
    // This code was originally written by Brian White (mscde***REMOVED***) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = typeof str === 'string' ? str : String(str);

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0***REMOVED***2D // -
            || c === 0***REMOVED***2E // .
            || c === 0***REMOVED***5F // _
            || c === 0***REMOVED***7E // ~
            || (c >= 0***REMOVED***30 && c <= 0***REMOVED***39) // 0-9
            || (c >= 0***REMOVED***41 && c <= 0***REMOVED***5A) // a-z
            || (c >= 0***REMOVED***61 && c <= 0***REMOVED***7A) // A-Z
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0***REMOVED***80) {
            out = out + he***REMOVED***Table[c];
            continue;
        }

        if (c < 0***REMOVED***800) {
            out = out + (he***REMOVED***Table[0***REMOVED***C0 | (c >> 6)] + he***REMOVED***Table[0***REMOVED***80 | (c & 0***REMOVED***3F)]);
            continue;
        }

        if (c < 0***REMOVED***D800 || c >= 0***REMOVED***E000) {
            out = out + (he***REMOVED***Table[0***REMOVED***E0 | (c >> 12)] + he***REMOVED***Table[0***REMOVED***80 | ((c >> 6) & 0***REMOVED***3F)] + he***REMOVED***Table[0***REMOVED***80 | (c & 0***REMOVED***3F)]);
            continue;
        }

        i += 1;
        c = 0***REMOVED***10000 + (((c & 0***REMOVED***3FF) << 10) | (string.charCodeAt(i) & 0***REMOVED***3FF));
        /* eslint operator-linebreak: [2, "before"] */
        out += he***REMOVED***Table[0***REMOVED***F0 | (c >> 18)]
            + he***REMOVED***Table[0***REMOVED***80 | ((c >> 12) & 0***REMOVED***3F)]
            + he***REMOVED***Table[0***REMOVED***80 | ((c >> 6) & 0***REMOVED***3F)]
            + he***REMOVED***Table[0***REMOVED***80 | (c & 0***REMOVED***3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.inde***REMOVED***Of(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    return compactQueue(queue);
};

var isRegE***REMOVED***p = function isRegE***REMOVED***p(obj) {
    return Object.prototype.toString.call(obj) === '[object RegE***REMOVED***p]';
};

var isBuffer = function isBuffer(obj) {
    if (obj === null || typeof obj === 'undefined') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

module.e***REMOVED***ports = {
    arrayToObject: arrayToObject,
    assign: assign,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegE***REMOVED***p: isRegE***REMOVED***p,
    merge: merge
};
