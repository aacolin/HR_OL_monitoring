'use strict'

var url = require('url')
var tunnel = require('tunnel-agent')

var defaultPro***REMOVED***yHeaderWhiteList = [
  'accept',
  'accept-charset',
  'accept-encoding',
  'accept-language',
  'accept-ranges',
  'cache-control',
  'content-encoding',
  'content-language',
  'content-location',
  'content-md5',
  'content-range',
  'content-type',
  'connection',
  'date',
  'e***REMOVED***pect',
  'ma***REMOVED***-forwards',
  'pragma',
  'referer',
  'te',
  'user-agent',
  'via'
]

var defaultPro***REMOVED***yHeaderE***REMOVED***clusiveList = [
  'pro***REMOVED***y-authorization'
]

function constructPro***REMOVED***yHost (uriObject) {
  var port = uriObject.port
  var protocol = uriObject.protocol
  var pro***REMOVED***yHost = uriObject.hostname + ':'

  if (port) {
    pro***REMOVED***yHost += port
  } else if (protocol === 'https:') {
    pro***REMOVED***yHost += '443'
  } else {
    pro***REMOVED***yHost += '80'
  }

  return pro***REMOVED***yHost
}

function constructPro***REMOVED***yHeaderWhiteList (headers, pro***REMOVED***yHeaderWhiteList) {
  var whiteList = pro***REMOVED***yHeaderWhiteList
    .reduce(function (set, header) {
      set[header.toLowerCase()] = true
      return set
    }, {})

  return Object.keys(headers)
    .filter(function (header) {
      return whiteList[header.toLowerCase()]
    })
    .reduce(function (set, header) {
      set[header] = headers[header]
      return set
    }, {})
}

function constructTunnelOptions (request, pro***REMOVED***yHeaders) {
  var pro***REMOVED***y = request.pro***REMOVED***y

  var tunnelOptions = {
    pro***REMOVED***y: {
      host: pro***REMOVED***y.hostname,
      port: +pro***REMOVED***y.port,
      pro***REMOVED***yAuth: pro***REMOVED***y.auth,
      headers: pro***REMOVED***yHeaders
    },
    headers: request.headers,
    ca: request.ca,
    cert: request.cert,
    key: request.key,
    passphrase: request.passphrase,
    pf***REMOVED***: request.pf***REMOVED***,
    ciphers: request.ciphers,
    rejectUnauthorized: request.rejectUnauthorized,
    secureOptions: request.secureOptions,
    secureProtocol: request.secureProtocol
  }

  return tunnelOptions
}

function constructTunnelFnName (uri, pro***REMOVED***y) {
  var uriProtocol = (uri.protocol === 'https:' ? 'https' : 'http')
  var pro***REMOVED***yProtocol = (pro***REMOVED***y.protocol === 'https:' ? 'Https' : 'Http')
  return [uriProtocol, pro***REMOVED***yProtocol].join('Over')
}

function getTunnelFn (request) {
  var uri = request.uri
  var pro***REMOVED***y = request.pro***REMOVED***y
  var tunnelFnName = constructTunnelFnName(uri, pro***REMOVED***y)
  return tunnel[tunnelFnName]
}

function Tunnel (request) {
  this.request = request
  this.pro***REMOVED***yHeaderWhiteList = defaultPro***REMOVED***yHeaderWhiteList
  this.pro***REMOVED***yHeaderE***REMOVED***clusiveList = []
  if (typeof request.tunnel !== 'undefined') {
    this.tunnelOverride = request.tunnel
  }
}

Tunnel.prototype.isEnabled = function () {
  var self = this
  var request = self.request
    // Tunnel HTTPS by default. Allow the user to override this setting.

  // If self.tunnelOverride is set (the user specified a value), use it.
  if (typeof self.tunnelOverride !== 'undefined') {
    return self.tunnelOverride
  }

  // If the destination is HTTPS, tunnel.
  if (request.uri.protocol === 'https:') {
    return true
  }

  // Otherwise, do not use tunnel.
  return false
}

Tunnel.prototype.setup = function (options) {
  var self = this
  var request = self.request

  options = options || {}

  if (typeof request.pro***REMOVED***y === 'string') {
    request.pro***REMOVED***y = url.parse(request.pro***REMOVED***y)
  }

  if (!request.pro***REMOVED***y || !request.tunnel) {
    return false
  }

  // Setup Pro***REMOVED***y Header E***REMOVED***clusive List and White List
  if (options.pro***REMOVED***yHeaderWhiteList) {
    self.pro***REMOVED***yHeaderWhiteList = options.pro***REMOVED***yHeaderWhiteList
  }
  if (options.pro***REMOVED***yHeaderE***REMOVED***clusiveList) {
    self.pro***REMOVED***yHeaderE***REMOVED***clusiveList = options.pro***REMOVED***yHeaderE***REMOVED***clusiveList
  }

  var pro***REMOVED***yHeaderE***REMOVED***clusiveList = self.pro***REMOVED***yHeaderE***REMOVED***clusiveList.concat(defaultPro***REMOVED***yHeaderE***REMOVED***clusiveList)
  var pro***REMOVED***yHeaderWhiteList = self.pro***REMOVED***yHeaderWhiteList.concat(pro***REMOVED***yHeaderE***REMOVED***clusiveList)

  // Setup Pro***REMOVED***y Headers and Pro***REMOVED***y Headers Host
  // Only send the Pro***REMOVED***y White Listed Header names
  var pro***REMOVED***yHeaders = constructPro***REMOVED***yHeaderWhiteList(request.headers, pro***REMOVED***yHeaderWhiteList)
  pro***REMOVED***yHeaders.host = constructPro***REMOVED***yHost(request.uri)

  pro***REMOVED***yHeaderE***REMOVED***clusiveList.forEach(request.removeHeader, request)

  // Set Agent from Tunnel Data
  var tunnelFn = getTunnelFn(request)
  var tunnelOptions = constructTunnelOptions(request, pro***REMOVED***yHeaders)
  request.agent = tunnelFn(tunnelOptions)

  return true
}

Tunnel.defaultPro***REMOVED***yHeaderWhiteList = defaultPro***REMOVED***yHeaderWhiteList
Tunnel.defaultPro***REMOVED***yHeaderE***REMOVED***clusiveList = defaultPro***REMOVED***yHeaderE***REMOVED***clusiveList
e***REMOVED***ports.Tunnel = Tunnel
