import type { Document } from './bson';
import { MongoRuntimeError, MongoTransactionError } from './error';
import type { CommandOperationOptions } from './operations/command';
import { ReadConcern, type ReadConcernLike } from './read_concern';
import { ReadPreference, type ReadPreferenceLike } from './read_preference';
import type { Server } from './sdam/server';
import { WriteConcern } from './write_concern';

/** @internal */
e***REMOVED***port const T***REMOVED***nState = Object.freeze({
  NO_TRANSACTION: 'NO_TRANSACTION',
  STARTING_TRANSACTION: 'STARTING_TRANSACTION',
  TRANSACTION_IN_PROGRESS: 'TRANSACTION_IN_PROGRESS',
  TRANSACTION_COMMITTED: 'TRANSACTION_COMMITTED',
  TRANSACTION_COMMITTED_EMPTY: 'TRANSACTION_COMMITTED_EMPTY',
  TRANSACTION_ABORTED: 'TRANSACTION_ABORTED'
} as const);

/** @internal */
e***REMOVED***port type T***REMOVED***nState = (typeof T***REMOVED***nState)[keyof typeof T***REMOVED***nState];

const stateMachine: { [state in T***REMOVED***nState]: T***REMOVED***nState[] } = {
  [T***REMOVED***nState.NO_TRANSACTION]: [T***REMOVED***nState.NO_TRANSACTION, T***REMOVED***nState.STARTING_TRANSACTION],
  [T***REMOVED***nState.STARTING_TRANSACTION]: [
    T***REMOVED***nState.TRANSACTION_IN_PROGRESS,
    T***REMOVED***nState.TRANSACTION_COMMITTED,
    T***REMOVED***nState.TRANSACTION_COMMITTED_EMPTY,
    T***REMOVED***nState.TRANSACTION_ABORTED
  ],
  [T***REMOVED***nState.TRANSACTION_IN_PROGRESS]: [
    T***REMOVED***nState.TRANSACTION_IN_PROGRESS,
    T***REMOVED***nState.TRANSACTION_COMMITTED,
    T***REMOVED***nState.TRANSACTION_ABORTED
  ],
  [T***REMOVED***nState.TRANSACTION_COMMITTED]: [
    T***REMOVED***nState.TRANSACTION_COMMITTED,
    T***REMOVED***nState.TRANSACTION_COMMITTED_EMPTY,
    T***REMOVED***nState.STARTING_TRANSACTION,
    T***REMOVED***nState.NO_TRANSACTION
  ],
  [T***REMOVED***nState.TRANSACTION_ABORTED]: [T***REMOVED***nState.STARTING_TRANSACTION, T***REMOVED***nState.NO_TRANSACTION],
  [T***REMOVED***nState.TRANSACTION_COMMITTED_EMPTY]: [
    T***REMOVED***nState.TRANSACTION_COMMITTED_EMPTY,
    T***REMOVED***nState.NO_TRANSACTION
  ]
};

const ACTIVE_STATES: Set<T***REMOVED***nState> = new Set([
  T***REMOVED***nState.STARTING_TRANSACTION,
  T***REMOVED***nState.TRANSACTION_IN_PROGRESS
]);

const COMMITTED_STATES: Set<T***REMOVED***nState> = new Set([
  T***REMOVED***nState.TRANSACTION_COMMITTED,
  T***REMOVED***nState.TRANSACTION_COMMITTED_EMPTY,
  T***REMOVED***nState.TRANSACTION_ABORTED
]);

/**
 * Configuration options for a transaction.
 * @public
 */
e***REMOVED***port interface TransactionOptions e***REMOVED***tends CommandOperationOptions {
  // TODO(NODE-3344): These options use the proper class forms of these settings, it should accept the basic enum values too
  /** A default read concern for commands in this transaction */
  readConcern?: ReadConcernLike;
  /** A default writeConcern for commands in this transaction */
  writeConcern?: WriteConcern;
  /** A default read preference for commands in this transaction */
  readPreference?: ReadPreferenceLike;
  /** Specifies the ma***REMOVED***imum amount of time to allow a commit action on a transaction to run in milliseconds */
  ma***REMOVED***CommitTimeMS?: number;
}

/**
 * @public
 * A class maintaining state related to a server transaction. Internal Only
 */
e***REMOVED***port class Transaction {
  /** @internal */
  state: T***REMOVED***nState;
  options: TransactionOptions;
  /** @internal */
  _pinnedServer?: Server;
  /** @internal */
  _recoveryToken?: Document;

  /** Create a transaction @internal */
  constructor(options?: TransactionOptions) {
    options = options ?? {};
    this.state = T***REMOVED***nState.NO_TRANSACTION;
    this.options = {};

    const writeConcern = WriteConcern.fromOptions(options);
    if (writeConcern) {
      if (writeConcern.w === 0) {
        throw new MongoTransactionError('Transactions do not support unacknowledged write concern');
      }

      this.options.writeConcern = writeConcern;
    }

    if (options.readConcern) {
      this.options.readConcern = ReadConcern.fromOptions(options);
    }

    if (options.readPreference) {
      this.options.readPreference = ReadPreference.fromOptions(options);
    }

    if (options.ma***REMOVED***CommitTimeMS) {
      this.options.ma***REMOVED***TimeMS = options.ma***REMOVED***CommitTimeMS;
    }

    // TODO: This isn't technically necessary
    this._pinnedServer = undefined;
    this._recoveryToken = undefined;
  }

  /** @internal */
  get server(): Server | undefined {
    return this._pinnedServer;
  }

  get recoveryToken(): Document | undefined {
    return this._recoveryToken;
  }

  get isPinned(): boolean {
    return !!this.server;
  }

  /** @returns Whether the transaction has started */
  get isStarting(): boolean {
    return this.state === T***REMOVED***nState.STARTING_TRANSACTION;
  }

  /**
   * @returns Whether this session is presently in a transaction
   */
  get isActive(): boolean {
    return ACTIVE_STATES.has(this.state);
  }

  get isCommitted(): boolean {
    return COMMITTED_STATES.has(this.state);
  }
  /**
   * Transition the transaction in the state machine
   * @internal
   * @param ne***REMOVED***tState - The new state to transition to
   */
  transition(ne***REMOVED***tState: T***REMOVED***nState): void {
    const ne***REMOVED***tStates = stateMachine[this.state];
    if (ne***REMOVED***tStates && ne***REMOVED***tStates.includes(ne***REMOVED***tState)) {
      this.state = ne***REMOVED***tState;
      if (
        this.state === T***REMOVED***nState.NO_TRANSACTION ||
        this.state === T***REMOVED***nState.STARTING_TRANSACTION ||
        this.state === T***REMOVED***nState.TRANSACTION_ABORTED
      ) {
        this.unpinServer();
      }
      return;
    }

    throw new MongoRuntimeError(
      `Attempted illegal state transition from [${this.state}] to [${ne***REMOVED***tState}]`
    );
  }

  /** @internal */
  pinServer(server: Server): void {
    if (this.isActive) {
      this._pinnedServer = server;
    }
  }

  /** @internal */
  unpinServer(): void {
    this._pinnedServer = undefined;
  }
}

e***REMOVED***port function isTransactionCommand(command: Document): boolean {
  return !!(command.commitTransaction || command.abortTransaction);
}
