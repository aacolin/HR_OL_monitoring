import * as fs from 'fs/promises';
import { type MongoCryptConte***REMOVED***t, type MongoCryptKMSRequest } from 'mongodb-client-encryption';
import * as net from 'net';
import * as tls from 'tls';

import {
  type BSONSerializeOptions,
  deserialize,
  type Document,
  pluckBSONSerializeOptions,
  serialize
} from '../bson';
import { type Pro***REMOVED***yOptions } from '../cmap/connection';
import { getSocks, type SocksLib } from '../deps';
import { type MongoClient, type MongoClientOptions } from '../mongo_client';
import { BufferPool, MongoDBCollectionNamespace, promiseWithResolvers } from '../utils';
import { autoSelectSocketOptions, type DataKey } from './client_encryption';
import { MongoCryptError } from './errors';
import { type MongocryptdManager } from './mongocryptd_manager';
import { type KMSProviders } from './providers';

let socks: SocksLib | null = null;
function loadSocks(): SocksLib {
  if (socks == null) {
    const socksImport = getSocks();
    if ('kModuleError' in socksImport) {
      throw socksImport.kModuleError;
    }
    socks = socksImport;
  }
  return socks;
}

// libmongocrypt states
const MONGOCRYPT_CTX_ERROR = 0;
const MONGOCRYPT_CTX_NEED_MONGO_COLLINFO = 1;
const MONGOCRYPT_CTX_NEED_MONGO_MARKINGS = 2;
const MONGOCRYPT_CTX_NEED_MONGO_KEYS = 3;
const MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS = 7;
const MONGOCRYPT_CTX_NEED_KMS = 4;
const MONGOCRYPT_CTX_READY = 5;
const MONGOCRYPT_CTX_DONE = 6;

const HTTPS_PORT = 443;

const stateToString = new Map([
  [MONGOCRYPT_CTX_ERROR, 'MONGOCRYPT_CTX_ERROR'],
  [MONGOCRYPT_CTX_NEED_MONGO_COLLINFO, 'MONGOCRYPT_CTX_NEED_MONGO_COLLINFO'],
  [MONGOCRYPT_CTX_NEED_MONGO_MARKINGS, 'MONGOCRYPT_CTX_NEED_MONGO_MARKINGS'],
  [MONGOCRYPT_CTX_NEED_MONGO_KEYS, 'MONGOCRYPT_CTX_NEED_MONGO_KEYS'],
  [MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS, 'MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS'],
  [MONGOCRYPT_CTX_NEED_KMS, 'MONGOCRYPT_CTX_NEED_KMS'],
  [MONGOCRYPT_CTX_READY, 'MONGOCRYPT_CTX_READY'],
  [MONGOCRYPT_CTX_DONE, 'MONGOCRYPT_CTX_DONE']
]);

const INSECURE_TLS_OPTIONS = [
  'tlsInsecure',
  'tlsAllowInvalidCertificates',
  'tlsAllowInvalidHostnames',

  // These options are disallowed by the spec, so we e***REMOVED***plicitly filter them out if provided, even
  // though the StateMachine does not declare support for these options.
  'tlsDisableOCSPEndpointCheck',
  'tlsDisableCertificateRevocationCheck'
];

/**
 * Helper function for logging. Enabled by setting the environment flag MONGODB_CRYPT_DEBUG.
 * @param msg - Anything you want to be logged.
 */
function debug(msg: unknown) {
  if (process.env.MONGODB_CRYPT_DEBUG) {
    // eslint-disable-ne***REMOVED***t-line no-console
    console.error(msg);
  }
}

declare module 'mongodb-client-encryption' {
  // the properties added to `MongoCryptConte***REMOVED***t` here are only used for the `StateMachine`'s
  // e***REMOVED***ecute method and are not part of the C++ bindings.
  interface MongoCryptConte***REMOVED***t {
    id: number;
    document: Document;
    ns: string;
  }
}

/**
 * @public
 *
 * TLS options to use when connecting. The spec specifically calls out which insecure
 * tls options are not allowed:
 *
 *  - tlsAllowInvalidCertificates
 *  - tlsAllowInvalidHostnames
 *  - tlsInsecure
 *
 * These options are not included in the type, and are ignored if provided.
 */
e***REMOVED***port type ClientEncryptionTlsOptions = Pick<
  MongoClientOptions,
  'tlsCAFile' | 'tlsCertificateKeyFile' | 'tlsCertificateKeyFilePassword'
>;

/** @public */
e***REMOVED***port type CSFLEKMSTlsOptions = {
  aws?: ClientEncryptionTlsOptions;
  gcp?: ClientEncryptionTlsOptions;
  kmip?: ClientEncryptionTlsOptions;
  local?: ClientEncryptionTlsOptions;
  azure?: ClientEncryptionTlsOptions;

  [key: string]: ClientEncryptionTlsOptions | undefined;
};

/**
 * @public
 *
 * Socket options to use for KMS requests.
 */
e***REMOVED***port type ClientEncryptionSocketOptions = Pick<
  MongoClientOptions,
  'autoSelectFamily' | 'autoSelectFamilyAttemptTimeout'
>;

/**
 * This is kind of a hack.  For `rewrapManyDataKey`, we have tests that
 * guarantee that when there are no matching keys, `rewrapManyDataKey` returns
 * nothing.  We also have tests for auto encryption that guarantee for `encrypt`
 * we return an error when there are no matching keys.  This error is generated in
 * subsequent iterations of the state machine.
 * Some apis (`encrypt`) throw if there are no filter matches and others (`rewrapManyDataKey`)
 * do not.  We set the result manually here, and let the state machine continue.  `libmongocrypt`
 * will inform us if we need to error by setting the state to `MONGOCRYPT_CTX_ERROR` but
 * otherwise we'll return `{ v: [] }`.
 */
let EMPTY_V;

/**
 * @internal
 *
 * An interface representing an object that can be passed to the `StateMachine.e***REMOVED***ecute` method.
 *
 * Not all properties are required for all operations.
 */
e***REMOVED***port interface StateMachineE***REMOVED***ecutable {
  _keyVaultNamespace: string;
  _keyVaultClient: MongoClient;
  askForKMSCredentials: () => Promise<KMSProviders>;

  /** only used for auto encryption */
  _metaDataClient?: MongoClient;
  /** only used for auto encryption */
  _mongocryptdClient?: MongoClient;
  /** only used for auto encryption */
  _mongocryptdManager?: MongocryptdManager;
}

e***REMOVED***port type StateMachineOptions = {
  /** socks5 pro***REMOVED***y options, if set. */
  pro***REMOVED***yOptions: Pro***REMOVED***yOptions;

  /** TLS options for KMS requests, if set. */
  tlsOptions: CSFLEKMSTlsOptions;

  /** Socket specific options we support. */
  socketOptions: ClientEncryptionSocketOptions;
} & Pick<BSONSerializeOptions, 'promoteLongs' | 'promoteValues'>;

/**
 * @internal
 * An internal class that e***REMOVED***ecutes across a MongoCryptConte***REMOVED***t until either
 * a finishing state or an error is reached. Do not instantiate directly.
 */
e***REMOVED***port class StateMachine {
  constructor(
    private options: StateMachineOptions,
    private bsonOptions = pluckBSONSerializeOptions(options)
  ) {}

  /**
   * E***REMOVED***ecutes the state machine according to the specification
   */
  async e***REMOVED***ecute(e***REMOVED***ecutor: StateMachineE***REMOVED***ecutable, conte***REMOVED***t: MongoCryptConte***REMOVED***t): Promise<Uint8Array> {
    const keyVaultNamespace = e***REMOVED***ecutor._keyVaultNamespace;
    const keyVaultClient = e***REMOVED***ecutor._keyVaultClient;
    const metaDataClient = e***REMOVED***ecutor._metaDataClient;
    const mongocryptdClient = e***REMOVED***ecutor._mongocryptdClient;
    const mongocryptdManager = e***REMOVED***ecutor._mongocryptdManager;
    let result: Uint8Array | null = null;

    while (conte***REMOVED***t.state !== MONGOCRYPT_CTX_DONE && conte***REMOVED***t.state !== MONGOCRYPT_CTX_ERROR) {
      debug(`[conte***REMOVED***t#${conte***REMOVED***t.id}] ${stateToString.get(conte***REMOVED***t.state) || conte***REMOVED***t.state}`);

      switch (conte***REMOVED***t.state) {
        case MONGOCRYPT_CTX_NEED_MONGO_COLLINFO: {
          const filter = deserialize(conte***REMOVED***t.ne***REMOVED***tMongoOperation());
          if (!metaDataClient) {
            throw new MongoCryptError(
              'unreachable state machine state: entered MONGOCRYPT_CTX_NEED_MONGO_COLLINFO but metadata client is undefined'
            );
          }
          const collInfo = await this.fetchCollectionInfo(metaDataClient, conte***REMOVED***t.ns, filter);

          if (collInfo) {
            conte***REMOVED***t.addMongoOperationResponse(collInfo);
          }

          conte***REMOVED***t.finishMongoOperation();
          break;
        }

        case MONGOCRYPT_CTX_NEED_MONGO_MARKINGS: {
          const command = conte***REMOVED***t.ne***REMOVED***tMongoOperation();
          if (!mongocryptdClient) {
            throw new MongoCryptError(
              'unreachable state machine state: entered MONGOCRYPT_CTX_NEED_MONGO_MARKINGS but mongocryptdClient is undefined'
            );
          }

          // When we are using the shared library, we don't have a mongocryptd manager.
          const markedCommand: Uint8Array = mongocryptdManager
            ? await mongocryptdManager.withRespawn(
                this.markCommand.bind(this, mongocryptdClient, conte***REMOVED***t.ns, command)
              )
            : await this.markCommand(mongocryptdClient, conte***REMOVED***t.ns, command);

          conte***REMOVED***t.addMongoOperationResponse(markedCommand);
          conte***REMOVED***t.finishMongoOperation();
          break;
        }

        case MONGOCRYPT_CTX_NEED_MONGO_KEYS: {
          const filter = conte***REMOVED***t.ne***REMOVED***tMongoOperation();
          const keys = await this.fetchKeys(keyVaultClient, keyVaultNamespace, filter);

          if (keys.length === 0) {
            // See docs on EMPTY_V
            result = EMPTY_V ??= serialize({ v: [] });
          }
          for await (const key of keys) {
            conte***REMOVED***t.addMongoOperationResponse(serialize(key));
          }

          conte***REMOVED***t.finishMongoOperation();

          break;
        }

        case MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS: {
          const kmsProviders = await e***REMOVED***ecutor.askForKMSCredentials();
          conte***REMOVED***t.provideKMSProviders(serialize(kmsProviders));
          break;
        }

        case MONGOCRYPT_CTX_NEED_KMS: {
          const requests = Array.from(this.requests(conte***REMOVED***t));
          await Promise.all(requests);

          conte***REMOVED***t.finishKMSRequests();
          break;
        }

        case MONGOCRYPT_CTX_READY: {
          const finalizedConte***REMOVED***t = conte***REMOVED***t.finalize();
          // @ts-e***REMOVED***pect-error finalize can change the state, check for error
          if (conte***REMOVED***t.state === MONGOCRYPT_CTX_ERROR) {
            const message = conte***REMOVED***t.status.message || 'Finalization error';
            throw new MongoCryptError(message);
          }
          result = finalizedConte***REMOVED***t;
          break;
        }

        default:
          throw new MongoCryptError(`Unknown state: ${conte***REMOVED***t.state}`);
      }
    }

    if (conte***REMOVED***t.state === MONGOCRYPT_CTX_ERROR || result == null) {
      const message = conte***REMOVED***t.status.message;
      if (!message) {
        debug(
          `unidentifiable error in MongoCrypt - received an error status from \`libmongocrypt\` but received no error message.`
        );
      }
      throw new MongoCryptError(
        message ??
          'unidentifiable error in MongoCrypt - received an error status from `libmongocrypt` but received no error message.'
      );
    }

    return result;
  }

  /**
   * Handles the request to the KMS service. E***REMOVED***posed for testing purposes. Do not directly invoke.
   * @param kmsConte***REMOVED***t - A C++ KMS conte***REMOVED***t returned from the bindings
   * @returns A promise that resolves when the KMS reply has be fully parsed
   */
  async kmsRequest(request: MongoCryptKMSRequest): Promise<void> {
    const parsedUrl = request.endpoint.split(':');
    const port = parsedUrl[1] != null ? Number.parseInt(parsedUrl[1], 10) : HTTPS_PORT;
    const socketOptions = autoSelectSocketOptions(this.options.socketOptions || {});
    const options: tls.ConnectionOptions & {
      host: string;
      port: number;
      autoSelectFamily?: boolean;
      autoSelectFamilyAttemptTimeout?: number;
    } = {
      host: parsedUrl[0],
      servername: parsedUrl[0],
      port,
      ...socketOptions
    };
    const message = request.message;
    const buffer = new BufferPool();

    const netSocket: net.Socket = new net.Socket();
    let socket: tls.TLSSocket;

    function destroySockets() {
      for (const sock of [socket, netSocket]) {
        if (sock) {
          sock.removeAllListeners();
          sock.destroy();
        }
      }
    }

    function ontimeout() {
      return new MongoCryptError('KMS request timed out');
    }

    function onerror(cause: Error) {
      return new MongoCryptError('KMS request failed', { cause });
    }

    function onclose() {
      return new MongoCryptError('KMS request closed');
    }

    const tlsOptions = this.options.tlsOptions;
    if (tlsOptions) {
      const kmsProvider = request.kmsProvider;
      const providerTlsOptions = tlsOptions[kmsProvider];
      if (providerTlsOptions) {
        const error = this.validateTlsOptions(kmsProvider, providerTlsOptions);
        if (error) {
          throw error;
        }
        try {
          await this.setTlsOptions(providerTlsOptions, options);
        } catch (err) {
          throw onerror(err);
        }
      }
    }

    const {
      promise: willConnect,
      reject: rejectOnNetSocketError,
      resolve: resolveOnNetSocketConnect
    } = promiseWithResolvers<void>();
    netSocket
      .once('timeout', () => rejectOnNetSocketError(ontimeout()))
      .once('error', err => rejectOnNetSocketError(onerror(err)))
      .once('close', () => rejectOnNetSocketError(onclose()))
      .once('connect', () => resolveOnNetSocketConnect());

    try {
      if (this.options.pro***REMOVED***yOptions && this.options.pro***REMOVED***yOptions.pro***REMOVED***yHost) {
        const netSocketOptions = {
          host: this.options.pro***REMOVED***yOptions.pro***REMOVED***yHost,
          port: this.options.pro***REMOVED***yOptions.pro***REMOVED***yPort || 1080,
          ...socketOptions
        };
        netSocket.connect(netSocketOptions);
        await willConnect;

        try {
          socks ??= loadSocks();
          options.socket = (
            await socks.SocksClient.createConnection({
              e***REMOVED***isting_socket: netSocket,
              command: 'connect',
              destination: { host: options.host, port: options.port },
              pro***REMOVED***y: {
                // host and port are ignored because we pass e***REMOVED***isting_socket
                host: 'iLoveJavaScript',
                port: 0,
                type: 5,
                userId: this.options.pro***REMOVED***yOptions.pro***REMOVED***yUsername,
                password: this.options.pro***REMOVED***yOptions.pro***REMOVED***yPassword
              }
            })
          ).socket;
        } catch (err) {
          throw onerror(err);
        }
      }

      socket = tls.connect(options, () => {
        socket.write(message);
      });

      const {
        promise: willResolveKmsRequest,
        reject: rejectOnTlsSocketError,
        resolve
      } = promiseWithResolvers<void>();
      socket
        .once('timeout', () => rejectOnTlsSocketError(ontimeout()))
        .once('error', err => rejectOnTlsSocketError(onerror(err)))
        .once('close', () => rejectOnTlsSocketError(onclose()))
        .on('data', data => {
          buffer.append(data);
          while (request.bytesNeeded > 0 && buffer.length) {
            const bytesNeeded = Math.min(request.bytesNeeded, buffer.length);
            request.addResponse(buffer.read(bytesNeeded));
          }

          if (request.bytesNeeded <= 0) {
            resolve();
          }
        });
      await willResolveKmsRequest;
    } finally {
      // There's no need for any more activity on this socket at this point.
      destroySockets();
    }
  }

  *requests(conte***REMOVED***t: MongoCryptConte***REMOVED***t) {
    for (
      let request = conte***REMOVED***t.ne***REMOVED***tKMSRequest();
      request != null;
      request = conte***REMOVED***t.ne***REMOVED***tKMSRequest()
    ) {
      yield this.kmsRequest(request);
    }
  }

  /**
   * Validates the provided TLS options are secure.
   *
   * @param kmsProvider - The KMS provider name.
   * @param tlsOptions - The client TLS options for the provider.
   *
   * @returns An error if any option is invalid.
   */
  validateTlsOptions(
    kmsProvider: string,
    tlsOptions: ClientEncryptionTlsOptions
  ): MongoCryptError | void {
    const tlsOptionNames = Object.keys(tlsOptions);
    for (const option of INSECURE_TLS_OPTIONS) {
      if (tlsOptionNames.includes(option)) {
        return new MongoCryptError(`Insecure TLS options prohibited for ${kmsProvider}: ${option}`);
      }
    }
  }

  /**
   * Sets only the valid secure TLS options.
   *
   * @param tlsOptions - The client TLS options for the provider.
   * @param options - The e***REMOVED***isting connection options.
   */
  async setTlsOptions(
    tlsOptions: ClientEncryptionTlsOptions,
    options: tls.ConnectionOptions
  ): Promise<void> {
    if (tlsOptions.tlsCertificateKeyFile) {
      const cert = await fs.readFile(tlsOptions.tlsCertificateKeyFile);
      options.cert = options.key = cert;
    }
    if (tlsOptions.tlsCAFile) {
      options.ca = await fs.readFile(tlsOptions.tlsCAFile);
    }
    if (tlsOptions.tlsCertificateKeyFilePassword) {
      options.passphrase = tlsOptions.tlsCertificateKeyFilePassword;
    }
  }

  /**
   * Fetches collection info for a provided namespace, when libmongocrypt
   * enters the `MONGOCRYPT_CTX_NEED_MONGO_COLLINFO` state. The result is
   * used to inform libmongocrypt of the schema associated with this
   * namespace. E***REMOVED***posed for testing purposes. Do not directly invoke.
   *
   * @param client - A MongoClient connected to the topology
   * @param ns - The namespace to list collections from
   * @param filter - A filter for the listCollections command
   * @param callback - Invoked with the info of the requested collection, or with an error
   */
  async fetchCollectionInfo(
    client: MongoClient,
    ns: string,
    filter: Document
  ): Promise<Uint8Array | null> {
    const { db } = MongoDBCollectionNamespace.fromString(ns);

    const collections = await client
      .db(db)
      .listCollections(filter, {
        promoteLongs: false,
        promoteValues: false
      })
      .toArray();

    const info = collections.length > 0 ? serialize(collections[0]) : null;
    return info;
  }

  /**
   * Calls to the mongocryptd to provide markings for a command.
   * E***REMOVED***posed for testing purposes. Do not directly invoke.
   * @param client - A MongoClient connected to a mongocryptd
   * @param ns - The namespace (database.collection) the command is being e***REMOVED***ecuted on
   * @param command - The command to e***REMOVED***ecute.
   * @param callback - Invoked with the serialized and marked bson command, or with an error
   */
  async markCommand(client: MongoClient, ns: string, command: Uint8Array): Promise<Uint8Array> {
    const options = { promoteLongs: false, promoteValues: false };
    const { db } = MongoDBCollectionNamespace.fromString(ns);
    const rawCommand = deserialize(command, options);

    const response = await client.db(db).command(rawCommand, options);

    return serialize(response, this.bsonOptions);
  }

  /**
   * Requests keys from the keyVault collection on the topology.
   * E***REMOVED***posed for testing purposes. Do not directly invoke.
   * @param client - A MongoClient connected to the topology
   * @param keyVaultNamespace - The namespace (database.collection) of the keyVault Collection
   * @param filter - The filter for the find query against the keyVault Collection
   * @param callback - Invoked with the found keys, or with an error
   */
  fetchKeys(
    client: MongoClient,
    keyVaultNamespace: string,
    filter: Uint8Array
  ): Promise<Array<DataKey>> {
    const { db: dbName, collection: collectionName } =
      MongoDBCollectionNamespace.fromString(keyVaultNamespace);

    return client
      .db(dbName)
      .collection<DataKey>(collectionName, { readConcern: { level: 'majority' } })
      .find(deserialize(filter))
      .toArray();
  }
}
