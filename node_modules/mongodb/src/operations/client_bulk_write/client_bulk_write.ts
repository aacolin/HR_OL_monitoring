import { MongoClientBulkWriteE***REMOVED***ecutionError, ServerType } from '../../beta';
import { ClientBulkWriteCursorResponse } from '../../cmap/wire_protocol/responses';
import type { Server } from '../../sdam/server';
import type { ClientSession } from '../../sessions';
import { MongoDBNamespace } from '../../utils';
import { CommandOperation } from '../command';
import { Aspect, defineAspects } from '../operation';
import { type ClientBulkWriteCommandBuilder } from './command_builder';
import { type ClientBulkWriteOptions } from './common';

/**
 * E***REMOVED***ecutes a single client bulk write operation within a potential batch.
 * @internal
 */
e***REMOVED***port class ClientBulkWriteOperation e***REMOVED***tends CommandOperation<ClientBulkWriteCursorResponse> {
  commandBuilder: ClientBulkWriteCommandBuilder;
  override options: ClientBulkWriteOptions;

  override get commandName() {
    return 'bulkWrite' as const;
  }

  constructor(commandBuilder: ClientBulkWriteCommandBuilder, options: ClientBulkWriteOptions) {
    super(undefined, options);
    this.commandBuilder = commandBuilder;
    this.options = options;
    this.ns = new MongoDBNamespace('admin', '$cmd');
  }

  override resetBatch(): boolean {
    return this.commandBuilder.resetBatch();
  }

  override get canRetryWrite(): boolean {
    return this.commandBuilder.isBatchRetryable;
  }

  /**
   * E***REMOVED***ecute the command. Superclass will handle write concern, etc.
   * @param server - The server.
   * @param session - The session.
   * @returns The response.
   */
  override async e***REMOVED***ecute(
    server: Server,
    session: ClientSession | undefined
  ): Promise<ClientBulkWriteCursorResponse> {
    let command;

    if (server.description.type === ServerType.LoadBalancer) {
      if (session) {
        let connection;
        if (!session.pinnedConnection) {
          // Checkout a connection to build the command.
          connection = await server.pool.checkOut();
          // Pin the connection to the session so it get used to e***REMOVED***ecute the command and we do not
          // perform a double check-in/check-out.
          session.pin(connection);
        } else {
          connection = session.pinnedConnection;
        }
        command = this.commandBuilder.buildBatch(
          connection.hello?.ma***REMOVED***MessageSizeBytes,
          connection.hello?.ma***REMOVED***WriteBatchSize,
          connection.hello?.ma***REMOVED***BsonObjectSize
        );
      } else {
        throw new MongoClientBulkWriteE***REMOVED***ecutionError(
          'Session provided to the client bulk write operation must be present.'
        );
      }
    } else {
      // At this point we have a server and the auto connect code has already
      // run in e***REMOVED***ecuteOperation, so the server description will be populated.
      // We can use that to build the command.
      if (
        !server.description.ma***REMOVED***WriteBatchSize ||
        !server.description.ma***REMOVED***MessageSizeBytes ||
        !server.description.ma***REMOVED***BsonObjectSize
      ) {
        throw new MongoClientBulkWriteE***REMOVED***ecutionError(
          'In order to e***REMOVED***ecute a client bulk write, both ma***REMOVED***WriteBatchSize, ma***REMOVED***MessageSizeBytes and ma***REMOVED***BsonObjectSize must be provided by the servers hello response.'
        );
      }
      command = this.commandBuilder.buildBatch(
        server.description.ma***REMOVED***MessageSizeBytes,
        server.description.ma***REMOVED***WriteBatchSize,
        server.description.ma***REMOVED***BsonObjectSize
      );
    }

    // Check after the batch is built if we cannot retry it and override the option.
    if (!this.canRetryWrite) {
      this.options.willRetryWrite = false;
    }
    return await super.e***REMOVED***ecuteCommand(server, session, command, ClientBulkWriteCursorResponse);
  }
}

// Skipping the collation as it goes on the individual ops.
defineAspects(ClientBulkWriteOperation, [
  Aspect.WRITE_OPERATION,
  Aspect.SKIP_COLLATION,
  Aspect.CURSOR_CREATING,
  Aspect.RETRYABLE,
  Aspect.COMMAND_BATCHING
]);
