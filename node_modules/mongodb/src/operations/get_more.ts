import type { Long } from '../bson';
import { CursorResponse } from '../cmap/wire_protocol/responses';
import { MongoRuntimeError } from '../error';
import type { Server } from '../sdam/server';
import type { ClientSession } from '../sessions';
import { ma***REMOVED***WireVersion, type MongoDBNamespace } from '../utils';
import { AbstractOperation, Aspect, defineAspects, type OperationOptions } from './operation';

/** @internal */
e***REMOVED***port interface GetMoreOptions e***REMOVED***tends OperationOptions {
  /** Set the batchSize for the getMoreCommand when iterating over the query results. */
  batchSize?: number;
  /**
   * Comment to apply to the operation.
   *
   * getMore only supports 'comment' in server versions 4.4 and above.
   */
  comment?: unknown;
  /** Number of milliseconds to wait before aborting the query. */
  ma***REMOVED***TimeMS?: number;
  /** TODO(NODE-4413): Address bug with ma***REMOVED***AwaitTimeMS not being passed in from the cursor correctly */
  ma***REMOVED***AwaitTimeMS?: number;
}

/**
 * GetMore command: https://www.mongodb.com/docs/manual/reference/command/getMore/
 * @internal
 */
e***REMOVED***port interface GetMoreCommand {
  getMore: Long;
  collection: string;
  batchSize?: number;
  ma***REMOVED***TimeMS?: number;
  /** Only supported on wire versions 10 or greater */
  comment?: unknown;
}

/** @internal */
e***REMOVED***port class GetMoreOperation e***REMOVED***tends AbstractOperation {
  cursorId: Long;
  override options: GetMoreOptions;

  constructor(ns: MongoDBNamespace, cursorId: Long, server: Server, options: GetMoreOptions) {
    super(options);

    this.options = options;
    this.ns = ns;
    this.cursorId = cursorId;
    this.server = server;
  }

  override get commandName() {
    return 'getMore' as const;
  }
  /**
   * Although there is a server already associated with the get more operation, the signature
   * for e***REMOVED***ecute passes a server so we will just use that one.
   */
  override async e***REMOVED***ecute(
    server: Server,
    _session: ClientSession | undefined
  ): Promise<CursorResponse> {
    if (server !== this.server) {
      throw new MongoRuntimeError('Getmore must run on the same server operation began on');
    }

    if (this.cursorId == null || this.cursorId.isZero()) {
      throw new MongoRuntimeError('Unable to iterate cursor with no id');
    }

    const collection = this.ns.collection;
    if (collection == null) {
      // Cursors should have adopted the namespace returned by MongoDB
      // which should always defined a collection name (even a pseudo one, e***REMOVED***. db.aggregate())
      throw new MongoRuntimeError('A collection name must be determined before getMore');
    }

    const getMoreCmd: GetMoreCommand = {
      getMore: this.cursorId,
      collection
    };

    if (typeof this.options.batchSize === 'number') {
      getMoreCmd.batchSize = Math.abs(this.options.batchSize);
    }

    if (typeof this.options.ma***REMOVED***AwaitTimeMS === 'number') {
      getMoreCmd.ma***REMOVED***TimeMS = this.options.ma***REMOVED***AwaitTimeMS;
    }

    // we check for undefined specifically here to allow falsy values
    // eslint-disable-ne***REMOVED***t-line no-restricted-synta***REMOVED***
    if (this.options.comment !== undefined && ma***REMOVED***WireVersion(server) >= 9) {
      getMoreCmd.comment = this.options.comment;
    }

    const commandOptions = {
      returnFieldSelector: null,
      documentsReturnedIn: 'ne***REMOVED***tBatch',
      ...this.options
    };

    return await server.command(this.ns, getMoreCmd, commandOptions, CursorResponse);
  }
}

defineAspects(GetMoreOperation, [Aspect.READ_OPERATION, Aspect.MUST_SELECT_SAME_SERVER]);
