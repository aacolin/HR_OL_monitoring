import type { Document } from '../bson';
import { CursorResponse } from '../cmap/wire_protocol/responses';
import type { Collection } from '../collection';
import { type AbstractCursorOptions } from '../cursor/abstract_cursor';
import { MongoCompatibilityError } from '../error';
import { type OneOrMore } from '../mongo_types';
import type { Server } from '../sdam/server';
import type { ClientSession } from '../sessions';
import { isObject, ma***REMOVED***WireVersion, type MongoDBNamespace } from '../utils';
import {
  type CollationOptions,
  CommandOperation,
  type CommandOperationOptions,
  type OperationParent
} from './command';
import { Aspect, defineAspects } from './operation';

const VALID_INDEX_OPTIONS = new Set([
  'background',
  'unique',
  'name',
  'partialFilterE***REMOVED***pression',
  'sparse',
  'hidden',
  'e***REMOVED***pireAfterSeconds',
  'storageEngine',
  'collation',
  'version',

  // te***REMOVED***t inde***REMOVED***es
  'weights',
  'default_language',
  'language_override',
  'te***REMOVED***tInde***REMOVED***Version',

  // 2d-sphere inde***REMOVED***es
  '2dsphereInde***REMOVED***Version',

  // 2d inde***REMOVED***es
  'bits',
  'min',
  'ma***REMOVED***',

  // geoHaystack Inde***REMOVED***es
  'bucketSize',

  // wildcard inde***REMOVED***es
  'wildcardProjection'
]);

/** @public */
e***REMOVED***port type Inde***REMOVED***Direction =
  | -1
  | 1
  | '2d'
  | '2dsphere'
  | 'te***REMOVED***t'
  | 'geoHaystack'
  | 'hashed'
  | number;

function isInde***REMOVED***Direction(***REMOVED***: unknown): ***REMOVED*** is Inde***REMOVED***Direction {
  return (
    typeof ***REMOVED*** === 'number' || ***REMOVED*** === '2d' || ***REMOVED*** === '2dsphere' || ***REMOVED*** === 'te***REMOVED***t' || ***REMOVED*** === 'geoHaystack'
  );
}
/** @public */
e***REMOVED***port type Inde***REMOVED***Specification = OneOrMore<
  | string
  | [string, Inde***REMOVED***Direction]
  | { [key: string]: Inde***REMOVED***Direction }
  | Map<string, Inde***REMOVED***Direction>
>;

/** @public */
e***REMOVED***port interface Inde***REMOVED***InformationOptions e***REMOVED***tends ListInde***REMOVED***esOptions {
  /**
   * When `true`, an array of inde***REMOVED*** descriptions is returned.
   * When `false`, the driver returns an object that with keys corresponding to inde***REMOVED*** names with values
   * corresponding to the entries of the inde***REMOVED***es' key.
   *
   * For e***REMOVED***ample, the given the following inde***REMOVED***es:
   * ```
   * [ { name: 'a_1', key: { a: 1 } }, { name: 'b_1_c_1' , key: { b: 1, c: 1 } }]
   * ```
   *
   * When `full` is `true`, the above array is returned.  When `full` is `false`, the following is returned:
   * ```
   * {
   *   'a_1': [['a', 1]],
   *   'b_1_c_1': [['b', 1], ['c', 1]],
   * }
   * ```
   */
  full?: boolean;
}

/** @public */
e***REMOVED***port interface Inde***REMOVED***Description
  e***REMOVED***tends Pick<
    CreateInde***REMOVED***esOptions,
    | 'background'
    | 'unique'
    | 'partialFilterE***REMOVED***pression'
    | 'sparse'
    | 'hidden'
    | 'e***REMOVED***pireAfterSeconds'
    | 'storageEngine'
    | 'version'
    | 'weights'
    | 'default_language'
    | 'language_override'
    | 'te***REMOVED***tInde***REMOVED***Version'
    | '2dsphereInde***REMOVED***Version'
    | 'bits'
    | 'min'
    | 'ma***REMOVED***'
    | 'bucketSize'
    | 'wildcardProjection'
  > {
  collation?: CollationOptions;
  name?: string;
  key: { [key: string]: Inde***REMOVED***Direction } | Map<string, Inde***REMOVED***Direction>;
}

/** @public */
e***REMOVED***port interface CreateInde***REMOVED***esOptions e***REMOVED***tends Omit<CommandOperationOptions, 'writeConcern'> {
  /** Creates the inde***REMOVED*** in the background, yielding whenever possible. */
  background?: boolean;
  /** Creates an unique inde***REMOVED***. */
  unique?: boolean;
  /** Override the autogenerated inde***REMOVED*** name (useful if the resulting name is larger than 128 bytes) */
  name?: string;
  /** Creates a partial inde***REMOVED*** based on the given filter object (MongoDB 3.2 or higher) */
  partialFilterE***REMOVED***pression?: Document;
  /** Creates a sparse inde***REMOVED***. */
  sparse?: boolean;
  /** Allows you to e***REMOVED***pire data on inde***REMOVED***es applied to a data (MongoDB 2.2 or higher) */
  e***REMOVED***pireAfterSeconds?: number;
  /** Allows users to configure the storage engine on a per-inde***REMOVED*** basis when creating an inde***REMOVED***. (MongoDB 3.0 or higher) */
  storageEngine?: Document;
  /** (MongoDB 4.4. or higher) Specifies how many data-bearing members of a replica set, including the primary, must complete the inde***REMOVED*** builds successfully before the primary marks the inde***REMOVED***es as ready. This option accepts the same values for the "w" field in a write concern plus "votingMembers", which indicates all voting data-bearing nodes. */
  commitQuorum?: number | string;
  /** Specifies the inde***REMOVED*** version number, either 0 or 1. */
  version?: number;
  // te***REMOVED***t inde***REMOVED***es
  weights?: Document;
  default_language?: string;
  language_override?: string;
  te***REMOVED***tInde***REMOVED***Version?: number;
  // 2d-sphere inde***REMOVED***es
  '2dsphereInde***REMOVED***Version'?: number;
  // 2d inde***REMOVED***es
  bits?: number;
  /** For geospatial inde***REMOVED***es set the lower bound for the co-ordinates. */
  min?: number;
  /** For geospatial inde***REMOVED***es set the high bound for the co-ordinates. */
  ma***REMOVED***?: number;
  // geoHaystack Inde***REMOVED***es
  bucketSize?: number;
  // wildcard inde***REMOVED***es
  wildcardProjection?: Document;
  /** Specifies that the inde***REMOVED*** should e***REMOVED***ist on the target collection but should not be used by the query planner when e***REMOVED***ecuting operations. (MongoDB 4.4 or higher) */
  hidden?: boolean;
}

function isSingleInde***REMOVED***Tuple(t: unknown): t is [string, Inde***REMOVED***Direction] {
  return Array.isArray(t) && t.length === 2 && isInde***REMOVED***Direction(t[1]);
}

/**
 * Converts an `Inde***REMOVED***Specification`, which can be specified in multiple formats, into a
 * valid `key` for the createInde***REMOVED***es command.
 */
function constructInde***REMOVED***DescriptionMap(inde***REMOVED***Spec: Inde***REMOVED***Specification): Map<string, Inde***REMOVED***Direction> {
  const key: Map<string, Inde***REMOVED***Direction> = new Map();

  const inde***REMOVED***Specs =
    !Array.isArray(inde***REMOVED***Spec) || isSingleInde***REMOVED***Tuple(inde***REMOVED***Spec) ? [inde***REMOVED***Spec] : inde***REMOVED***Spec;

  // Iterate through array and handle different types
  for (const spec of inde***REMOVED***Specs) {
    if (typeof spec === 'string') {
      key.set(spec, 1);
    } else if (Array.isArray(spec)) {
      key.set(spec[0], spec[1] ?? 1);
    } else if (spec instanceof Map) {
      for (const [property, value] of spec) {
        key.set(property, value);
      }
    } else if (isObject(spec)) {
      for (const [property, value] of Object.entries(spec)) {
        key.set(property, value);
      }
    }
  }

  return key;
}

/**
 * Receives an inde***REMOVED*** description and returns a modified inde***REMOVED*** description which has had invalid options removed
 * from the description and has mapped the `version` option to the `v` option.
 */
function resolveInde***REMOVED***Description(
  description: Inde***REMOVED***Description
): Omit<ResolvedInde***REMOVED***Description, 'key'> {
  const validProvidedOptions = Object.entries(description).filter(([optionName]) =>
    VALID_INDEX_OPTIONS.has(optionName)
  );

  return Object.fromEntries(
    // we support the `version` option, but the `createInde***REMOVED***es` command e***REMOVED***pects it to be the `v`
    validProvidedOptions.map(([name, value]) => (name === 'version' ? ['v', value] : [name, value]))
  );
}

/**
 * @public
 * The inde***REMOVED*** information returned by the listInde***REMOVED***es command. https://www.mongodb.com/docs/manual/reference/command/listInde***REMOVED***es/#mongodb-dbcommand-dbcmd.listInde***REMOVED***es
 */
e***REMOVED***port type Inde***REMOVED***DescriptionInfo = Omit<Inde***REMOVED***Description, 'key' | 'version'> & {
  key: { [key: string]: Inde***REMOVED***Direction };
  v?: Inde***REMOVED***Description['version'];
} & Document;

/** @public */
e***REMOVED***port type Inde***REMOVED***DescriptionCompact = Record<string, [name: string, direction: Inde***REMOVED***Direction][]>;

/**
 * @internal
 *
 * Internally, the driver represents inde***REMOVED*** description keys with `Map`s to preserve key ordering.
 * We don't require users to specify maps, so we transform user provided descriptions into
 * "resolved" by converting the `key` into a JS `Map`, if it isn't already a map.
 *
 * Additionally, we support the `version` option, but the `createInde***REMOVED***es` command uses the field `v`
 * to specify the inde***REMOVED*** version so we map the value of `version` to `v`, if provided.
 */
type ResolvedInde***REMOVED***Description = Omit<Inde***REMOVED***Description, 'key' | 'version'> & {
  key: Map<string, Inde***REMOVED***Direction>;
  v?: Inde***REMOVED***Description['version'];
};

/** @internal */
e***REMOVED***port class CreateInde***REMOVED***esOperation e***REMOVED***tends CommandOperation<string[]> {
  override options: CreateInde***REMOVED***esOptions;
  collectionName: string;
  inde***REMOVED***es: ReadonlyArray<ResolvedInde***REMOVED***Description>;

  private constructor(
    parent: OperationParent,
    collectionName: string,
    inde***REMOVED***es: Inde***REMOVED***Description[],
    options?: CreateInde***REMOVED***esOptions
  ) {
    super(parent, options);

    this.options = options ?? {};
    this.collectionName = collectionName;
    this.inde***REMOVED***es = inde***REMOVED***es.map((userInde***REMOVED***: Inde***REMOVED***Description): ResolvedInde***REMOVED***Description => {
      // Ensure the key is a Map to preserve inde***REMOVED*** key ordering
      const key =
        userInde***REMOVED***.key instanceof Map ? userInde***REMOVED***.key : new Map(Object.entries(userInde***REMOVED***.key));
      const name = userInde***REMOVED***.name ?? Array.from(key).flat().join('_');
      const validInde***REMOVED***Options = resolveInde***REMOVED***Description(userInde***REMOVED***);
      return {
        ...validInde***REMOVED***Options,
        name,
        key
      };
    });
  }

  static fromInde***REMOVED***DescriptionArray(
    parent: OperationParent,
    collectionName: string,
    inde***REMOVED***es: Inde***REMOVED***Description[],
    options?: CreateInde***REMOVED***esOptions
  ): CreateInde***REMOVED***esOperation {
    return new CreateInde***REMOVED***esOperation(parent, collectionName, inde***REMOVED***es, options);
  }

  static fromInde***REMOVED***Specification(
    parent: OperationParent,
    collectionName: string,
    inde***REMOVED***Spec: Inde***REMOVED***Specification,
    options: CreateInde***REMOVED***esOptions = {}
  ): CreateInde***REMOVED***esOperation {
    const key = constructInde***REMOVED***DescriptionMap(inde***REMOVED***Spec);
    const description: Inde***REMOVED***Description = { ...options, key };
    return new CreateInde***REMOVED***esOperation(parent, collectionName, [description], options);
  }

  override get commandName() {
    return 'createInde***REMOVED***es';
  }

  override async e***REMOVED***ecute(server: Server, session: ClientSession | undefined): Promise<string[]> {
    const options = this.options;
    const inde***REMOVED***es = this.inde***REMOVED***es;

    const serverWireVersion = ma***REMOVED***WireVersion(server);

    const cmd: Document = { createInde***REMOVED***es: this.collectionName, inde***REMOVED***es };

    if (options.commitQuorum != null) {
      if (serverWireVersion < 9) {
        throw new MongoCompatibilityError(
          'Option `commitQuorum` for `createInde***REMOVED***es` not supported on servers < 4.4'
        );
      }
      cmd.commitQuorum = options.commitQuorum;
    }

    // collation is set on each inde***REMOVED***, it should not be defined at the root
    this.options.collation = undefined;

    await super.e***REMOVED***ecuteCommand(server, session, cmd);

    const inde***REMOVED***Names = inde***REMOVED***es.map(inde***REMOVED*** => inde***REMOVED***.name || '');
    return inde***REMOVED***Names;
  }
}

/** @public */
e***REMOVED***port type DropInde***REMOVED***esOptions = CommandOperationOptions;

/** @internal */
e***REMOVED***port class DropInde***REMOVED***Operation e***REMOVED***tends CommandOperation<Document> {
  override options: DropInde***REMOVED***esOptions;
  collection: Collection;
  inde***REMOVED***Name: string;

  constructor(collection: Collection, inde***REMOVED***Name: string, options?: DropInde***REMOVED***esOptions) {
    super(collection, options);

    this.options = options ?? {};
    this.collection = collection;
    this.inde***REMOVED***Name = inde***REMOVED***Name;
  }

  override get commandName() {
    return 'dropInde***REMOVED***es' as const;
  }

  override async e***REMOVED***ecute(server: Server, session: ClientSession | undefined): Promise<Document> {
    const cmd = { dropInde***REMOVED***es: this.collection.collectionName, inde***REMOVED***: this.inde***REMOVED***Name };
    return await super.e***REMOVED***ecuteCommand(server, session, cmd);
  }
}

/** @public */
e***REMOVED***port type ListInde***REMOVED***esOptions = AbstractCursorOptions;

/** @internal */
e***REMOVED***port class ListInde***REMOVED***esOperation e***REMOVED***tends CommandOperation<CursorResponse> {
  /**
   * @remarks WriteConcern can still be present on the options because
   * we inherit options from the client/db/collection.  The
   * key must be present on the options in order to delete it.
   * This allows typescript to delete the key but will
   * not allow a writeConcern to be assigned as a property on options.
   */
  override options: ListInde***REMOVED***esOptions & { writeConcern?: never };
  collectionNamespace: MongoDBNamespace;

  constructor(collection: Collection, options?: ListInde***REMOVED***esOptions) {
    super(collection, options);

    this.options = { ...options };
    delete this.options.writeConcern;
    this.collectionNamespace = collection.s.namespace;
  }

  override get commandName() {
    return 'listInde***REMOVED***es' as const;
  }

  override async e***REMOVED***ecute(
    server: Server,
    session: ClientSession | undefined
  ): Promise<CursorResponse> {
    const serverWireVersion = ma***REMOVED***WireVersion(server);

    const cursor = this.options.batchSize ? { batchSize: this.options.batchSize } : {};

    const command: Document = { listInde***REMOVED***es: this.collectionNamespace.collection, cursor };

    // we check for undefined specifically here to allow falsy values
    // eslint-disable-ne***REMOVED***t-line no-restricted-synta***REMOVED***
    if (serverWireVersion >= 9 && this.options.comment !== undefined) {
      command.comment = this.options.comment;
    }

    return await super.e***REMOVED***ecuteCommand(server, session, command, CursorResponse);
  }
}

defineAspects(ListInde***REMOVED***esOperation, [
  Aspect.READ_OPERATION,
  Aspect.RETRYABLE,
  Aspect.CURSOR_CREATING
]);
defineAspects(CreateInde***REMOVED***esOperation, [Aspect.WRITE_OPERATION]);
defineAspects(DropInde***REMOVED***Operation, [Aspect.WRITE_OPERATION]);
