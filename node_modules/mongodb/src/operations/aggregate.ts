import type { Document } from '../bson';
import { CursorResponse, E***REMOVED***plainedCursorResponse } from '../cmap/wire_protocol/responses';
import { MongoInvalidArgumentError } from '../error';
import { type E***REMOVED***plainOptions } from '../e***REMOVED***plain';
import type { Server } from '../sdam/server';
import type { ClientSession } from '../sessions';
import { ma***REMOVED***WireVersion, type MongoDBNamespace } from '../utils';
import { WriteConcern } from '../write_concern';
import { type CollationOptions, CommandOperation, type CommandOperationOptions } from './command';
import { Aspect, defineAspects, type Hint } from './operation';

/** @internal */
// eslint-disable-ne***REMOVED***t-line @typescript-eslint/no-unnecessary-type-assertion
e***REMOVED***port const DB_AGGREGATE_COLLECTION = 1 as const;
const MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;

/** @public */
e***REMOVED***port interface AggregateOptions e***REMOVED***tends Omit<CommandOperationOptions, 'e***REMOVED***plain'> {
  /** allowDiskUse lets the server know if it can use disk to store temporary results for the aggregation (requires mongodb 2.6 \>). */
  allowDiskUse?: boolean;
  /** The number of documents to return per batch. See [aggregation documentation](https://www.mongodb.com/docs/manual/reference/command/aggregate). */
  batchSize?: number;
  /** Allow driver to bypass schema validation. */
  bypassDocumentValidation?: boolean;
  /** Return the query as cursor, on 2.6 \> it returns as a real cursor on pre 2.6 it returns as an emulated cursor. */
  cursor?: Document;
  /** specifies a cumulative time limit in milliseconds for processing operations on the cursor. MongoDB interrupts the operation at the earliest following interrupt point. */
  ma***REMOVED***TimeMS?: number;
  /** The ma***REMOVED***imum amount of time for the server to wait on new documents to satisfy a tailable cursor query. */
  ma***REMOVED***AwaitTimeMS?: number;
  /** Specify collation. */
  collation?: CollationOptions;
  /** Add an inde***REMOVED*** selection hint to an aggregation command */
  hint?: Hint;
  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */
  let?: Document;

  out?: string;

  /**
   * Specifies the verbosity mode for the e***REMOVED***plain output.
   * @deprecated This API is deprecated in favor of `collection.aggregate().e***REMOVED***plain()`
   * or `db.aggregate().e***REMOVED***plain()`.
   */
  e***REMOVED***plain?: E***REMOVED***plainOptions['e***REMOVED***plain'];
}

/** @internal */
e***REMOVED***port class AggregateOperation e***REMOVED***tends CommandOperation<CursorResponse> {
  override options: AggregateOptions;
  target: string | typeof DB_AGGREGATE_COLLECTION;
  pipeline: Document[];
  hasWriteStage: boolean;

  constructor(ns: MongoDBNamespace, pipeline: Document[], options?: AggregateOptions) {
    super(undefined, { ...options, dbName: ns.db });

    this.options = { ...options };

    // Covers when ns.collection is null, undefined or the empty string, use DB_AGGREGATE_COLLECTION
    this.target = ns.collection || DB_AGGREGATE_COLLECTION;

    this.pipeline = pipeline;

    // determine if we have a write stage, override read preference if so
    this.hasWriteStage = false;
    if (typeof options?.out === 'string') {
      this.pipeline = this.pipeline.concat({ $out: options.out });
      this.hasWriteStage = true;
    } else if (pipeline.length > 0) {
      const finalStage = pipeline[pipeline.length - 1];
      if (finalStage.$out || finalStage.$merge) {
        this.hasWriteStage = true;
      }
    }

    if (this.hasWriteStage) {
      this.trySecondaryWrite = true;
    } else {
      delete this.options.writeConcern;
    }

    if (this.e***REMOVED***plain && this.writeConcern) {
      throw new MongoInvalidArgumentError(
        'Option "e***REMOVED***plain" cannot be used on an aggregate call with writeConcern'
      );
    }

    if (options?.cursor != null && typeof options.cursor !== 'object') {
      throw new MongoInvalidArgumentError('Cursor options must be an object');
    }
  }

  override get commandName() {
    return 'aggregate' as const;
  }

  override get canRetryRead(): boolean {
    return !this.hasWriteStage;
  }

  addToPipeline(stage: Document): void {
    this.pipeline.push(stage);
  }

  override async e***REMOVED***ecute(
    server: Server,
    session: ClientSession | undefined
  ): Promise<CursorResponse> {
    const options: AggregateOptions = this.options;
    const serverWireVersion = ma***REMOVED***WireVersion(server);
    const command: Document = { aggregate: this.target, pipeline: this.pipeline };

    if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {
      this.readConcern = undefined;
    }

    if (this.hasWriteStage && this.writeConcern) {
      WriteConcern.apply(command, this.writeConcern);
    }

    if (options.bypassDocumentValidation === true) {
      command.bypassDocumentValidation = options.bypassDocumentValidation;
    }

    if (typeof options.allowDiskUse === 'boolean') {
      command.allowDiskUse = options.allowDiskUse;
    }

    if (options.hint) {
      command.hint = options.hint;
    }

    if (options.let) {
      command.let = options.let;
    }

    // we check for undefined specifically here to allow falsy values
    // eslint-disable-ne***REMOVED***t-line no-restricted-synta***REMOVED***
    if (options.comment !== undefined) {
      command.comment = options.comment;
    }

    command.cursor = options.cursor || {};
    if (options.batchSize && !this.hasWriteStage) {
      command.cursor.batchSize = options.batchSize;
    }

    return await super.e***REMOVED***ecuteCommand(
      server,
      session,
      command,
      this.e***REMOVED***plain ? E***REMOVED***plainedCursorResponse : CursorResponse
    );
  }
}

defineAspects(AggregateOperation, [
  Aspect.READ_OPERATION,
  Aspect.RETRYABLE,
  Aspect.EXPLAINABLE,
  Aspect.CURSOR_CREATING
]);
