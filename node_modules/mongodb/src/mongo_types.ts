import { EventEmitter } from 'events';

import type {
  Binary,
  BSONRegE***REMOVED***p,
  BSONType,
  Decimal128,
  Document,
  Double,
  Int32,
  Long,
  ObjectId,
  ObjectIdLike,
  Timestamp
} from './bson';
import { type CommandStartedEvent } from './cmap/command_monitoring_events';
import {
  type LoggableCommandFailedEvent,
  type LoggableCommandSucceededEvent,
  type LoggableServerHeartbeatFailedEvent,
  type LoggableServerHeartbeatStartedEvent,
  type LoggableServerHeartbeatSucceededEvent,
  MongoLoggableComponent,
  type MongoLogger
} from './mongo_logger';
import type { Sort } from './sort';

/** @internal */
e***REMOVED***port type TODO_NODE_3286 = any;

/** Given an object shaped type, return the type of the _id field or default to ObjectId @public */
e***REMOVED***port type InferIdType<TSchema> = TSchema e***REMOVED***tends { _id: infer IdType }
  ? // user has defined a type for _id
    Record<any, never> e***REMOVED***tends IdType
    ? never // e***REMOVED***plicitly forbid empty objects as the type of _id
    : IdType
  : TSchema e***REMOVED***tends { _id?: infer IdType }
    ? // optional _id defined - return ObjectId | IdType
      unknown e***REMOVED***tends IdType
      ? ObjectId // infer the _id type as ObjectId if the type of _id is unknown
      : IdType
    : ObjectId; // user has not defined _id on schema

/** Add an _id field to an object shaped type @public */
e***REMOVED***port type WithId<TSchema> = EnhancedOmit<TSchema, '_id'> & { _id: InferIdType<TSchema> };

/**
 * Add an optional _id field to an object shaped type
 * @public
 */
e***REMOVED***port type OptionalId<TSchema> = EnhancedOmit<TSchema, '_id'> & { _id?: InferIdType<TSchema> };

/**
 * Adds an optional _id field to an object shaped type, unless the _id field is required on that type.
 * In the case _id is required, this method continues to require_id.
 *
 * @public
 *
 * @privateRemarks
 * `ObjectId e***REMOVED***tends TSchema['_id']` is a confusing ordering at first glance. Rather than ask
 * `TSchema['_id'] e***REMOVED***tends ObjectId` which translated to "Is the _id property ObjectId?"
 * we instead ask "Does ObjectId look like (have the same shape) as the _id?"
 */
e***REMOVED***port type OptionalUnlessRequiredId<TSchema> = TSchema e***REMOVED***tends { _id: any }
  ? TSchema
  : OptionalId<TSchema>;

/** TypeScript Omit (E***REMOVED***clude to be specific) does not work for objects with an "any" inde***REMOVED***ed type, and breaks discriminated unions @public */
e***REMOVED***port type EnhancedOmit<TRecordOrUnion, KeyUnion> = string e***REMOVED***tends keyof TRecordOrUnion
  ? TRecordOrUnion // TRecordOrUnion has inde***REMOVED***ed type e.g. { _id: string; [k: string]: any; } or it is "any"
  : TRecordOrUnion e***REMOVED***tends any
    ? Pick<TRecordOrUnion, E***REMOVED***clude<keyof TRecordOrUnion, KeyUnion>> // discriminated unions
    : never;

/** Remove the _id field from an object shaped type @public */
e***REMOVED***port type WithoutId<TSchema> = Omit<TSchema, '_id'>;

/** A MongoDB filter can be some portion of the schema or a set of operators @public */
e***REMOVED***port type Filter<TSchema> = {
  [P in keyof WithId<TSchema>]?: Condition<WithId<TSchema>[P]>;
} & RootFilterOperators<WithId<TSchema>>;

/** @public */
e***REMOVED***port type Condition<T> = AlternativeType<T> | FilterOperators<AlternativeType<T>>;

/**
 * It is possible to search using alternative types in mongodb e.g.
 * string types can be searched using a rege***REMOVED*** in mongo
 * array types can be searched using their element type
 * @public
 */
e***REMOVED***port type AlternativeType<T> =
  T e***REMOVED***tends ReadonlyArray<infer U> ? T | RegE***REMOVED***pOrString<U> : RegE***REMOVED***pOrString<T>;

/** @public */
e***REMOVED***port type RegE***REMOVED***pOrString<T> = T e***REMOVED***tends string ? BSONRegE***REMOVED***p | RegE***REMOVED***p | T : T;

/** @public */
e***REMOVED***port interface RootFilterOperators<TSchema> e***REMOVED***tends Document {
  $and?: Filter<TSchema>[];
  $nor?: Filter<TSchema>[];
  $or?: Filter<TSchema>[];
  $te***REMOVED***t?: {
    $search: string;
    $language?: string;
    $caseSensitive?: boolean;
    $diacriticSensitive?: boolean;
  };
  $where?: string | ((this: TSchema) => boolean);
  $comment?: string | Document;
}

/**
 * @public
 * A type that e***REMOVED***tends Document but forbids anything that "looks like" an object id.
 */
e***REMOVED***port type NonObjectIdLikeDocument = {
  [key in keyof ObjectIdLike]?: never;
} & Document;

/** @public */
e***REMOVED***port interface FilterOperators<TValue> e***REMOVED***tends NonObjectIdLikeDocument {
  // Comparison
  $eq?: TValue;
  $gt?: TValue;
  $gte?: TValue;
  $in?: ReadonlyArray<TValue>;
  $lt?: TValue;
  $lte?: TValue;
  $ne?: TValue;
  $nin?: ReadonlyArray<TValue>;
  // Logical
  $not?: TValue e***REMOVED***tends string ? FilterOperators<TValue> | RegE***REMOVED***p : FilterOperators<TValue>;
  // Element
  /**
   * When `true`, `$e***REMOVED***ists` matches the documents that contain the field,
   * including documents where the field value is null.
   */
  $e***REMOVED***ists?: boolean;
  $type?: BSONType | BSONTypeAlias;
  // Evaluation
  $e***REMOVED***pr?: Record<string, any>;
  $jsonSchema?: Record<string, any>;
  $mod?: TValue e***REMOVED***tends number ? [number, number] : never;
  $rege***REMOVED***?: TValue e***REMOVED***tends string ? RegE***REMOVED***p | BSONRegE***REMOVED***p | string : never;
  $options?: TValue e***REMOVED***tends string ? string : never;
  // Geospatial
  $geoIntersects?: { $geometry: Document };
  $geoWithin?: Document;
  $near?: Document;
  $nearSphere?: Document;
  $ma***REMOVED***Distance?: number;
  // Array
  $all?: ReadonlyArray<any>;
  $elemMatch?: Document;
  $size?: TValue e***REMOVED***tends ReadonlyArray<any> ? number : never;
  // Bitwise
  $bitsAllClear?: BitwiseFilter;
  $bitsAllSet?: BitwiseFilter;
  $bitsAnyClear?: BitwiseFilter;
  $bitsAnySet?: BitwiseFilter;
  $rand?: Record<string, never>;
}

/** @public */
e***REMOVED***port type BitwiseFilter =
  | number /** numeric bit mask */
  | Binary /** BinData bit mask */
  | ReadonlyArray<number>; /** `[ <position1>, <position2>, ... ]` */

/** @public */
e***REMOVED***port type BSONTypeAlias = keyof typeof BSONType;

/** @public */
e***REMOVED***port type IsAny<Type, ResultIfAny, ResultIfNotAny> = true e***REMOVED***tends false & Type
  ? ResultIfAny
  : ResultIfNotAny;

/** @public */
e***REMOVED***port type Flatten<Type> = Type e***REMOVED***tends ReadonlyArray<infer Item> ? Item : Type;

/** @public */
e***REMOVED***port type ArrayElement<Type> = Type e***REMOVED***tends ReadonlyArray<infer Item> ? Item : never;

/** @public */
e***REMOVED***port type SchemaMember<T, V> = { [P in keyof T]?: V } | { [key: string]: V };

/** @public */
e***REMOVED***port type IntegerType = number | Int32 | Long | bigint;

/** @public */
e***REMOVED***port type NumericType = IntegerType | Decimal128 | Double;

/** @public */
e***REMOVED***port type FilterOperations<T> =
  T e***REMOVED***tends Record<string, any>
    ? { [key in keyof T]?: FilterOperators<T[key]> }
    : FilterOperators<T>;

/** @public */
e***REMOVED***port type KeysOfAType<TSchema, Type> = {
  [key in keyof TSchema]: NonNullable<TSchema[key]> e***REMOVED***tends Type ? key : never;
}[keyof TSchema];

/** @public */
e***REMOVED***port type KeysOfOtherType<TSchema, Type> = {
  [key in keyof TSchema]: NonNullable<TSchema[key]> e***REMOVED***tends Type ? never : key;
}[keyof TSchema];

/** @public */
e***REMOVED***port type AcceptedFields<TSchema, FieldType, AssignableType> = {
  readonly [key in KeysOfAType<TSchema, FieldType>]?: AssignableType;
};

/** It avoids using fields with not acceptable types @public */
e***REMOVED***port type NotAcceptedFields<TSchema, FieldType> = {
  readonly [key in KeysOfOtherType<TSchema, FieldType>]?: never;
};

/** @public */
e***REMOVED***port type OnlyFieldsOfType<TSchema, FieldType = any, AssignableType = FieldType> = IsAny<
  TSchema[keyof TSchema],
  AssignableType e***REMOVED***tends FieldType ? Record<string, FieldType> : Record<string, AssignableType>,
  AcceptedFields<TSchema, FieldType, AssignableType> &
    NotAcceptedFields<TSchema, FieldType> &
    Record<string, AssignableType>
>;

/** @public */
e***REMOVED***port type MatchKeysAndValues<TSchema> = Readonly<Partial<TSchema>> & Record<string, any>;

/** @public */
e***REMOVED***port type AddToSetOperators<Type> = {
  $each?: Array<Flatten<Type>>;
};

/** @public */
e***REMOVED***port type ArrayOperator<Type> = {
  $each?: Array<Flatten<Type>>;
  $slice?: number;
  $position?: number;
  $sort?: Sort;
};

/** @public */
e***REMOVED***port type SetFields<TSchema> = ({
  readonly [key in KeysOfAType<TSchema, ReadonlyArray<any> | undefined>]?:
    | OptionalId<Flatten<TSchema[key]>>
    | AddToSetOperators<Array<OptionalId<Flatten<TSchema[key]>>>>;
} & IsAny<
  TSchema[keyof TSchema],
  object,
  NotAcceptedFields<TSchema, ReadonlyArray<any> | undefined>
>) & {
  readonly [key: string]: AddToSetOperators<any> | any;
};

/** @public */
e***REMOVED***port type PushOperator<TSchema> = ({
  readonly [key in KeysOfAType<TSchema, ReadonlyArray<any>>]?:
    | Flatten<TSchema[key]>
    | ArrayOperator<Array<Flatten<TSchema[key]>>>;
} & NotAcceptedFields<TSchema, ReadonlyArray<any>>) & {
  readonly [key: string]: ArrayOperator<any> | any;
};

/** @public */
e***REMOVED***port type PullOperator<TSchema> = ({
  readonly [key in KeysOfAType<TSchema, ReadonlyArray<any>>]?:
    | Partial<Flatten<TSchema[key]>>
    | FilterOperations<Flatten<TSchema[key]>>;
} & NotAcceptedFields<TSchema, ReadonlyArray<any>>) & {
  readonly [key: string]: FilterOperators<any> | any;
};

/** @public */
e***REMOVED***port type PullAllOperator<TSchema> = ({
  readonly [key in KeysOfAType<TSchema, ReadonlyArray<any>>]?: TSchema[key];
} & NotAcceptedFields<TSchema, ReadonlyArray<any>>) & {
  readonly [key: string]: ReadonlyArray<any>;
};

/** @public */
e***REMOVED***port type UpdateFilter<TSchema> = {
  $currentDate?: OnlyFieldsOfType<
    TSchema,
    Date | Timestamp,
    true | { $type: 'date' | 'timestamp' }
  >;
  $inc?: OnlyFieldsOfType<TSchema, NumericType | undefined>;
  $min?: MatchKeysAndValues<TSchema>;
  $ma***REMOVED***?: MatchKeysAndValues<TSchema>;
  $mul?: OnlyFieldsOfType<TSchema, NumericType | undefined>;
  $rename?: Record<string, string>;
  $set?: MatchKeysAndValues<TSchema>;
  $setOnInsert?: MatchKeysAndValues<TSchema>;
  $unset?: OnlyFieldsOfType<TSchema, any, '' | true | 1>;
  $addToSet?: SetFields<TSchema>;
  $pop?: OnlyFieldsOfType<TSchema, ReadonlyArray<any>, 1 | -1>;
  $pull?: PullOperator<TSchema>;
  $push?: PushOperator<TSchema>;
  $pullAll?: PullAllOperator<TSchema>;
  $bit?: OnlyFieldsOfType<
    TSchema,
    NumericType | undefined,
    { and: IntegerType } | { or: IntegerType } | { ***REMOVED***or: IntegerType }
  >;
} & Document;

/** @public */
e***REMOVED***port type Nullable<AnyType> = AnyType | null | undefined;

/** @public */
e***REMOVED***port type OneOrMore<T> = T | ReadonlyArray<T>;

/** @public */
e***REMOVED***port type GenericListener = (...args: any[]) => void;

/**
 * Event description type
 * @public
 */
e***REMOVED***port type EventsDescription = Record<string, GenericListener>;

/** @public */
e***REMOVED***port type CommonEvents = 'newListener' | 'removeListener';

/**
 * Typescript type safe event emitter
 * @public
 */
e***REMOVED***port declare interface TypedEventEmitter<Events e***REMOVED***tends EventsDescription> e***REMOVED***tends EventEmitter {
  addListener<EventKey e***REMOVED***tends keyof Events>(event: EventKey, listener: Events[EventKey]): this;
  addListener(
    event: CommonEvents,
    listener: (eventName: string | symbol, listener: GenericListener) => void
  ): this;
  addListener(event: string | symbol, listener: GenericListener): this;

  on<EventKey e***REMOVED***tends keyof Events>(event: EventKey, listener: Events[EventKey]): this;
  on(
    event: CommonEvents,
    listener: (eventName: string | symbol, listener: GenericListener) => void
  ): this;
  on(event: string | symbol, listener: GenericListener): this;

  once<EventKey e***REMOVED***tends keyof Events>(event: EventKey, listener: Events[EventKey]): this;
  once(
    event: CommonEvents,
    listener: (eventName: string | symbol, listener: GenericListener) => void
  ): this;
  once(event: string | symbol, listener: GenericListener): this;

  removeListener<EventKey e***REMOVED***tends keyof Events>(event: EventKey, listener: Events[EventKey]): this;
  removeListener(
    event: CommonEvents,
    listener: (eventName: string | symbol, listener: GenericListener) => void
  ): this;
  removeListener(event: string | symbol, listener: GenericListener): this;

  off<EventKey e***REMOVED***tends keyof Events>(event: EventKey, listener: Events[EventKey]): this;
  off(
    event: CommonEvents,
    listener: (eventName: string | symbol, listener: GenericListener) => void
  ): this;
  off(event: string | symbol, listener: GenericListener): this;

  removeAllListeners<EventKey e***REMOVED***tends keyof Events>(
    event?: EventKey | CommonEvents | symbol | string
  ): this;

  listeners<EventKey e***REMOVED***tends keyof Events>(
    event: EventKey | CommonEvents | symbol | string
  ): Events[EventKey][];

  rawListeners<EventKey e***REMOVED***tends keyof Events>(
    event: EventKey | CommonEvents | symbol | string
  ): Events[EventKey][];

  emit<EventKey e***REMOVED***tends keyof Events>(
    event: EventKey | symbol,
    ...args: Parameters<Events[EventKey]>
  ): boolean;

  listenerCount<EventKey e***REMOVED***tends keyof Events>(
    type: EventKey | CommonEvents | symbol | string
  ): number;

  prependListener<EventKey e***REMOVED***tends keyof Events>(event: EventKey, listener: Events[EventKey]): this;
  prependListener(
    event: CommonEvents,
    listener: (eventName: string | symbol, listener: GenericListener) => void
  ): this;
  prependListener(event: string | symbol, listener: GenericListener): this;

  prependOnceListener<EventKey e***REMOVED***tends keyof Events>(
    event: EventKey,
    listener: Events[EventKey]
  ): this;
  prependOnceListener(
    event: CommonEvents,
    listener: (eventName: string | symbol, listener: GenericListener) => void
  ): this;
  prependOnceListener(event: string | symbol, listener: GenericListener): this;

  eventNames(): string[];
  getMa***REMOVED***Listeners(): number;
  setMa***REMOVED***Listeners(n: number): this;
}

/**
 * Typescript type safe event emitter
 * @public
 */

// eslint-disable-ne***REMOVED***t-line @typescript-eslint/no-unsafe-declaration-merging
e***REMOVED***port class TypedEventEmitter<Events e***REMOVED***tends EventsDescription> e***REMOVED***tends EventEmitter {
  /** @internal */
  protected mongoLogger?: MongoLogger;
  /** @internal */
  protected component?: MongoLoggableComponent;
  /** @internal */
  emitAndLog<EventKey e***REMOVED***tends keyof Events>(
    event: EventKey | symbol,
    ...args: Parameters<Events[EventKey]>
  ): void {
    this.emit(event, ...args);
    if (this.component) this.mongoLogger?.debug(this.component, args[0]);
  }
  /** @internal */
  emitAndLogHeartbeat<EventKey e***REMOVED***tends keyof Events>(
    event: EventKey | symbol,
    topologyId: number,
    serverConnectionId?: number | '<monitor>',
    ...args: Parameters<Events[EventKey]>
  ): void {
    this.emit(event, ...args);
    if (this.component) {
      const loggableHeartbeatEvent:
        | LoggableServerHeartbeatFailedEvent
        | LoggableServerHeartbeatSucceededEvent
        | LoggableServerHeartbeatStartedEvent = {
        topologyId: topologyId,
        serverConnectionId: serverConnectionId ?? null,
        ...args[0]
      };
      this.mongoLogger?.debug(this.component, loggableHeartbeatEvent);
    }
  }
  /** @internal */
  emitAndLogCommand<EventKey e***REMOVED***tends keyof Events>(
    monitorCommands: boolean,
    event: EventKey | symbol,
    databaseName: string,
    connectionEstablished: boolean,
    ...args: Parameters<Events[EventKey]>
  ): void {
    if (monitorCommands) {
      this.emit(event, ...args);
    }
    if (connectionEstablished) {
      const loggableCommandEvent:
        | CommandStartedEvent
        | LoggableCommandFailedEvent
        | LoggableCommandSucceededEvent = {
        databaseName: databaseName,
        ...args[0]
      };
      this.mongoLogger?.debug(MongoLoggableComponent.COMMAND, loggableCommandEvent);
    }
  }
}

/** @public */
e***REMOVED***port class CancellationToken e***REMOVED***tends TypedEventEmitter<{ cancel(): void }> {}

/**
 * Helper types for dot-notation filter attributes
 */

/** @public */
e***REMOVED***port type Join<T e***REMOVED***tends unknown[], D e***REMOVED***tends string> = T e***REMOVED***tends []
  ? ''
  : T e***REMOVED***tends [string | number]
    ? `${T[0]}`
    : T e***REMOVED***tends [string | number, ...infer R]
      ? `${T[0]}${D}${Join<R, D>}`
      : string;

/** @public */
e***REMOVED***port type PropertyType<Type, Property e***REMOVED***tends string> = string e***REMOVED***tends Property
  ? unknown
  : Property e***REMOVED***tends keyof Type
    ? Type[Property]
    : Property e***REMOVED***tends `${number}`
      ? Type e***REMOVED***tends ReadonlyArray<infer ArrayType>
        ? ArrayType
        : unknown
      : Property e***REMOVED***tends `${infer Key}.${infer Rest}`
        ? Key e***REMOVED***tends `${number}`
          ? Type e***REMOVED***tends ReadonlyArray<infer ArrayType>
            ? PropertyType<ArrayType, Rest>
            : unknown
          : Key e***REMOVED***tends keyof Type
            ? Type[Key] e***REMOVED***tends Map<string, infer MapType>
              ? MapType
              : PropertyType<Type[Key], Rest>
            : unknown
        : unknown;

/**
 * @public
 * returns tuple of strings (keys to be joined on '.') that represent every path into a schema
 * https://www.mongodb.com/docs/manual/tutorial/query-embedded-documents/
 *
 * @remarks
 * Through testing we determined that a depth of 8 is safe for the typescript compiler
 * and provides reasonable compilation times. This number is otherwise not special and
 * should be changed if issues are found with this level of checking. Beyond this
 * depth any helpers that make use of NestedPaths should devolve to not asserting any
 * type safety on the input.
 */
e***REMOVED***port type NestedPaths<Type, Depth e***REMOVED***tends number[]> = Depth['length'] e***REMOVED***tends 8
  ? []
  : Type e***REMOVED***tends
        | string
        | number
        | bigint
        | boolean
        | Date
        | RegE***REMOVED***p
        | Buffer
        | Uint8Array
        | ((...args: any[]) => any)
        | { _bsontype: string }
    ? []
    : Type e***REMOVED***tends ReadonlyArray<infer ArrayType>
      ? [] | [number, ...NestedPaths<ArrayType, [...Depth, 1]>]
      : Type e***REMOVED***tends Map<string, any>
        ? [string]
        : Type e***REMOVED***tends object
          ? {
              [Key in E***REMOVED***tract<keyof Type, string>]: Type[Key] e***REMOVED***tends Type // type of value e***REMOVED***tends the parent
                ? [Key]
                : // for a recursive union type, the child will never e***REMOVED***tend the parent type.
                  // but the parent will still e***REMOVED***tend the child
                  Type e***REMOVED***tends Type[Key]
                  ? [Key]
                  : Type[Key] e***REMOVED***tends ReadonlyArray<infer ArrayType> // handling recursive types with arrays
                    ? Type e***REMOVED***tends ArrayType // is the type of the parent the same as the type of the array?
                      ? [Key] // yes, it's a recursive array type
                      : // for unions, the child type e***REMOVED***tends the parent
                        ArrayType e***REMOVED***tends Type
                        ? [Key] // we have a recursive array union
                        : // child is an array, but it's not a recursive array
                          [Key, ...NestedPaths<Type[Key], [...Depth, 1]>]
                    : // child is not structured the same as the parent
                      [Key, ...NestedPaths<Type[Key], [...Depth, 1]>] | [Key];
            }[E***REMOVED***tract<keyof Type, string>]
          : [];

/**
 * @public
 * returns keys (strings) for every path into a schema with a value of type
 * https://www.mongodb.com/docs/manual/tutorial/query-embedded-documents/
 */
e***REMOVED***port type NestedPathsOfType<TSchema, Type> = KeysOfAType<
  {
    [Property in Join<NestedPaths<TSchema, []>, '.'>]: PropertyType<TSchema, Property>;
  },
  Type
>;

/**
 * @public
 * @e***REMOVED***perimental
 */
e***REMOVED***port type StrictFilter<TSchema> =
  | Partial<TSchema>
  | ({
      [Property in Join<NestedPaths<WithId<TSchema>, []>, '.'>]?: Condition<
        PropertyType<WithId<TSchema>, Property>
      >;
    } & RootFilterOperators<WithId<TSchema>>);

/**
 * @public
 * @e***REMOVED***perimental
 */
e***REMOVED***port type StrictUpdateFilter<TSchema> = {
  $currentDate?: OnlyFieldsOfType<
    TSchema,
    Date | Timestamp,
    true | { $type: 'date' | 'timestamp' }
  >;
  $inc?: OnlyFieldsOfType<TSchema, NumericType | undefined>;
  $min?: StrictMatchKeysAndValues<TSchema>;
  $ma***REMOVED***?: StrictMatchKeysAndValues<TSchema>;
  $mul?: OnlyFieldsOfType<TSchema, NumericType | undefined>;
  $rename?: Record<string, string>;
  $set?: StrictMatchKeysAndValues<TSchema>;
  $setOnInsert?: StrictMatchKeysAndValues<TSchema>;
  $unset?: OnlyFieldsOfType<TSchema, any, '' | true | 1>;
  $addToSet?: SetFields<TSchema>;
  $pop?: OnlyFieldsOfType<TSchema, ReadonlyArray<any>, 1 | -1>;
  $pull?: PullOperator<TSchema>;
  $push?: PushOperator<TSchema>;
  $pullAll?: PullAllOperator<TSchema>;
  $bit?: OnlyFieldsOfType<
    TSchema,
    NumericType | undefined,
    { and: IntegerType } | { or: IntegerType } | { ***REMOVED***or: IntegerType }
  >;
} & Document;

/**
 * @public
 * @e***REMOVED***perimental
 */
e***REMOVED***port type StrictMatchKeysAndValues<TSchema> = Readonly<
  {
    [Property in Join<NestedPaths<TSchema, []>, '.'>]?: PropertyType<TSchema, Property>;
  } & {
    [Property in `${NestedPathsOfType<TSchema, any[]>}.$${`[${string}]` | ''}`]?: ArrayElement<
      PropertyType<TSchema, Property e***REMOVED***tends `${infer Key}.$${string}` ? Key : never>
    >;
  } & {
    [Property in `${NestedPathsOfType<TSchema, Record<string, any>[]>}.$${
      | `[${string}]`
      | ''}.${string}`]?: any; // Could be further narrowed
  } & Document
>;
