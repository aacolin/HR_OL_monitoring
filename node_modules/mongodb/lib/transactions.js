"use strict";
Object.defineProperty(e***REMOVED***ports, "__esModule", { value: true });
e***REMOVED***ports.Transaction = e***REMOVED***ports.T***REMOVED***nState = void 0;
e***REMOVED***ports.isTransactionCommand = isTransactionCommand;
const error_1 = require("./error");
const read_concern_1 = require("./read_concern");
const read_preference_1 = require("./read_preference");
const write_concern_1 = require("./write_concern");
/** @internal */
e***REMOVED***ports.T***REMOVED***nState = Object.freeze({
    NO_TRANSACTION: 'NO_TRANSACTION',
    STARTING_TRANSACTION: 'STARTING_TRANSACTION',
    TRANSACTION_IN_PROGRESS: 'TRANSACTION_IN_PROGRESS',
    TRANSACTION_COMMITTED: 'TRANSACTION_COMMITTED',
    TRANSACTION_COMMITTED_EMPTY: 'TRANSACTION_COMMITTED_EMPTY',
    TRANSACTION_ABORTED: 'TRANSACTION_ABORTED'
});
const stateMachine = {
    [e***REMOVED***ports.T***REMOVED***nState.NO_TRANSACTION]: [e***REMOVED***ports.T***REMOVED***nState.NO_TRANSACTION, e***REMOVED***ports.T***REMOVED***nState.STARTING_TRANSACTION],
    [e***REMOVED***ports.T***REMOVED***nState.STARTING_TRANSACTION]: [
        e***REMOVED***ports.T***REMOVED***nState.TRANSACTION_IN_PROGRESS,
        e***REMOVED***ports.T***REMOVED***nState.TRANSACTION_COMMITTED,
        e***REMOVED***ports.T***REMOVED***nState.TRANSACTION_COMMITTED_EMPTY,
        e***REMOVED***ports.T***REMOVED***nState.TRANSACTION_ABORTED
    ],
    [e***REMOVED***ports.T***REMOVED***nState.TRANSACTION_IN_PROGRESS]: [
        e***REMOVED***ports.T***REMOVED***nState.TRANSACTION_IN_PROGRESS,
        e***REMOVED***ports.T***REMOVED***nState.TRANSACTION_COMMITTED,
        e***REMOVED***ports.T***REMOVED***nState.TRANSACTION_ABORTED
    ],
    [e***REMOVED***ports.T***REMOVED***nState.TRANSACTION_COMMITTED]: [
        e***REMOVED***ports.T***REMOVED***nState.TRANSACTION_COMMITTED,
        e***REMOVED***ports.T***REMOVED***nState.TRANSACTION_COMMITTED_EMPTY,
        e***REMOVED***ports.T***REMOVED***nState.STARTING_TRANSACTION,
        e***REMOVED***ports.T***REMOVED***nState.NO_TRANSACTION
    ],
    [e***REMOVED***ports.T***REMOVED***nState.TRANSACTION_ABORTED]: [e***REMOVED***ports.T***REMOVED***nState.STARTING_TRANSACTION, e***REMOVED***ports.T***REMOVED***nState.NO_TRANSACTION],
    [e***REMOVED***ports.T***REMOVED***nState.TRANSACTION_COMMITTED_EMPTY]: [
        e***REMOVED***ports.T***REMOVED***nState.TRANSACTION_COMMITTED_EMPTY,
        e***REMOVED***ports.T***REMOVED***nState.NO_TRANSACTION
    ]
};
const ACTIVE_STATES = new Set([
    e***REMOVED***ports.T***REMOVED***nState.STARTING_TRANSACTION,
    e***REMOVED***ports.T***REMOVED***nState.TRANSACTION_IN_PROGRESS
]);
const COMMITTED_STATES = new Set([
    e***REMOVED***ports.T***REMOVED***nState.TRANSACTION_COMMITTED,
    e***REMOVED***ports.T***REMOVED***nState.TRANSACTION_COMMITTED_EMPTY,
    e***REMOVED***ports.T***REMOVED***nState.TRANSACTION_ABORTED
]);
/**
 * @public
 * A class maintaining state related to a server transaction. Internal Only
 */
class Transaction {
    /** Create a transaction @internal */
    constructor(options) {
        options = options ?? {};
        this.state = e***REMOVED***ports.T***REMOVED***nState.NO_TRANSACTION;
        this.options = {};
        const writeConcern = write_concern_1.WriteConcern.fromOptions(options);
        if (writeConcern) {
            if (writeConcern.w === 0) {
                throw new error_1.MongoTransactionError('Transactions do not support unacknowledged write concern');
            }
            this.options.writeConcern = writeConcern;
        }
        if (options.readConcern) {
            this.options.readConcern = read_concern_1.ReadConcern.fromOptions(options);
        }
        if (options.readPreference) {
            this.options.readPreference = read_preference_1.ReadPreference.fromOptions(options);
        }
        if (options.ma***REMOVED***CommitTimeMS) {
            this.options.ma***REMOVED***TimeMS = options.ma***REMOVED***CommitTimeMS;
        }
        // TODO: This isn't technically necessary
        this._pinnedServer = undefined;
        this._recoveryToken = undefined;
    }
    /** @internal */
    get server() {
        return this._pinnedServer;
    }
    get recoveryToken() {
        return this._recoveryToken;
    }
    get isPinned() {
        return !!this.server;
    }
    /** @returns Whether the transaction has started */
    get isStarting() {
        return this.state === e***REMOVED***ports.T***REMOVED***nState.STARTING_TRANSACTION;
    }
    /**
     * @returns Whether this session is presently in a transaction
     */
    get isActive() {
        return ACTIVE_STATES.has(this.state);
    }
    get isCommitted() {
        return COMMITTED_STATES.has(this.state);
    }
    /**
     * Transition the transaction in the state machine
     * @internal
     * @param ne***REMOVED***tState - The new state to transition to
     */
    transition(ne***REMOVED***tState) {
        const ne***REMOVED***tStates = stateMachine[this.state];
        if (ne***REMOVED***tStates && ne***REMOVED***tStates.includes(ne***REMOVED***tState)) {
            this.state = ne***REMOVED***tState;
            if (this.state === e***REMOVED***ports.T***REMOVED***nState.NO_TRANSACTION ||
                this.state === e***REMOVED***ports.T***REMOVED***nState.STARTING_TRANSACTION ||
                this.state === e***REMOVED***ports.T***REMOVED***nState.TRANSACTION_ABORTED) {
                this.unpinServer();
            }
            return;
        }
        throw new error_1.MongoRuntimeError(`Attempted illegal state transition from [${this.state}] to [${ne***REMOVED***tState}]`);
    }
    /** @internal */
    pinServer(server) {
        if (this.isActive) {
            this._pinnedServer = server;
        }
    }
    /** @internal */
    unpinServer() {
        this._pinnedServer = undefined;
    }
}
e***REMOVED***ports.Transaction = Transaction;
function isTransactionCommand(command) {
    return !!(command.commitTransaction || command.abortTransaction);
}
//# sourceMappingURL=transactions.js.map