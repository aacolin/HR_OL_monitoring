"use strict";
Object.defineProperty(e***REMOVED***ports, "__esModule", { value: true });
e***REMOVED***ports.buildReplaceOneOperation = e***REMOVED***ports.buildUpdateManyOperation = e***REMOVED***ports.buildUpdateOneOperation = e***REMOVED***ports.buildDeleteManyOperation = e***REMOVED***ports.buildDeleteOneOperation = e***REMOVED***ports.buildInsertOneOperation = e***REMOVED***ports.ClientBulkWriteCommandBuilder = void 0;
e***REMOVED***ports.buildOperation = buildOperation;
const bson_1 = require("../../bson");
const commands_1 = require("../../cmap/commands");
const error_1 = require("../../error");
const utils_1 = require("../../utils");
/**
 * The bytes overhead for the e***REMOVED***tra fields added post command generation.
 */
const MESSAGE_OVERHEAD_BYTES = 1000;
/** @internal */
class ClientBulkWriteCommandBuilder {
    /**
     * Create the command builder.
     * @param models - The client write models.
     */
    constructor(models, options, pkFactory) {
        this.models = models;
        this.options = options;
        this.pkFactory = pkFactory ?? utils_1.DEFAULT_PK_FACTORY;
        this.currentModelInde***REMOVED*** = 0;
        this.previousModelInde***REMOVED*** = 0;
        this.lastOperations = [];
        this.isBatchRetryable = true;
    }
    /**
     * Gets the errorsOnly value for the command, which is the inverse of the
     * user provided verboseResults option. Defaults to true.
     */
    get errorsOnly() {
        if ('verboseResults' in this.options) {
            return !this.options.verboseResults;
        }
        return true;
    }
    /**
     * Determines if there is another batch to process.
     * @returns True if not all batches have been built.
     */
    hasNe***REMOVED***tBatch() {
        return this.currentModelInde***REMOVED*** < this.models.length;
    }
    /**
     * When we need to retry a command we need to set the current
     * model inde***REMOVED*** back to its previous value.
     */
    resetBatch() {
        this.currentModelInde***REMOVED*** = this.previousModelInde***REMOVED***;
        return true;
    }
    /**
     * Build a single batch of a client bulk write command.
     * @param ma***REMOVED***MessageSizeBytes - The ma***REMOVED*** message size in bytes.
     * @param ma***REMOVED***WriteBatchSize - The ma***REMOVED*** write batch size.
     * @returns The client bulk write command.
     */
    buildBatch(ma***REMOVED***MessageSizeBytes, ma***REMOVED***WriteBatchSize, ma***REMOVED***BsonObjectSize) {
        // We start by assuming the batch has no multi-updates, so it is retryable
        // until we find them.
        this.isBatchRetryable = true;
        let commandLength = 0;
        let currentNamespaceInde***REMOVED*** = 0;
        const command = this.baseCommand();
        const namespaces = new Map();
        // In the case of retries we need to mark where we started this batch.
        this.previousModelInde***REMOVED*** = this.currentModelInde***REMOVED***;
        while (this.currentModelInde***REMOVED*** < this.models.length) {
            const model = this.models[this.currentModelInde***REMOVED***];
            const ns = model.namespace;
            const nsInde***REMOVED*** = namespaces.get(ns);
            // Multi updates are not retryable.
            if (model.name === 'deleteMany' || model.name === 'updateMany') {
                this.isBatchRetryable = false;
            }
            if (nsInde***REMOVED*** != null) {
                // Build the operation and serialize it to get the bytes buffer.
                const operation = buildOperation(model, nsInde***REMOVED***, this.pkFactory);
                let operationBuffer;
                try {
                    operationBuffer = bson_1.BSON.serialize(operation);
                }
                catch (cause) {
                    throw new error_1.MongoInvalidArgumentError(`Could not serialize operation to BSON`, { cause });
                }
                validateBufferSize('ops', operationBuffer, ma***REMOVED***BsonObjectSize);
                // Check if the operation buffer can fit in the command. If it can,
                // then add the operation to the document sequence and increment the
                // current length as long as the ops don't e***REMOVED***ceed the ma***REMOVED***WriteBatchSize.
                if (commandLength + operationBuffer.length < ma***REMOVED***MessageSizeBytes &&
                    command.ops.documents.length < ma***REMOVED***WriteBatchSize) {
                    // Pushing to the ops document sequence returns the total byte length of the document sequence.
                    commandLength = MESSAGE_OVERHEAD_BYTES + command.ops.push(operation, operationBuffer);
                    // Increment the builder's current model inde***REMOVED***.
                    this.currentModelInde***REMOVED***++;
                }
                else {
                    // The operation cannot fit in the current command and will need to
                    // go in the ne***REMOVED***t batch. E***REMOVED***it the loop.
                    break;
                }
            }
            else {
                // The namespace is not already in the nsInfo so we will set it in the map, and
                // construct our nsInfo and ops documents and buffers.
                namespaces.set(ns, currentNamespaceInde***REMOVED***);
                const nsInfo = { ns: ns };
                const operation = buildOperation(model, currentNamespaceInde***REMOVED***, this.pkFactory);
                let nsInfoBuffer;
                let operationBuffer;
                try {
                    nsInfoBuffer = bson_1.BSON.serialize(nsInfo);
                    operationBuffer = bson_1.BSON.serialize(operation);
                }
                catch (cause) {
                    throw new error_1.MongoInvalidArgumentError(`Could not serialize ns info to BSON`, { cause });
                }
                validateBufferSize('nsInfo', nsInfoBuffer, ma***REMOVED***BsonObjectSize);
                validateBufferSize('ops', operationBuffer, ma***REMOVED***BsonObjectSize);
                // Check if the operation and nsInfo buffers can fit in the command. If they
                // can, then add the operation and nsInfo to their respective document
                // sequences and increment the current length as long as the ops don't e***REMOVED***ceed
                // the ma***REMOVED***WriteBatchSize.
                if (commandLength + nsInfoBuffer.length + operationBuffer.length < ma***REMOVED***MessageSizeBytes &&
                    command.ops.documents.length < ma***REMOVED***WriteBatchSize) {
                    // Pushing to the ops document sequence returns the total byte length of the document sequence.
                    commandLength =
                        MESSAGE_OVERHEAD_BYTES +
                            command.nsInfo.push(nsInfo, nsInfoBuffer) +
                            command.ops.push(operation, operationBuffer);
                    // We've added a new namespace, increment the namespace inde***REMOVED***.
                    currentNamespaceInde***REMOVED***++;
                    // Increment the builder's current model inde***REMOVED***.
                    this.currentModelInde***REMOVED***++;
                }
                else {
                    // The operation cannot fit in the current command and will need to
                    // go in the ne***REMOVED***t batch. E***REMOVED***it the loop.
                    break;
                }
            }
        }
        // Set the last operations and return the command.
        this.lastOperations = command.ops.documents;
        return command;
    }
    baseCommand() {
        const command = {
            bulkWrite: 1,
            errorsOnly: this.errorsOnly,
            ordered: this.options.ordered ?? true,
            ops: new commands_1.DocumentSequence('ops'),
            nsInfo: new commands_1.DocumentSequence('nsInfo')
        };
        // Add bypassDocumentValidation if it was present in the options.
        if (this.options.bypassDocumentValidation != null) {
            command.bypassDocumentValidation = this.options.bypassDocumentValidation;
        }
        // Add let if it was present in the options.
        if (this.options.let) {
            command.let = this.options.let;
        }
        // we check for undefined specifically here to allow falsy values
        // eslint-disable-ne***REMOVED***t-line no-restricted-synta***REMOVED***
        if (this.options.comment !== undefined) {
            command.comment = this.options.comment;
        }
        return command;
    }
}
e***REMOVED***ports.ClientBulkWriteCommandBuilder = ClientBulkWriteCommandBuilder;
function validateBufferSize(name, buffer, ma***REMOVED***BsonObjectSize) {
    if (buffer.length > ma***REMOVED***BsonObjectSize) {
        throw new error_1.MongoInvalidArgumentError(`Client bulk write operation ${name} of length ${buffer.length} e***REMOVED***ceeds the ma***REMOVED*** bson object size of ${ma***REMOVED***BsonObjectSize}`);
    }
}
/**
 * Build the insert one operation.
 * @param model - The insert one model.
 * @param inde***REMOVED*** - The namespace inde***REMOVED***.
 * @returns the operation.
 */
const buildInsertOneOperation = (model, inde***REMOVED***, pkFactory) => {
    const document = {
        insert: inde***REMOVED***,
        document: model.document
    };
    document.document._id = model.document._id ?? pkFactory.createPk();
    return document;
};
e***REMOVED***ports.buildInsertOneOperation = buildInsertOneOperation;
/**
 * Build the delete one operation.
 * @param model - The insert many model.
 * @param inde***REMOVED*** - The namespace inde***REMOVED***.
 * @returns the operation.
 */
const buildDeleteOneOperation = (model, inde***REMOVED***) => {
    return createDeleteOperation(model, inde***REMOVED***, false);
};
e***REMOVED***ports.buildDeleteOneOperation = buildDeleteOneOperation;
/**
 * Build the delete many operation.
 * @param model - The delete many model.
 * @param inde***REMOVED*** - The namespace inde***REMOVED***.
 * @returns the operation.
 */
const buildDeleteManyOperation = (model, inde***REMOVED***) => {
    return createDeleteOperation(model, inde***REMOVED***, true);
};
e***REMOVED***ports.buildDeleteManyOperation = buildDeleteManyOperation;
/**
 * Creates a delete operation based on the parameters.
 */
function createDeleteOperation(model, inde***REMOVED***, multi) {
    const document = {
        delete: inde***REMOVED***,
        multi: multi,
        filter: model.filter
    };
    if (model.hint) {
        document.hint = model.hint;
    }
    if (model.collation) {
        document.collation = model.collation;
    }
    return document;
}
/**
 * Build the update one operation.
 * @param model - The update one model.
 * @param inde***REMOVED*** - The namespace inde***REMOVED***.
 * @returns the operation.
 */
const buildUpdateOneOperation = (model, inde***REMOVED***) => {
    return createUpdateOperation(model, inde***REMOVED***, false);
};
e***REMOVED***ports.buildUpdateOneOperation = buildUpdateOneOperation;
/**
 * Build the update many operation.
 * @param model - The update many model.
 * @param inde***REMOVED*** - The namespace inde***REMOVED***.
 * @returns the operation.
 */
const buildUpdateManyOperation = (model, inde***REMOVED***) => {
    return createUpdateOperation(model, inde***REMOVED***, true);
};
e***REMOVED***ports.buildUpdateManyOperation = buildUpdateManyOperation;
/**
 * Validate the update document.
 * @param update - The update document.
 */
function validateUpdate(update) {
    if (!(0, utils_1.hasAtomicOperators)(update)) {
        throw new error_1.MongoAPIError('Client bulk write update models must only contain atomic modifiers (start with $) and must not be empty.');
    }
}
/**
 * Creates a delete operation based on the parameters.
 */
function createUpdateOperation(model, inde***REMOVED***, multi) {
    // Update documents provided in UpdateOne and UpdateMany write models are
    // required only to contain atomic modifiers (i.e. keys that start with "$").
    // Drivers MUST throw an error if an update document is empty or if the
    // document's first key does not start with "$".
    validateUpdate(model.update);
    const document = {
        update: inde***REMOVED***,
        multi: multi,
        filter: model.filter,
        updateMods: model.update
    };
    if (model.hint) {
        document.hint = model.hint;
    }
    if (model.upsert) {
        document.upsert = model.upsert;
    }
    if (model.arrayFilters) {
        document.arrayFilters = model.arrayFilters;
    }
    if (model.collation) {
        document.collation = model.collation;
    }
    return document;
}
/**
 * Build the replace one operation.
 * @param model - The replace one model.
 * @param inde***REMOVED*** - The namespace inde***REMOVED***.
 * @returns the operation.
 */
const buildReplaceOneOperation = (model, inde***REMOVED***) => {
    if ((0, utils_1.hasAtomicOperators)(model.replacement)) {
        throw new error_1.MongoAPIError('Client bulk write replace models must not contain atomic modifiers (start with $) and must not be empty.');
    }
    const document = {
        update: inde***REMOVED***,
        multi: false,
        filter: model.filter,
        updateMods: model.replacement
    };
    if (model.hint) {
        document.hint = model.hint;
    }
    if (model.upsert) {
        document.upsert = model.upsert;
    }
    if (model.collation) {
        document.collation = model.collation;
    }
    return document;
};
e***REMOVED***ports.buildReplaceOneOperation = buildReplaceOneOperation;
/** @internal */
function buildOperation(model, inde***REMOVED***, pkFactory) {
    switch (model.name) {
        case 'insertOne':
            return (0, e***REMOVED***ports.buildInsertOneOperation)(model, inde***REMOVED***, pkFactory);
        case 'deleteOne':
            return (0, e***REMOVED***ports.buildDeleteOneOperation)(model, inde***REMOVED***);
        case 'deleteMany':
            return (0, e***REMOVED***ports.buildDeleteManyOperation)(model, inde***REMOVED***);
        case 'updateOne':
            return (0, e***REMOVED***ports.buildUpdateOneOperation)(model, inde***REMOVED***);
        case 'updateMany':
            return (0, e***REMOVED***ports.buildUpdateManyOperation)(model, inde***REMOVED***);
        case 'replaceOne':
            return (0, e***REMOVED***ports.buildReplaceOneOperation)(model, inde***REMOVED***);
    }
}
//# sourceMappingURL=command_builder.js.map