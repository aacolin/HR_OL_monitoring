"use strict";
Object.defineProperty(e***REMOVED***ports, "__esModule", { value: true });
e***REMOVED***ports.ServerType = e***REMOVED***ports.TopologyType = e***REMOVED***ports.STATE_CONNECTED = e***REMOVED***ports.STATE_CONNECTING = e***REMOVED***ports.STATE_CLOSED = e***REMOVED***ports.STATE_CLOSING = void 0;
e***REMOVED***ports.drainTimerQueue = drainTimerQueue;
e***REMOVED***ports._advanceClusterTime = _advanceClusterTime;
const timers_1 = require("timers");
// shared state names
e***REMOVED***ports.STATE_CLOSING = 'closing';
e***REMOVED***ports.STATE_CLOSED = 'closed';
e***REMOVED***ports.STATE_CONNECTING = 'connecting';
e***REMOVED***ports.STATE_CONNECTED = 'connected';
/**
 * An enumeration of topology types we know about
 * @public
 */
e***REMOVED***ports.TopologyType = Object.freeze({
    Single: 'Single',
    ReplicaSetNoPrimary: 'ReplicaSetNoPrimary',
    ReplicaSetWithPrimary: 'ReplicaSetWithPrimary',
    Sharded: 'Sharded',
    Unknown: 'Unknown',
    LoadBalanced: 'LoadBalanced'
});
/**
 * An enumeration of server types we know about
 * @public
 */
e***REMOVED***ports.ServerType = Object.freeze({
    Standalone: 'Standalone',
    Mongos: 'Mongos',
    PossiblePrimary: 'PossiblePrimary',
    RSPrimary: 'RSPrimary',
    RSSecondary: 'RSSecondary',
    RSArbiter: 'RSArbiter',
    RSOther: 'RSOther',
    RSGhost: 'RSGhost',
    Unknown: 'Unknown',
    LoadBalancer: 'LoadBalancer'
});
/** @internal */
function drainTimerQueue(queue) {
    queue.forEach(timers_1.clearTimeout);
    queue.clear();
}
/** Shared function to determine clusterTime for a given topology or session */
function _advanceClusterTime(entity, $clusterTime) {
    if (entity.clusterTime == null) {
        entity.clusterTime = $clusterTime;
    }
    else {
        if ($clusterTime.clusterTime.greaterThan(entity.clusterTime.clusterTime)) {
            entity.clusterTime = $clusterTime;
        }
    }
}
//# sourceMappingURL=common.js.map