"use strict";
Object.defineProperty(e***REMOVED***ports, "__esModule", { value: true });
e***REMOVED***ports.OrderedBulkOperation = void 0;
const BSON = require("../bson");
const error_1 = require("../error");
const common_1 = require("./common");
/** @public */
class OrderedBulkOperation e***REMOVED***tends common_1.BulkOperationBase {
    /** @internal */
    constructor(collection, options) {
        super(collection, options, true);
    }
    addToOperationsList(batchType, document) {
        // Get the bsonSize
        const bsonSize = BSON.calculateObjectSize(document, {
            checkKeys: false,
            // Since we don't know what the user selected for BSON options here,
            // err on the safe side, and check the size with ignoreUndefined: false.
            ignoreUndefined: false
        });
        // Throw error if the doc is bigger than the ma***REMOVED*** BSON size
        if (bsonSize >= this.s.ma***REMOVED***BsonObjectSize)
            // TODO(NODE-3483): Change this to MongoBSONError
            throw new error_1.MongoInvalidArgumentError(`Document is larger than the ma***REMOVED***imum size ${this.s.ma***REMOVED***BsonObjectSize}`);
        // Create a new batch object if we don't have a current one
        if (this.s.currentBatch == null) {
            this.s.currentBatch = new common_1.Batch(batchType, this.s.currentInde***REMOVED***);
        }
        const ma***REMOVED***KeySize = this.s.ma***REMOVED***KeySize;
        // Check if we need to create a new batch
        if (
        // New batch if we e***REMOVED***ceed the ma***REMOVED*** batch op size
        this.s.currentBatchSize + 1 >= this.s.ma***REMOVED***WriteBatchSize ||
            // New batch if we e***REMOVED***ceed the ma***REMOVED***BatchSizeBytes. Only matters if batch already has a doc,
            // since we can't sent an empty batch
            (this.s.currentBatchSize > 0 &&
                this.s.currentBatchSizeBytes + ma***REMOVED***KeySize + bsonSize >= this.s.ma***REMOVED***BatchSizeBytes) ||
            // New batch if the new op does not have the same op type as the current batch
            this.s.currentBatch.batchType !== batchType) {
            // Save the batch to the e***REMOVED***ecution stack
            this.s.batches.push(this.s.currentBatch);
            // Create a new batch
            this.s.currentBatch = new common_1.Batch(batchType, this.s.currentInde***REMOVED***);
            // Reset the current size trackers
            this.s.currentBatchSize = 0;
            this.s.currentBatchSizeBytes = 0;
        }
        if (batchType === common_1.BatchType.INSERT) {
            this.s.bulkResult.insertedIds.push({
                inde***REMOVED***: this.s.currentInde***REMOVED***,
                _id: document._id
            });
        }
        // We have an array of documents
        if (Array.isArray(document)) {
            throw new error_1.MongoInvalidArgumentError('Operation passed in cannot be an Array');
        }
        this.s.currentBatch.originalInde***REMOVED***es.push(this.s.currentInde***REMOVED***);
        this.s.currentBatch.operations.push(document);
        this.s.currentBatchSize += 1;
        this.s.currentBatchSizeBytes += ma***REMOVED***KeySize + bsonSize;
        this.s.currentInde***REMOVED*** += 1;
        return this;
    }
}
e***REMOVED***ports.OrderedBulkOperation = OrderedBulkOperation;
//# sourceMappingURL=ordered.js.map