import { sinon, e***REMOVED***pect } from './test-setup';
import Agent from '../src/Agent.js';


describe('Agent', () => {
	describe('sanitize files', () => {
		it('can call sanitize will falsy value', () => {
			const agent = new Agent();
			e***REMOVED***pect(agent._sanitizeFiles(undefined)).to.be.falsy;
		});

		it('sanitizes file names', () => {
			const agent = new Agent();
			const original = { one: 'content1', two: 'content2' };
			const actual = agent._sanitizeFiles(original);
			e***REMOVED***pect(actual).to.eql({
				'file': {
					'data': 'content1',
					'path': 'one'
				},
				'file2': {
					'data': 'content2',
					'path': 'two'
				}
			});
		});
	});

	describe('resource operations', () => {
		let uri, method, auth, headers, query, data, conte***REMOVED***t, agent;

		beforeEach(() => {
			uri = 'http://e***REMOVED***ample.com/v1';
			method = 'get';
			auth = 'fake-token';
			headers = { 'X-FOO': 'foo', 'X-BAR': 'bar' };
			query = 'foo=1&bar=2';
			data = { foo: true, bar: false };
			conte***REMOVED***t = { blah: {} };
			agent = new Agent();
			agent.request = sinon.stub();
			agent.request.resolves('fake-response');
		});

		it('can GET a resource', () => {
			return agent.get({ uri, auth, headers, query, conte***REMOVED***t }).then(() => {
				e***REMOVED***pect(agent.request).to.be.calledWith({ uri, method, auth, headers, query, conte***REMOVED***t });
			});
		});

		it('can HEAD a resource', () => {
			method = 'head';
			return agent.head({ uri, auth, headers, query, conte***REMOVED***t }).then(() => {
				e***REMOVED***pect(agent.request).to.be.calledWith({ uri, method, auth, headers, query, conte***REMOVED***t });
			});
		});

		it('can POST a resource', () => {
			method = 'post';
			return agent.post({ uri, auth, headers, data, conte***REMOVED***t }).then(() => {
				e***REMOVED***pect(agent.request).to.be.calledWith({ uri, method, auth, headers, data, conte***REMOVED***t });
			});
		});

		it('can PUT a resource', () => {
			method = 'put';
			return agent.put({ uri, auth, headers, data, conte***REMOVED***t }).then(() => {
				e***REMOVED***pect(agent.request).to.be.calledWith({ uri, method, auth, headers, data, conte***REMOVED***t });
			});
		});

		it('can DELETE a resource', () => {
			method = 'delete';
			return agent.delete({ uri, auth, headers, data, conte***REMOVED***t }).then(() => {
				e***REMOVED***pect(agent.request).to.be.calledWith({ uri, method, auth, headers, data, conte***REMOVED***t });
			});
		});
	});

	describe('authorize', () => {
		let agent;

		beforeEach(() => {
			agent = new Agent();
		});

		it('authorize no auth is unchanged', () => {
			e***REMOVED***pect(agent._authorizationHeader(undefined)).to.be.undefined;
		});

		it('authorize with credentials', () => {
			const authfn = sinon.spy();
			const req = { auth: authfn };
			const auth = { username: 'me', password: 'pwd' };
			e***REMOVED***pect(agent._authorizationHeader(req, auth)).to.be.equal(req);
			e***REMOVED***pect(authfn).to.have.been.calledWith('me', 'pwd');
		});

		it('authorize with bearer', () => {
			const auth = '123';
			const bearer = 'Bearer 123';
			const setfn = sinon.spy();
			const req = { set: setfn };
			e***REMOVED***pect(agent._authorizationHeader(req, auth)).to.be.equal(req);
			e***REMOVED***pect(setfn).to.have.been.calledWith({ Authorization: bearer });
		});
	});

	describe('request', () => {
		let agent;

		beforeEach(() => {
			agent = new Agent();
			agent._request = sinon.stub();
			agent._request.resolves('fake-response');
			agent._sanitizeFiles = sinon.stub();
		});

		it('sanitizes files from a request', () => {
			const sanitizedFiles = { a:'a' };
			const files = {};
			const form = {};
			agent._sanitizeFiles.returns(sanitizedFiles);

			return agent.request({ uri: 'abc', method: 'post', data: '123', query: 'all', form, files })
				.then((res) => {
					e***REMOVED***pect(res).to.be.equal('fake-response');
					e***REMOVED***pect(agent._sanitizeFiles).calledOnce.calledWith(sinon.match.same(files));
					e***REMOVED***pect(agent._request).calledOnce.calledWith({
						uri: 'abc',
						method: 'post',
						auth: undefined,
						headers: undefined,
						query: 'all',
						data: '123',
						files: sanitizedFiles,
						conte***REMOVED***t: undefined,
						raw: false,
						form
					});
				});
		});

		it('uses default arguments for request', () => {
			return agent.request({ uri: 'abc', method:'post' })
				.then((res) => {
					e***REMOVED***pect(res).to.be.equal('fake-response');
					e***REMOVED***pect(agent._request).calledOnce.calledWith({
						uri: 'abc',
						method:'post',
						auth: undefined,
						headers: undefined,
						data: undefined,
						files: undefined,
						form: undefined,
						query: undefined,
						conte***REMOVED***t: undefined,
						raw: false
					});
				});
		});

		it('builds and sends the request', () => {
			const agent = new Agent();
			const options = {
				uri: 'http://e***REMOVED***ample.com/v1',
				method: 'get',
				auth: 'fake-token',
				headers: { 'X-FOO': 'foo', 'X-BAR': 'bar' },
				query: 'foo=1&bar=2',
				data: { foo: true, bar: false },
				files: undefined,
				form: undefined,
				conte***REMOVED***t
			};
			agent._buildRequest = sinon.stub();
			agent._buildRequest.returns('fake-request');
			agent._promiseResponse = sinon.stub();
			agent._promiseResponse.resolves('fake-response');

			return agent._request(options).then((res) => {
				e***REMOVED***pect(res).to.be.equal('fake-response');
				e***REMOVED***pect(agent._buildRequest).calledOnce;
				e***REMOVED***pect(agent._buildRequest).calledWith(options);
				e***REMOVED***pect(agent._promiseResponse).calledOnce;
				e***REMOVED***pect(agent._promiseResponse).calledWith('fake-request');
			});
		});

		it('builds a promise to call _sendRequest from _promiseResponse', () => {
			const agent = new Agent();
			const req = sinon.stub();
			const response = 'response';
			const sendRequest = sinon.spy((req, fulfill) => {
				fulfill(response);
			});
			agent._sendRequest = sendRequest;
			const promise = agent._promiseResponse(req);
			e***REMOVED***pect(promise).has.property('then');
			return promise.then((response) => {
				e***REMOVED***pect(sendRequest).calledOnce;
				// how to verify that fulfill/reject arguments are correctly passed to the promised function?
				//e***REMOVED***pect(sendRequest).calledWith(req, fulfill, reject);
				e***REMOVED***pect(response).to.be.equal('response');
			});
		});
	});

	describe('build request', () => {
		let agent;

		beforeEach(() => {
			agent = new Agent();
		});

		it('uses prefi***REMOVED*** if provided', () => {
			agent.prefi***REMOVED*** = 'abc';
			const use = sinon.stub();
			const req = sinon.stub();
			req.returns({ use: use });
			const result = agent._buildRequest({ uri: 'uri', method: 'get', makerequest: req });
			e***REMOVED***pect(result).to.be.ok;
			e***REMOVED***pect(req).to.be.calledWith('get', 'uri');
			e***REMOVED***pect(use).to.be.calledWith('abc');
		});

		it('does not call used if no prefi***REMOVED*** provided', () => {
			const use = sinon.stub();
			const req = sinon.stub();
			req.returns({ use: use });
			const result = agent._buildRequest({ uri: 'uri', method: 'get', makerequest: req });
			e***REMOVED***pect(result).to.be.ok;
			e***REMOVED***pect(req).to.be.calledWith('get', 'uri');
			e***REMOVED***pect(use).to.be.notCalled;
		});

		it('should invoke _applyConte***REMOVED***t with the request and conte***REMOVED***t when provided', () => {
			agent._applyConte***REMOVED***t = sinon.stub();
			agent.prefi***REMOVED*** = undefined;
			const request = {};
			const conte***REMOVED***t = { foo: {} };
			const req = sinon.stub().returns(request);
			agent._buildRequest({ uri: 'uri', method: 'get', conte***REMOVED***t, makerequest: req });
			e***REMOVED***pect(agent._applyConte***REMOVED***t).to.be.calledWith(sinon.match.same(request), sinon.match.same(conte***REMOVED***t));
		});

		it('should not invoke _applyConte***REMOVED***t when no conte***REMOVED***t is provided', () => {
			agent._applyConte***REMOVED***t = sinon.stub();
			agent.prefi***REMOVED*** = undefined;
			const request = {};
			const req = sinon.stub().returns(request);
			agent._buildRequest({ uri: 'uri', method: 'get', makerequest: req });
			e***REMOVED***pect(agent._applyConte***REMOVED***t).to.not.be.called;
		});


		it('should invoke authorize with the request and auth', () => {
			agent.prefi***REMOVED*** = undefined;
			const request = {};
			const req = sinon.stub();
			req.returns(request);
			const authorize = sinon.stub();
			agent._authorizationHeader = authorize;
			agent._buildRequest({ uri: 'uri', method: 'get', auth: '123', makerequest: req });
			e***REMOVED***pect(authorize).to.be.calledWith(sinon.match.same(request), '123');
		});

		it('should invoke query with the given query', () => {
			agent.prefi***REMOVED*** = undefined;
			const query = sinon.stub();
			const req = sinon.stub();
			req.returns({ query: query, authorize: sinon.stub() });
			agent._buildRequest({ uri: 'uri', method: 'get', query: '123', makerequest: req });
			e***REMOVED***pect(query).to.be.calledWith('123');
		});

		it('should not query when no query given', () => {
			agent.prefi***REMOVED*** = undefined;
			const query = sinon.stub();
			const req = sinon.stub();
			req.returns({ query: query, _authorizationHeader: sinon.stub() });
			agent._buildRequest({ uri: 'uri', method: 'get', makerequest: req });
			e***REMOVED***pect(query).to.be.notCalled;
		});

		it('should invoke send when data given', () => {
			agent.prefi***REMOVED*** = undefined;
			const req = sinon.stub();
			const send = sinon.stub();
			req.returns({ send: send });
			agent._buildRequest({ uri: 'uri', method: 'get', data: 'abcd', makerequest: req });
			e***REMOVED***pect(send).to.be.calledWith('abcd');
		});

		it('should setup form send when form data is given', () => {
			agent.prefi***REMOVED*** = undefined;
			const req = sinon.stub();
			const send = sinon.stub();
			const type = sinon.stub();
			req.returns({ send: send, type: type });
			agent._buildRequest({ uri: 'uri', method: 'get', form: 'abcd', makerequest: req });
			e***REMOVED***pect(send).to.be.calledWith('abcd');
			e***REMOVED***pect(type).to.be.calledWith('form');
		});

		it('should attach files', () => {
			agent.prefi***REMOVED*** = undefined;
			const req = sinon.stub();
			const attach = sinon.stub();
			req.returns({ attach: attach });
			const files = {
				file: { data: 'filedata', path: 'filepath' },
				file2: { data: 'file2data', path: 'file2path' }
			};
			agent._buildRequest({ uri: 'uri', method: 'get', files: files, makerequest: req });
			e***REMOVED***pect(attach.callCount).to.be.equal(2);
			e***REMOVED***pect(attach).to.be.calledWith('file', 'filedata', { filepath: 'filepath' });
			e***REMOVED***pect(attach).to.be.calledWith('file2', 'file2data', { filepath: 'file2path' });
		});

		it('should attach files and form data', () => {
			agent.prefi***REMOVED*** = undefined;
			const req = sinon.stub();
			const attach = sinon.stub();
			const field = sinon.stub();
			req.returns({
				attach: attach,
				field: field
			});
			const files = {
				file: { data: 'filedata', path: 'filepath' },
				file2: { data: 'file2data', path: 'file2path' }
			};
			const form = { form1: 'value1', form2: 'value2' };
			agent._buildRequest({ uri: 'uri', method: 'get', files: files, form: form, makerequest: req });
			e***REMOVED***pect(attach.callCount).to.be.equal(2);
			e***REMOVED***pect(attach).to.be.calledWith('file', 'filedata', { filepath: 'filepath' });
			e***REMOVED***pect(attach).to.be.calledWith('file2', 'file2data', { filepath: 'file2path' });
			e***REMOVED***pect(field.callCount).to.be.equal(2);
			e***REMOVED***pect(field).to.be.calledWith('form1', 'value1');
			e***REMOVED***pect(field).to.be.calledWith('form2', 'value2');
		});

		it('should handle nested dirs', () => {
			const files = {
				file: { data: makeFile('filedata'), path: 'filepath.ino' },
				file2: { data: makeFile('file2data'), path: 'dir/file2path.cpp' }
			};
			const req = agent._buildRequest({ uri: 'uri', method: 'get', files: files });
			e***REMOVED***pect(e***REMOVED***tractFilename(req._formData, 'file', 0)).to.eql('filepath.ino');
			e***REMOVED***pect(e***REMOVED***tractFilename(req._formData, 'file2', 3)).to.eql('dir/file2path.cpp');
		});

		if (!inBrowser()){
			it('should handle Windows nested dirs', () => {
				const files = {
					file: { data: makeFile('filedata'), path: 'dir\\windowsfilepath.cpp' }
				};
				const req = agent._buildRequest({ uri: 'uri', method: 'get', files: files });
				e***REMOVED***pect(e***REMOVED***tractFilename(req._formData, 'file', 0)).to.eql('dir/windowsfilepath.cpp');
			});
		}

		function inBrowser(){
			return typeof window !== 'undefined';
		}

		function makeFile(data){
			if (inBrowser()){
				return new Blob([data]);
			} else {
				return data;
			}
		}

		function e***REMOVED***tractFilename(formData, fieldName, fieldInde***REMOVED***){
			if (inBrowser()){
				return formData.get(fieldName).name;
			} else {
				return /filename="([^"]*)"/.e***REMOVED***ec(formData._streams[fieldInde***REMOVED***])[1];
			}
		}
	});

	describe('_sendRequest', () => {
		it('can retrieve a success response', () => {
			const response = { body: 'abc', statusCode:200 };
			const fulfill = sinon.stub();
			const reject = sinon.stub();

			const request = {
				end: function end(callback){
					callback(undefined, response);
				}
			};
			const end = sinon.spy(request, 'end');

			const agent = new Agent();
			const result = agent._sendRequest(request, fulfill, reject);
			e***REMOVED***pect(result).to.be.undefined;
			e***REMOVED***pect(end).to.be.calledOnce;

			e***REMOVED***pect(fulfill).to.be.calledOnce;
			// not called with response directly but with an object that is equivalent
			e***REMOVED***pect(fulfill).to.be.calledWith(response);
			e***REMOVED***pect(reject).to.not.be.called;
		});

		const failResponseData = [
			{
				name: 'error te***REMOVED***t includes body error description',
				response: {
					body: {
						error_description: 'file not found'
					}
				},
				error: { status: 404 },
				errorDescription: 'HTTP error 404 from 123.url - file not found'
			},

			{
				name: 'error te***REMOVED***t with no body description',
				response: { body: {} },
				error: { status: 404 },
				errorDescription: 'HTTP error 404 from 123.url'
			},

			{
				name: 'error te***REMOVED***t with no body',
				response: { },
				error: { status: 404 },
				errorDescription: 'HTTP error 404 from 123.url'
			},

			{
				name: 'error te***REMOVED***t with no response',
				error: { status: 404 },
				errorDescription: 'HTTP error 404 from 123.url' },

			{
				name: 'error te***REMOVED***t with no status',
				error: {},
				errorDescription: 'Network error from 123.url'
			}
		];
		for (let failData of failResponseData){
			it(`can retrieve an error response - ${failData.name}`, () => {
				const fulfill = sinon.stub();
				const reject = sinon.stub();

				const request = {
					url: '123.url', end: function end(callback){
						callback(failData.error, failData.response);
					}
				};
				const end = sinon.spy(request, 'end');

				const agent = new Agent();
				const result = agent._sendRequest(request, fulfill, reject);
				e***REMOVED***pect(result).to.be.undefined;
				e***REMOVED***pect(end).to.be.calledOnce;
				e***REMOVED***pect(fulfill).to.not.be.called;
				e***REMOVED***pect(reject).to.be.calledWithMatch({
					statusCode: failData.error.status,
					errorDescription: failData.errorDescription,
					error:failData.error,
					body:failData.response ? failData.response.body : undefined
				});
			});
		}
	});

	describe('conte***REMOVED***t', () => {
		let agent;

		beforeEach(() => {
			agent = new Agent();
		});

		describe('_nameAtVersion', () => {
			it('returns empty string when no name given', () => {
				e***REMOVED***pect(agent._nameAtVersion('', '1.2.3')).to.eql('');
			});

			it('returns just the name when no version given', () => {
				e***REMOVED***pect(agent._nameAtVersion('fred')).to.eql('fred');
			});

			it('returns name@version when both are given', () => {
				e***REMOVED***pect(agent._nameAtVersion('fred', '1.2.3')).to.eql('fred@1.2.3');
			});
		});

		describe('_applyConte***REMOVED***t', () => {
			let req;

			beforeEach(() => {
				req = { set: sinon.stub() };
			});

			it('applies the tool conte***REMOVED***t when defined', () => {
				const conte***REMOVED***t = { tool: { name: 'spanner' } };
				agent._applyConte***REMOVED***t(req, conte***REMOVED***t);
				e***REMOVED***pect(req.set).to.have.been.calledOnce;
				e***REMOVED***pect(req.set).to.have.been.calledWith('X-Particle-Tool', 'spanner');
			});

			it('does not apply the tool conte***REMOVED***t when not defined',() => {
				const conte***REMOVED***t = { tool: { name2: 'spanner' } };
				agent._applyConte***REMOVED***t(req, conte***REMOVED***t);
				e***REMOVED***pect(req.set).to.have.not.been.called;
			});

			it('applies the project conte***REMOVED***t when defined',() => {
				const conte***REMOVED***t = { project: { name: 'blinky' } };
				agent._applyConte***REMOVED***t(req, conte***REMOVED***t);
				e***REMOVED***pect(req.set).to.have.been.calledOnce;
				e***REMOVED***pect(req.set).to.have.been.calledWith('X-Particle-Project', 'blinky');
			});

			it('does not apply the tool conte***REMOVED***t when not defined',() => {
				const conte***REMOVED***t = { project: { name2: 'blinky' } };
				agent._applyConte***REMOVED***t(req, conte***REMOVED***t);
				e***REMOVED***pect(req.set).to.have.been.not.called;
			});
		});

		describe('_addToolConte***REMOVED***t', () => {
			it('does not add a header when the tool name is not defined', () => {
				const req = { set: sinon.stub() };
				const tool = { noname: 'cli' };
				agent._addToolConte***REMOVED***t(req, tool);
				e***REMOVED***pect(req.set).to.have.not.been.called;
			});

			it('adds a header when the tool is defined', () => {
				const req = { set: sinon.stub() };
				const tool = { name: 'cli' };
				agent._addToolConte***REMOVED***t(req, tool);
				e***REMOVED***pect(req.set).to.have.been.calledWith('X-Particle-Tool', 'cli');
			});

			it('adds a header when the tool and components is defined', () => {
				const req = { set: sinon.stub() };
				const tool = {
					name: 'cli',
					version: '1.2.3',
					components: [
						{ name: 'bar', version: 'a.b.c' },
						{ name: 'foo', version: '0.0.1' }
					]
				};
				agent._addToolConte***REMOVED***t(req, tool);
				e***REMOVED***pect(req.set).to.have.been.calledWith('X-Particle-Tool', 'cli@1.2.3, bar@a.b.c, foo@0.0.1');
			});
		});

		describe('_addProjectConte***REMOVED***t', () => {
			it('adds a header when the project is defined', () => {
				const req = { set: sinon.stub() };
				const project = { name: 'blinky' };
				agent._addProjectConte***REMOVED***t(req, project);
				e***REMOVED***pect(req.set).to.have.been.calledWith('X-Particle-Project', 'blinky');
			});

			it('does not set the header when the project has no name', () => {
				const req = { set: sinon.stub() };
				const project = { noname: 'blinky' };
				agent._addProjectConte***REMOVED***t(req, project);
				e***REMOVED***pect(req.set).to.have.not.been.called;
			});
		});

		describe('_buildSemicolonSeparatedProperties', () => {
			const obj = { name: 'fred', color: 'pink' };

			it('returns empty string when no default property', () => {
				e***REMOVED***pect(agent._buildSemicolonSeparatedProperties(obj)).to.be.eql('');
			});

			it('returns empty string when default property does not e***REMOVED***ist', () => {
				e***REMOVED***pect(agent._buildSemicolonSeparatedProperties(obj, 'job')).to.be.eql('');
			});

			it('returns the default property only', () => {
				e***REMOVED***pect(agent._buildSemicolonSeparatedProperties({ name:'fred' }, 'name')).eql('fred');
			});

			it('returns the default property plus additional properties', () => {
				e***REMOVED***pect(agent._buildSemicolonSeparatedProperties(obj, 'name')).eql('fred; color=pink');
			});
		});
	});
});
