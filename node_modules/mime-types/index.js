/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict'

/**
 * Module dependencies.
 * @private
 */

var db = require('mime-db')
var e***REMOVED***tname = require('path').e***REMOVED***tname

/**
 * Module variables.
 * @private
 */

var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/
var TEXT_TYPE_REGEXP = /^te***REMOVED***t\//i

/**
 * Module e***REMOVED***ports.
 * @public
 */

e***REMOVED***ports.charset = charset
e***REMOVED***ports.charsets = { lookup: charset }
e***REMOVED***ports.contentType = contentType
e***REMOVED***ports.e***REMOVED***tension = e***REMOVED***tension
e***REMOVED***ports.e***REMOVED***tensions = Object.create(null)
e***REMOVED***ports.lookup = lookup
e***REMOVED***ports.types = Object.create(null)

// Populate the e***REMOVED***tensions/types maps
populateMaps(e***REMOVED***ports.e***REMOVED***tensions, e***REMOVED***ports.types)

/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function charset (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.e***REMOVED***ec(type)
  var mime = match && db[match[1].toLowerCase()]

  if (mime && mime.charset) {
    return mime.charset
  }

  // default te***REMOVED***t/* to utf-8
  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
    return 'UTF-8'
  }

  return false
}

/**
 * Create a full Content-Type header given a MIME type or e***REMOVED***tension.
 *
 * @param {string} str
 * @return {boolean|string}
 */

function contentType (str) {
  // TODO: should this even be in this module?
  if (!str || typeof str !== 'string') {
    return false
  }

  var mime = str.inde***REMOVED***Of('/') === -1
    ? e***REMOVED***ports.lookup(str)
    : str

  if (!mime) {
    return false
  }

  // TODO: use content-type or other module
  if (mime.inde***REMOVED***Of('charset') === -1) {
    var charset = e***REMOVED***ports.charset(mime)
    if (charset) mime += '; charset=' + charset.toLowerCase()
  }

  return mime
}

/**
 * Get the default e***REMOVED***tension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function e***REMOVED***tension (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.e***REMOVED***ec(type)

  // get e***REMOVED***tensions
  var e***REMOVED***ts = match && e***REMOVED***ports.e***REMOVED***tensions[match[1].toLowerCase()]

  if (!e***REMOVED***ts || !e***REMOVED***ts.length) {
    return false
  }

  return e***REMOVED***ts[0]
}

/**
 * Lookup the MIME type for a file path/e***REMOVED***tension.
 *
 * @param {string} path
 * @return {boolean|string}
 */

function lookup (path) {
  if (!path || typeof path !== 'string') {
    return false
  }

  // get the e***REMOVED***tension ("e***REMOVED***t" or ".e***REMOVED***t" or full path)
  var e***REMOVED***tension = e***REMOVED***tname('***REMOVED***.' + path)
    .toLowerCase()
    .substr(1)

  if (!e***REMOVED***tension) {
    return false
  }

  return e***REMOVED***ports.types[e***REMOVED***tension] || false
}

/**
 * Populate the e***REMOVED***tensions and types maps.
 * @private
 */

function populateMaps (e***REMOVED***tensions, types) {
  // source preference (least -> most)
  var preference = ['ngin***REMOVED***', 'apache', undefined, 'iana']

  Object.keys(db).forEach(function forEachMimeType (type) {
    var mime = db[type]
    var e***REMOVED***ts = mime.e***REMOVED***tensions

    if (!e***REMOVED***ts || !e***REMOVED***ts.length) {
      return
    }

    // mime -> e***REMOVED***tensions
    e***REMOVED***tensions[type] = e***REMOVED***ts

    // e***REMOVED***tension -> mime
    for (var i = 0; i < e***REMOVED***ts.length; i++) {
      var e***REMOVED***tension = e***REMOVED***ts[i]

      if (types[e***REMOVED***tension]) {
        var from = preference.inde***REMOVED***Of(db[types[e***REMOVED***tension]].source)
        var to = preference.inde***REMOVED***Of(mime.source)

        if (types[e***REMOVED***tension] !== 'application/octet-stream' &&
          (from > to || (from === to && types[e***REMOVED***tension].substr(0, 12) === 'application/'))) {
          // skip the remapping
          continue
        }
      }

      // set the e***REMOVED***tension -> mime
      types[e***REMOVED***tension] = type
    }
  })
}
