// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
'use strict';

function f(s, ***REMOVED***, y, z) {
  switch (s) {
    case 0: return (***REMOVED*** & y) ^ (~***REMOVED*** & z);
    case 1: return ***REMOVED*** ^ y ^ z;
    case 2: return (***REMOVED*** & y) ^ (***REMOVED*** & z) ^ (y & z);
    case 3: return ***REMOVED*** ^ y ^ z;
  }
}

function ROTL(***REMOVED***, n) {
  return (***REMOVED*** << n) | (***REMOVED***>>> (32 - n));
}

function sha1(bytes) {
  var K = [0***REMOVED***5a827999, 0***REMOVED***6ed9eba1, 0***REMOVED***8f1bbcdc, 0***REMOVED***ca62c1d6];
  var H = [0***REMOVED***67452301, 0***REMOVED***efcdab89, 0***REMOVED***98badcfe, 0***REMOVED***10325476, 0***REMOVED***c3d2e1f0];

  if (typeof(bytes) == 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape
    bytes = new Array(msg.length);
    for (var i = 0; i < msg.length; i++) bytes[i] = msg.charCodeAt(i);
  }

  bytes.push(0***REMOVED***80);

  var l = bytes.length/4 + 2;
  var N = Math.ceil(l/16);
  var M = new Array(N);

  for (var i=0; i<N; i++) {
    M[i] = new Array(16);
    for (var j=0; j<16; j++) {
      M[i][j] =
        bytes[i * 64 + j * 4] << 24 |
        bytes[i * 64 + j * 4 + 1] << 16 |
        bytes[i * 64 + j * 4 + 2] << 8 |
        bytes[i * 64 + j * 4 + 3];
    }
  }

  M[N - 1][14] = ((bytes.length - 1) * 8) /
    Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = ((bytes.length - 1) * 8) & 0***REMOVED***ffffffff;

  for (var i=0; i<N; i++) {
    var W = new Array(80);

    for (var t=0; t<16; t++) W[t] = M[i][t];
    for (var t=16; t<80; t++) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }

    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];

    for (var t=0; t<80; t++) {
      var s = Math.floor(t/20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = (H[0] + a) >>> 0;
    H[1] = (H[1] + b) >>> 0;
    H[2] = (H[2] + c) >>> 0;
    H[3] = (H[3] + d) >>> 0;
    H[4] = (H[4] + e) >>> 0;
  }

  return [
    H[0] >> 24 & 0***REMOVED***ff, H[0] >> 16 & 0***REMOVED***ff, H[0] >> 8 & 0***REMOVED***ff, H[0] & 0***REMOVED***ff,
    H[1] >> 24 & 0***REMOVED***ff, H[1] >> 16 & 0***REMOVED***ff, H[1] >> 8 & 0***REMOVED***ff, H[1] & 0***REMOVED***ff,
    H[2] >> 24 & 0***REMOVED***ff, H[2] >> 16 & 0***REMOVED***ff, H[2] >> 8 & 0***REMOVED***ff, H[2] & 0***REMOVED***ff,
    H[3] >> 24 & 0***REMOVED***ff, H[3] >> 16 & 0***REMOVED***ff, H[3] >> 8 & 0***REMOVED***ff, H[3] & 0***REMOVED***ff,
    H[4] >> 24 & 0***REMOVED***ff, H[4] >> 16 & 0***REMOVED***ff, H[4] >> 8 & 0***REMOVED***ff, H[4] & 0***REMOVED***ff
  ];
}

module.e***REMOVED***ports = sha1;
