'use strict';

var isRegE***REMOVED***p = require('./_is-rege***REMOVED***p');
var anObject = require('./_an-object');
var speciesConstructor = require('./_species-constructor');
var advanceStringInde***REMOVED*** = require('./_advance-string-inde***REMOVED***');
var toLength = require('./_to-length');
var callRegE***REMOVED***pE***REMOVED***ec = require('./_rege***REMOVED***p-e***REMOVED***ec-abstract');
var rege***REMOVED***pE***REMOVED***ec = require('./_rege***REMOVED***p-e***REMOVED***ec');
var fails = require('./_fails');
var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastInde***REMOVED***';
var MAX_UINT32 = 0***REMOVED***ffffffff;

// babel-minify transpiles RegE***REMOVED***p('***REMOVED***', 'y') -> /***REMOVED***/y and it causes Synta***REMOVED***Error
var SUPPORTS_Y = !fails(function () { RegE***REMOVED***p(MAX_UINT32, 'y'); });

// @@split logic
require('./_fi***REMOVED***-re-wks')('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a rege***REMOVED***, use native split
      if (!isRegE***REMOVED***p(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastInde***REMOVED*** = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;
      // Make `global` and avoid `lastInde***REMOVED***` issues by working with a copy
      var separatorCopy = new RegE***REMOVED***p(separator.source, flags + 'g');
      var match, lastInde***REMOVED***, lastLength;
      while (match = rege***REMOVED***pE***REMOVED***ec.call(separatorCopy, string)) {
        lastInde***REMOVED*** = separatorCopy[LAST_INDEX];
        if (lastInde***REMOVED*** > lastLastInde***REMOVED***) {
          output.push(string.slice(lastLastInde***REMOVED***, match.inde***REMOVED***));
          if (match[LENGTH] > 1 && match.inde***REMOVED*** < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastInde***REMOVED*** = lastInde***REMOVED***;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.inde***REMOVED***) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastInde***REMOVED*** === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastInde***REMOVED***));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = defined(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegE***REMOVED***p.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-rege***REMOVED***p.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (rege***REMOVED***p, limit) {
      var res = maybeCallNative(internalSplit, rege***REMOVED***p, this, limit, internalSplit !== $split);
      if (res.done) return res.value;

      var r***REMOVED*** = anObject(rege***REMOVED***p);
      var S = String(this);
      var C = speciesConstructor(r***REMOVED***, RegE***REMOVED***p);

      var unicodeMatching = r***REMOVED***.unicode;
      var flags = (r***REMOVED***.ignoreCase ? 'i' : '') +
                  (r***REMOVED***.multiline ? 'm' : '') +
                  (r***REMOVED***.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + r***REMOVED*** + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? r***REMOVED*** : '^(?:' + r***REMOVED***.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegE***REMOVED***pE***REMOVED***ec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastInde***REMOVED*** = SUPPORTS_Y ? q : 0;
        var z = callRegE***REMOVED***pE***REMOVED***ec(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = $min(toLength(splitter.lastInde***REMOVED*** + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringInde***REMOVED***(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
});
