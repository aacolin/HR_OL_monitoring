var global = require('./_global');
var core = require('./_core');
var ct***REMOVED*** = require('./_ct***REMOVED***');
var hide = require('./_hide');
var has = require('./_has');
var PROTOTYPE = 'prototype';

var $e***REMOVED***port = function (type, name, source) {
  var IS_FORCED = type & $e***REMOVED***port.F;
  var IS_GLOBAL = type & $e***REMOVED***port.G;
  var IS_STATIC = type & $e***REMOVED***port.S;
  var IS_PROTO = type & $e***REMOVED***port.P;
  var IS_BIND = type & $e***REMOVED***port.B;
  var IS_WRAP = type & $e***REMOVED***port.W;
  var e***REMOVED***ports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var e***REMOVED***pProto = e***REMOVED***ports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(e***REMOVED***ports, key)) continue;
    // e***REMOVED***port native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    e***REMOVED***ports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from e***REMOVED***port conte***REMOVED***t
    : IS_BIND && own ? ct***REMOVED***(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ct***REMOVED***(Function.call, out) : out;
    // e***REMOVED***port proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (e***REMOVED***ports.virtual || (e***REMOVED***ports.virtual = {}))[key] = out;
      // e***REMOVED***port proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $e***REMOVED***port.R && e***REMOVED***pProto && !e***REMOVED***pProto[key]) hide(e***REMOVED***pProto, key, out);
    }
  }
};
// type bitmap
$e***REMOVED***port.F = 1;   // forced
$e***REMOVED***port.G = 2;   // global
$e***REMOVED***port.S = 4;   // static
$e***REMOVED***port.P = 8;   // proto
$e***REMOVED***port.B = 16;  // bind
$e***REMOVED***port.W = 32;  // wrap
$e***REMOVED***port.U = 64;  // safe
$e***REMOVED***port.R = 128; // real proto method for `library`
module.e***REMOVED***ports = $e***REMOVED***port;
