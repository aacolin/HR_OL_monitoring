'use strict';
require('./es6.rege***REMOVED***p.e***REMOVED***ec');
var redefine = require('./_redefine');
var hide = require('./_hide');
var fails = require('./_fails');
var defined = require('./_defined');
var wks = require('./_wks');
var rege***REMOVED***pE***REMOVED***ec = require('./_rege***REMOVED***p-e***REMOVED***ec');

var SPECIES = wks('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the e***REMOVED***ec results, even if it has
  // a "grops" property.
  var re = /./;
  re.e***REMOVED***ec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
  // Chrome 51 has a buggy "split" implementation when RegE***REMOVED***p#e***REMOVED***ec !== nativeE***REMOVED***ec
  var re = /(?:)/;
  var originalE***REMOVED***ec = re.e***REMOVED***ec;
  re.e***REMOVED***ec = function () { return originalE***REMOVED***ec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
})();

module.e***REMOVED***ports = function (KEY, length, e***REMOVED***ec) {
  var SYMBOL = wks(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegE***REMOVED***p methods call .e***REMOVED***ec
    var e***REMOVED***ecCalled = false;
    var re = /a/;
    re.e***REMOVED***ec = function () { e***REMOVED***ecCalled = true; return null; };
    if (KEY === 'split') {
      // RegE***REMOVED***p[@@split] doesn't call the rege***REMOVED***'s e***REMOVED***ec method, but first creates
      // a new one. We need to return the patched rege***REMOVED*** when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }
    re[SYMBOL]('');
    return !e***REMOVED***ecCalled;
  }) : undefined;

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegE***REMOVED***pMethod = /./[SYMBOL];
    var fns = e***REMOVED***ec(
      defined,
      SYMBOL,
      ''[KEY],
      function maybeCallNative(nativeMethod, rege***REMOVED***p, str, arg2, forceStringMethod) {
        if (rege***REMOVED***p.e***REMOVED***ec === rege***REMOVED***pE***REMOVED***ec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegE***REMOVED***pMethod.call(rege***REMOVED***p, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, rege***REMOVED***p, arg2) };
        }
        return { done: false };
      }
    );
    var strfn = fns[0];
    var r***REMOVED***fn = fns[1];

    redefine(String.prototype, KEY, strfn);
    hide(RegE***REMOVED***p.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegE***REMOVED***p.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegE***REMOVED***p.prototype[@@split](string, limit)
      ? function (string, arg) { return r***REMOVED***fn.call(string, this, arg); }
      // 21.2.5.6 RegE***REMOVED***p.prototype[@@match](string)
      // 21.2.5.9 RegE***REMOVED***p.prototype[@@search](string)
      : function (string) { return r***REMOVED***fn.call(string, this); }
    );
  }
};
