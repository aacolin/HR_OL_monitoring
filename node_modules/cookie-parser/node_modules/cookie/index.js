/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict';

/**
 * Module e***REMOVED***ports.
 * @public
 */

e***REMOVED***ports.parse = parse;
e***REMOVED***ports.serialize = serialize;

/**
 * Module variables.
 * @private
 */

var __toString = Object.prototype.toString
var __hasOwnProperty = Object.prototype.hasOwnProperty

/**
 * RegE***REMOVED***p to match cookie-name in RFC 6265 sec 4.1.1
 * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
 * which has been replaced by the token definition in RFC 7230 appendi***REMOVED*** B.
 *
 * cookie-name       = token
 * token             = 1*tchar
 * tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
 *                     "*" / "+" / "-" / "." / "^" / "_" /
 *                     "`" / "|" / "~" / DIGIT / ALPHA
 */

var cookieNameRegE***REMOVED***p = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;

/**
 * RegE***REMOVED***p to match cookie-value in RFC 6265 sec 4.1.1
 *
 * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
 * cookie-octet      = %***REMOVED***21 / %***REMOVED***23-2B / %***REMOVED***2D-3A / %***REMOVED***3C-5B / %***REMOVED***5D-7E
 *                     ; US-ASCII characters e***REMOVED***cluding CTLs,
 *                     ; whitespace DQUOTE, comma, semicolon,
 *                     ; and backslash
 */

var cookieValueRegE***REMOVED***p = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;

/**
 * RegE***REMOVED***p to match domain-value in RFC 6265 sec 4.1.1
 *
 * domain-value      = <subdomain>
 *                     ; defined in [RFC1034], Section 3.5, as
 *                     ; enhanced by [RFC1123], Section 2.1
 * <subdomain>       = <label> | <subdomain> "." <label>
 * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]
 *                     Labels must be 63 characters or less.
 *                     'let-dig' not 'letter' in the first char, per RFC1123
 * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>
 * <let-dig-hyp>     = <let-dig> | "-"
 * <let-dig>         = <letter> | <digit>
 * <letter>          = any one of the 52 alphabetic characters A through Z in
 *                     upper case and a through z in lower case
 * <digit>           = any one of the ten digits 0 through 9
 *
 * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173
 *
 * > (Note that a leading %***REMOVED***2E ("."), if present, is ignored even though that
 * character is not permitted, but a trailing %***REMOVED***2E ("."), if present, will
 * cause the user agent to ignore the attribute.)
 */

var domainValueRegE***REMOVED***p = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;

/**
 * RegE***REMOVED***p to match path-value in RFC 6265 sec 4.1.1
 *
 * path-value        = <any CHAR e***REMOVED***cept CTLs or ";">
 * CHAR              = %***REMOVED***01-7F
 *                     ; defined in RFC 5234 appendi***REMOVED*** B.1
 */

var pathValueRegE***REMOVED***p = /^[\u0020-\u003A\u003D-\u007E]*$/;

/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 *
 * @param {string} str
 * @param {object} [opt]
 * @return {object}
 * @public
 */

function parse(str, opt) {
  if (typeof str !== 'string') {
    throw new TypeError('argument str must be a string');
  }

  var obj = {};
  var len = str.length;
  // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.
  if (len < 2) return obj;

  var dec = (opt && opt.decode) || decode;
  var inde***REMOVED*** = 0;
  var eqId***REMOVED*** = 0;
  var endId***REMOVED*** = 0;

  do {
    eqId***REMOVED*** = str.inde***REMOVED***Of('=', inde***REMOVED***);
    if (eqId***REMOVED*** === -1) break; // No more cookie pairs.

    endId***REMOVED*** = str.inde***REMOVED***Of(';', inde***REMOVED***);

    if (endId***REMOVED*** === -1) {
      endId***REMOVED*** = len;
    } else if (eqId***REMOVED*** > endId***REMOVED***) {
      // backtrack on prior semicolon
      inde***REMOVED*** = str.lastInde***REMOVED***Of(';', eqId***REMOVED*** - 1) + 1;
      continue;
    }

    var keyStartId***REMOVED*** = startInde***REMOVED***(str, inde***REMOVED***, eqId***REMOVED***);
    var keyEndId***REMOVED*** = endInde***REMOVED***(str, eqId***REMOVED***, keyStartId***REMOVED***);
    var key = str.slice(keyStartId***REMOVED***, keyEndId***REMOVED***);

    // only assign once
    if (!__hasOwnProperty.call(obj, key)) {
      var valStartId***REMOVED*** = startInde***REMOVED***(str, eqId***REMOVED*** + 1, endId***REMOVED***);
      var valEndId***REMOVED*** = endInde***REMOVED***(str, endId***REMOVED***, valStartId***REMOVED***);

      if (str.charCodeAt(valStartId***REMOVED***) === 0***REMOVED***22 /* " */ && str.charCodeAt(valEndId***REMOVED*** - 1) === 0***REMOVED***22 /* " */) {
        valStartId***REMOVED***++;
        valEndId***REMOVED***--;
      }

      var val = str.slice(valStartId***REMOVED***, valEndId***REMOVED***);
      obj[key] = tryDecode(val, dec);
    }

    inde***REMOVED*** = endId***REMOVED*** + 1
  } while (inde***REMOVED*** < len);

  return obj;
}

function startInde***REMOVED***(str, inde***REMOVED***, ma***REMOVED***) {
  do {
    var code = str.charCodeAt(inde***REMOVED***);
    if (code !== 0***REMOVED***20 /*   */ && code !== 0***REMOVED***09 /* \t */) return inde***REMOVED***;
  } while (++inde***REMOVED*** < ma***REMOVED***);
  return ma***REMOVED***;
}

function endInde***REMOVED***(str, inde***REMOVED***, min) {
  while (inde***REMOVED*** > min) {
    var code = str.charCodeAt(--inde***REMOVED***);
    if (code !== 0***REMOVED***20 /*   */ && code !== 0***REMOVED***09 /* \t */) return inde***REMOVED*** + 1;
  }
  return min;
}

/**
 * Serialize data into a cookie header.
 *
 * Serialize a name value pair into a cookie string suitable for
 * http headers. An optional options object specifies cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 *
 * @param {string} name
 * @param {string} val
 * @param {object} [opt]
 * @return {string}
 * @public
 */

function serialize(name, val, opt) {
  var enc = (opt && opt.encode) || encodeURIComponent;

  if (typeof enc !== 'function') {
    throw new TypeError('option encode is invalid');
  }

  if (!cookieNameRegE***REMOVED***p.test(name)) {
    throw new TypeError('argument name is invalid');
  }

  var value = enc(val);

  if (!cookieValueRegE***REMOVED***p.test(value)) {
    throw new TypeError('argument val is invalid');
  }

  var str = name + '=' + value;
  if (!opt) return str;

  if (null != opt.ma***REMOVED***Age) {
    var ma***REMOVED***Age = Math.floor(opt.ma***REMOVED***Age);

    if (!isFinite(ma***REMOVED***Age)) {
      throw new TypeError('option ma***REMOVED***Age is invalid')
    }

    str += '; Ma***REMOVED***-Age=' + ma***REMOVED***Age;
  }

  if (opt.domain) {
    if (!domainValueRegE***REMOVED***p.test(opt.domain)) {
      throw new TypeError('option domain is invalid');
    }

    str += '; Domain=' + opt.domain;
  }

  if (opt.path) {
    if (!pathValueRegE***REMOVED***p.test(opt.path)) {
      throw new TypeError('option path is invalid');
    }

    str += '; Path=' + opt.path;
  }

  if (opt.e***REMOVED***pires) {
    var e***REMOVED***pires = opt.e***REMOVED***pires

    if (!isDate(e***REMOVED***pires) || isNaN(e***REMOVED***pires.valueOf())) {
      throw new TypeError('option e***REMOVED***pires is invalid');
    }

    str += '; E***REMOVED***pires=' + e***REMOVED***pires.toUTCString()
  }

  if (opt.httpOnly) {
    str += '; HttpOnly';
  }

  if (opt.secure) {
    str += '; Secure';
  }

  if (opt.partitioned) {
    str += '; Partitioned'
  }

  if (opt.priority) {
    var priority = typeof opt.priority === 'string'
      ? opt.priority.toLowerCase() : opt.priority;

    switch (priority) {
      case 'low':
        str += '; Priority=Low'
        break
      case 'medium':
        str += '; Priority=Medium'
        break
      case 'high':
        str += '; Priority=High'
        break
      default:
        throw new TypeError('option priority is invalid')
    }
  }

  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === 'string'
      ? opt.sameSite.toLowerCase() : opt.sameSite;

    switch (sameSite) {
      case true:
        str += '; SameSite=Strict';
        break;
      case 'la***REMOVED***':
        str += '; SameSite=La***REMOVED***';
        break;
      case 'strict':
        str += '; SameSite=Strict';
        break;
      case 'none':
        str += '; SameSite=None';
        break;
      default:
        throw new TypeError('option sameSite is invalid');
    }
  }

  return str;
}

/**
 * URL-decode string value. Optimized to skip native call when no %.
 *
 * @param {string} str
 * @returns {string}
 */

function decode (str) {
  return str.inde***REMOVED***Of('%') !== -1
    ? decodeURIComponent(str)
    : str
}

/**
 * Determine if value is a Date.
 *
 * @param {*} val
 * @private
 */

function isDate (val) {
  return __toString.call(val) === '[object Date]';
}

/**
 * Try decoding a string using a decoding function.
 *
 * @param {string} str
 * @param {function} decode
 * @private
 */

function tryDecode(str, decode) {
  try {
    return decode(str);
  } catch (e) {
    return str;
  }
}
