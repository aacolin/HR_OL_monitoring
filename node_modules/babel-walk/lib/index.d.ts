import * as t from '@babel/types';
e***REMOVED***port declare type NodeType<type e***REMOVED***tends string> = type e***REMOVED***tends keyof t.Aliases ? t.Aliases[type] : E***REMOVED***tract<t.Node, {
    type: type;
}>;
e***REMOVED***port declare type SimpleFunction<TKey e***REMOVED***tends string, TState> = (node: NodeType<TKey>, state: TState) => void;
e***REMOVED***port declare type SimpleVisitors<TState = void> = {
    [key in keyof t.Aliases | t.Node['type']]?: SimpleFunction<key, TState> | {
        enter?: SimpleFunction<key, TState>;
        e***REMOVED***it?: SimpleFunction<key, TState>;
    };
};
e***REMOVED***port declare function simple<TState = void>(visitors: SimpleVisitors<TState>): (node: t.Node, state: TState) => void;
e***REMOVED***port declare type AncestorFunction<TKey e***REMOVED***tends string, TState> = (node: NodeType<TKey>, state: TState, ancestors: t.Node[]) => void;
e***REMOVED***port declare type AncestorVisitor<TState = void> = {
    [key in keyof t.Aliases | t.Node['type']]?: AncestorFunction<key, TState> | {
        enter?: AncestorFunction<key, TState>;
        e***REMOVED***it?: AncestorFunction<key, TState>;
    };
};
e***REMOVED***port declare function ancestor<TState = void>(visitors: AncestorVisitor<TState>): (node: t.Node, state: TState) => void;
e***REMOVED***port declare type RecursiveVisitors<TState = void> = {
    [key in keyof t.Aliases | t.Node['type']]?: (node: NodeType<key>, state: TState, recurse: (node: t.Node) => void) => void;
};
e***REMOVED***port declare function recursive<TState = void>(visitors: RecursiveVisitors<TState>): (node: t.Node, state: TState) => void;
