var path = require('path');
var fs = require('fs');

function Mime() {
  // Map of e***REMOVED***tension -> mime type
  this.types = Object.create(null);

  // Map of mime type -> e***REMOVED***tension
  this.e***REMOVED***tensions = Object.create(null);
}

/**
 * Define mimetype -> e***REMOVED***tension mappings.  Each key is a mime-type that maps
 * to an array of e***REMOVED***tensions associated with the type.  The first e***REMOVED***tension is
 * used as the default e***REMOVED***tension for the type.
 *
 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'sp***REMOVED***']});
 *
 * @param map (Object) type definitions
 */
Mime.prototype.define = function (map) {
  for (var type in map) {
    var e***REMOVED***ts = map[type];
    for (var i = 0; i < e***REMOVED***ts.length; i++) {
      if (process.env.DEBUG_MIME && this.types[e***REMOVED***ts[i]]) {
        console.warn((this._loading || "define()").replace(/.*\//, ''), 'changes "' + e***REMOVED***ts[i] + '" e***REMOVED***tension type from ' +
          this.types[e***REMOVED***ts[i]] + ' to ' + type);
      }

      this.types[e***REMOVED***ts[i]] = type;
    }

    // Default e***REMOVED***tension is the first one we encounter
    if (!this.e***REMOVED***tensions[type]) {
      this.e***REMOVED***tensions[type] = e***REMOVED***ts[0];
    }
  }
};

/**
 * Load an Apache2-style ".types" file
 *
 * This may be called multiple times (it's e***REMOVED***pected).  Where files declare
 * overlapping types/e***REMOVED***tensions, the last file wins.
 *
 * @param file (String) path of file to load.
 */
Mime.prototype.load = function(file) {
  this._loading = file;
  // Read file and split into lines
  var map = {},
      content = fs.readFileSync(file, 'ascii'),
      lines = content.split(/[\r\n]+/);

  lines.forEach(function(line) {
    // Clean up whitespace/comments, and split into fields
    var fields = line.replace(/\s*#.*|^\s*|\s*$/g, '').split(/\s+/);
    map[fields.shift()] = fields;
  });

  this.define(map);

  this._loading = null;
};

/**
 * Lookup a mime type based on e***REMOVED***tension
 */
Mime.prototype.lookup = function(path, fallback) {
  var e***REMOVED***t = path.replace(/^.*[\.\/\\]/, '').toLowerCase();

  return this.types[e***REMOVED***t] || fallback || this.default_type;
};

/**
 * Return file e***REMOVED***tension associated with a mime type
 */
Mime.prototype.e***REMOVED***tension = function(mimeType) {
  var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
  return this.e***REMOVED***tensions[type];
};

// Default instance
var mime = new Mime();

// Define built-in types
mime.define(require('./types.json'));

// Default type
mime.default_type = mime.lookup('bin');

//
// Additional API specific to the default instance
//

mime.Mime = Mime;

/**
 * Lookup a charset based on mime type.
 */
mime.charsets = {
  lookup: function(mimeType, fallback) {
    // Assume te***REMOVED***t types are utf8
    return (/^te***REMOVED***t\/|^application\/(javascript|json)/).test(mimeType) ? 'UTF-8' : fallback;
  }
};

module.e***REMOVED***ports = mime;
