"use strict";

Object.defineProperty(e***REMOVED***ports, "__esModule", {
  value: true
});
e***REMOVED***ports.patternLikeCommon = e***REMOVED***ports.importAttributes = e***REMOVED***ports.functionTypeAnnotationCommon = e***REMOVED***ports.functionDeclarationCommon = e***REMOVED***ports.functionCommon = e***REMOVED***ports.classMethodOrPropertyCommon = e***REMOVED***ports.classMethodOrDeclareMethodCommon = void 0;
var _is = require("../validators/is.js");
var _isValidIdentifier = require("../validators/isValidIdentifier.js");
var _helperValidatorIdentifier = require("@babel/helper-validator-identifier");
var _helperStringParser = require("@babel/helper-string-parser");
var _inde***REMOVED*** = require("../constants/inde***REMOVED***.js");
var _utils = require("./utils.js");
const defineType = (0, _utils.defineAliasedType)("Standardized");
defineType("ArrayE***REMOVED***pression", {
  fields: {
    elements: {
      validate: (0, _utils.arrayOf)((0, _utils.assertNodeOrValueType)("null", "E***REMOVED***pression", "SpreadElement")),
      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined
    }
  },
  visitor: ["elements"],
  aliases: ["E***REMOVED***pression"]
});
defineType("AssignmentE***REMOVED***pression", {
  fields: {
    operator: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("string") : Object.assign(function () {
        const identifier = (0, _utils.assertOneOf)(..._inde***REMOVED***.ASSIGNMENT_OPERATORS);
        const pattern = (0, _utils.assertOneOf)("=");
        return function (node, key, val) {
          const validator = (0, _is.default)("Pattern", node.left) ? pattern : identifier;
          validator(node, key, val);
        };
      }(), {
        type: "string"
      })
    },
    left: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal", "OptionalMemberE***REMOVED***pression") : (0, _utils.assertNodeType)("Identifier", "MemberE***REMOVED***pression", "OptionalMemberE***REMOVED***pression", "ArrayPattern", "ObjectPattern", "TSAsE***REMOVED***pression", "TSSatisfiesE***REMOVED***pression", "TSTypeAssertion", "TSNonNullE***REMOVED***pression")
    },
    right: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    }
  },
  builder: ["operator", "left", "right"],
  visitor: ["left", "right"],
  aliases: ["E***REMOVED***pression"]
});
defineType("BinaryE***REMOVED***pression", {
  builder: ["operator", "left", "right"],
  fields: {
    operator: {
      validate: (0, _utils.assertOneOf)(..._inde***REMOVED***.BINARY_OPERATORS)
    },
    left: {
      validate: function () {
        const e***REMOVED***pression = (0, _utils.assertNodeType)("E***REMOVED***pression");
        const inOp = (0, _utils.assertNodeType)("E***REMOVED***pression", "PrivateName");
        const validator = Object.assign(function (node, key, val) {
          const validator = node.operator === "in" ? inOp : e***REMOVED***pression;
          validator(node, key, val);
        }, {
          oneOfNodeTypes: ["E***REMOVED***pression", "PrivateName"]
        });
        return validator;
      }()
    },
    right: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    }
  },
  visitor: ["left", "right"],
  aliases: ["Binary", "E***REMOVED***pression"]
});
defineType("InterpreterDirective", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});
defineType("Directive", {
  visitor: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertNodeType)("DirectiveLiteral")
    }
  }
});
defineType("DirectiveLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});
defineType("BlockStatement", {
  builder: ["body", "directives"],
  visitor: ["directives", "body"],
  fields: {
    directives: {
      validate: (0, _utils.arrayOfType)("Directive"),
      default: []
    },
    body: (0, _utils.validateArrayOfType)("Statement")
  },
  aliases: ["Scopable", "BlockParent", "Block", "Statement"]
});
defineType("BreakStatement", {
  visitor: ["label"],
  fields: {
    label: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    }
  },
  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
});
defineType("CallE***REMOVED***pression", {
  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
  builder: ["callee", "arguments"],
  aliases: ["E***REMOVED***pression"],
  fields: Object.assign({
    callee: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression", "Super", "V8IntrinsicIdentifier")
    },
    arguments: (0, _utils.validateArrayOfType)("E***REMOVED***pression", "SpreadElement", "ArgumentPlaceholder")
  }, !process.env.BABEL_TYPES_8_BREAKING ? {
    optional: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    }
  } : {}, {
    typeArguments: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
      optional: true
    }
  })
});
defineType("CatchClause", {
  visitor: ["param", "body"],
  fields: {
    param: {
      validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  },
  aliases: ["Scopable", "BlockParent"]
});
defineType("ConditionalE***REMOVED***pression", {
  visitor: ["test", "consequent", "alternate"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    },
    consequent: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    },
    alternate: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    }
  },
  aliases: ["E***REMOVED***pression", "Conditional"]
});
defineType("ContinueStatement", {
  visitor: ["label"],
  fields: {
    label: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    }
  },
  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
});
defineType("DebuggerStatement", {
  aliases: ["Statement"]
});
defineType("DoWhileStatement", {
  builder: ["test", "body"],
  visitor: ["body", "test"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  },
  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
});
defineType("EmptyStatement", {
  aliases: ["Statement"]
});
defineType("E***REMOVED***pressionStatement", {
  visitor: ["e***REMOVED***pression"],
  fields: {
    e***REMOVED***pression: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    }
  },
  aliases: ["Statement", "E***REMOVED***pressionWrapper"]
});
defineType("File", {
  builder: ["program", "comments", "tokens"],
  visitor: ["program"],
  fields: {
    program: {
      validate: (0, _utils.assertNodeType)("Program")
    },
    comments: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {}, {
        each: {
          oneOfNodeTypes: ["CommentBlock", "CommentLine"]
        }
      }) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),
      optional: true
    },
    tokens: {
      validate: (0, _utils.assertEach)(Object.assign(() => {}, {
        type: "any"
      })),
      optional: true
    }
  }
});
defineType("ForInStatement", {
  visitor: ["left", "right", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
  fields: {
    left: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberE***REMOVED***pression", "ArrayPattern", "ObjectPattern", "TSAsE***REMOVED***pression", "TSSatisfiesE***REMOVED***pression", "TSTypeAssertion", "TSNonNullE***REMOVED***pression")
    },
    right: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
defineType("ForStatement", {
  visitor: ["init", "test", "update", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
  fields: {
    init: {
      validate: (0, _utils.assertNodeType)("VariableDeclaration", "E***REMOVED***pression"),
      optional: true
    },
    test: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression"),
      optional: true
    },
    update: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
const functionCommon = () => ({
  params: (0, _utils.validateArrayOfType)("Identifier", "Pattern", "RestElement"),
  generator: {
    default: false
  },
  async: {
    default: false
  }
});
e***REMOVED***ports.functionCommon = functionCommon;
const functionTypeAnnotationCommon = () => ({
  returnType: {
    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
    optional: true
  },
  typeParameters: {
    validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
    optional: true
  }
});
e***REMOVED***ports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
const functionDeclarationCommon = () => Object.assign({}, functionCommon(), {
  declare: {
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
  },
  id: {
    validate: (0, _utils.assertNodeType)("Identifier"),
    optional: true
  }
});
e***REMOVED***ports.functionDeclarationCommon = functionDeclarationCommon;
defineType("FunctionDeclaration", {
  builder: ["id", "params", "body", "generator", "async"],
  visitor: ["id", "typeParameters", "params", "returnType", "body"],
  fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    },
    predicate: {
      validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
      optional: true
    }
  }),
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
  validate: !process.env.BABEL_TYPES_8_BREAKING ? undefined : function () {
    const identifier = (0, _utils.assertNodeType)("Identifier");
    return function (parent, key, node) {
      if (!(0, _is.default)("E***REMOVED***portDefaultDeclaration", parent)) {
        identifier(node, "id", node.id);
      }
    };
  }()
});
defineType("FunctionE***REMOVED***pression", {
  inherits: "FunctionDeclaration",
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "E***REMOVED***pression", "Pureish"],
  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
    id: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    },
    predicate: {
      validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
      optional: true
    }
  })
});
const patternLikeCommon = () => ({
  typeAnnotation: {
    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
    optional: true
  },
  optional: {
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
  },
  decorators: {
    validate: (0, _utils.arrayOfType)("Decorator"),
    optional: true
  }
});
e***REMOVED***ports.patternLikeCommon = patternLikeCommon;
defineType("Identifier", {
  builder: ["name"],
  visitor: ["typeAnnotation", "decorators"],
  aliases: ["E***REMOVED***pression", "PatternLike", "LVal", "TSEntityName"],
  fields: Object.assign({}, patternLikeCommon(), {
    name: {
      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function (node, key, val) {
        if (!(0, _isValidIdentifier.default)(val, false)) {
          throw new TypeError(`"${val}" is not a valid identifier name`);
        }
      }, {
        type: "string"
      })) : (0, _utils.assertValueType)("string")
    }
  }),
  validate: process.env.BABEL_TYPES_8_BREAKING ? function (parent, key, node) {
    const match = /\.(\w+)$/.e***REMOVED***ec(key);
    if (!match) return;
    const [, parentKey] = match;
    const nonComp = {
      computed: false
    };
    if (parentKey === "property") {
      if ((0, _is.default)("MemberE***REMOVED***pression", parent, nonComp)) return;
      if ((0, _is.default)("OptionalMemberE***REMOVED***pression", parent, nonComp)) return;
    } else if (parentKey === "key") {
      if ((0, _is.default)("Property", parent, nonComp)) return;
      if ((0, _is.default)("Method", parent, nonComp)) return;
    } else if (parentKey === "e***REMOVED***ported") {
      if ((0, _is.default)("E***REMOVED***portSpecifier", parent)) return;
    } else if (parentKey === "imported") {
      if ((0, _is.default)("ImportSpecifier", parent, {
        imported: node
      })) return;
    } else if (parentKey === "meta") {
      if ((0, _is.default)("MetaProperty", parent, {
        meta: node
      })) return;
    }
    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== "this") {
      throw new TypeError(`"${node.name}" is not a valid identifier`);
    }
  } : undefined
});
defineType("IfStatement", {
  visitor: ["test", "consequent", "alternate"],
  aliases: ["Statement", "Conditional"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    },
    consequent: {
      validate: (0, _utils.assertNodeType)("Statement")
    },
    alternate: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
defineType("LabeledStatement", {
  visitor: ["label", "body"],
  aliases: ["Statement"],
  fields: {
    label: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
defineType("StringLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  },
  aliases: ["E***REMOVED***pression", "Pureish", "Literal", "Immutable"]
});
defineType("NumericLiteral", {
  builder: ["value"],
  deprecatedAlias: "NumberLiteral",
  fields: {
    value: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("number"), Object.assign(function (node, key, val) {
        if (1 / val < 0 || !Number.isFinite(val)) {
          const error = new Error("NumericLiterals must be non-negative finite numbers. " + `You can use t.valueToNode(${val}) instead.`);
          {}
        }
      }, {
        type: "number"
      }))
    }
  },
  aliases: ["E***REMOVED***pression", "Pureish", "Literal", "Immutable"]
});
defineType("NullLiteral", {
  aliases: ["E***REMOVED***pression", "Pureish", "Literal", "Immutable"]
});
defineType("BooleanLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("boolean")
    }
  },
  aliases: ["E***REMOVED***pression", "Pureish", "Literal", "Immutable"]
});
defineType("RegE***REMOVED***pLiteral", {
  builder: ["pattern", "flags"],
  deprecatedAlias: "Rege***REMOVED***Literal",
  aliases: ["E***REMOVED***pression", "Pureish", "Literal"],
  fields: {
    pattern: {
      validate: (0, _utils.assertValueType)("string")
    },
    flags: {
      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function (node, key, val) {
        const invalid = /[^gimsuy]/.e***REMOVED***ec(val);
        if (invalid) {
          throw new TypeError(`"${invalid[0]}" is not a valid RegE***REMOVED***p flag`);
        }
      }, {
        type: "string"
      })) : (0, _utils.assertValueType)("string"),
      default: ""
    }
  }
});
defineType("LogicalE***REMOVED***pression", {
  builder: ["operator", "left", "right"],
  visitor: ["left", "right"],
  aliases: ["Binary", "E***REMOVED***pression"],
  fields: {
    operator: {
      validate: (0, _utils.assertOneOf)(..._inde***REMOVED***.LOGICAL_OPERATORS)
    },
    left: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    },
    right: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    }
  }
});
defineType("MemberE***REMOVED***pression", {
  builder: ["object", "property", "computed", ...(!process.env.BABEL_TYPES_8_BREAKING ? ["optional"] : [])],
  visitor: ["object", "property"],
  aliases: ["E***REMOVED***pression", "LVal"],
  fields: Object.assign({
    object: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression", "Super")
    },
    property: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
        const computed = (0, _utils.assertNodeType)("E***REMOVED***pression");
        const validator = function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
        validator.oneOfNodeTypes = ["E***REMOVED***pression", "Identifier", "PrivateName"];
        return validator;
      }()
    },
    computed: {
      default: false
    }
  }, !process.env.BABEL_TYPES_8_BREAKING ? {
    optional: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    }
  } : {})
});
defineType("NewE***REMOVED***pression", {
  inherits: "CallE***REMOVED***pression"
});
defineType("Program", {
  visitor: ["directives", "body"],
  builder: ["body", "directives", "sourceType", "interpreter"],
  fields: {
    sourceType: {
      validate: (0, _utils.assertOneOf)("script", "module"),
      default: "script"
    },
    interpreter: {
      validate: (0, _utils.assertNodeType)("InterpreterDirective"),
      default: null,
      optional: true
    },
    directives: {
      validate: (0, _utils.arrayOfType)("Directive"),
      default: []
    },
    body: (0, _utils.validateArrayOfType)("Statement")
  },
  aliases: ["Scopable", "BlockParent", "Block"]
});
defineType("ObjectE***REMOVED***pression", {
  visitor: ["properties"],
  aliases: ["E***REMOVED***pression"],
  fields: {
    properties: (0, _utils.validateArrayOfType)("ObjectMethod", "ObjectProperty", "SpreadElement")
  }
});
defineType("ObjectMethod", {
  builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
  visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
    kind: Object.assign({
      validate: (0, _utils.assertOneOf)("method", "get", "set")
    }, !process.env.BABEL_TYPES_8_BREAKING ? {
      default: "method"
    } : {}),
    computed: {
      default: false
    },
    key: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
        const computed = (0, _utils.assertNodeType)("E***REMOVED***pression");
        const validator = function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
        validator.oneOfNodeTypes = ["E***REMOVED***pression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"];
        return validator;
      }()
    },
    decorators: {
      validate: (0, _utils.arrayOfType)("Decorator"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  }),
  aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
});
defineType("ObjectProperty", {
  builder: ["key", "value", "computed", "shorthand", ...(!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : [])],
  fields: {
    computed: {
      default: false
    },
    key: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");
        const computed = (0, _utils.assertNodeType)("E***REMOVED***pression");
        const validator = Object.assign(function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        }, {
          oneOfNodeTypes: ["E***REMOVED***pression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
        });
        return validator;
      }()
    },
    value: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression", "PatternLike")
    },
    shorthand: {
      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function (node, key, shorthand) {
        if (!shorthand) return;
        if (node.computed) {
          throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
        }
        if (!(0, _is.default)("Identifier", node.key)) {
          throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
        }
      }, {
        type: "boolean"
      })) : (0, _utils.assertValueType)("boolean"),
      default: false
    },
    decorators: {
      validate: (0, _utils.arrayOfType)("Decorator"),
      optional: true
    }
  },
  visitor: ["key", "value", "decorators"],
  aliases: ["UserWhitespacable", "Property", "ObjectMember"],
  validate: !process.env.BABEL_TYPES_8_BREAKING ? undefined : function () {
    const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern", "TSAsE***REMOVED***pression", "TSSatisfiesE***REMOVED***pression", "TSNonNullE***REMOVED***pression", "TSTypeAssertion");
    const e***REMOVED***pression = (0, _utils.assertNodeType)("E***REMOVED***pression");
    return function (parent, key, node) {
      const validator = (0, _is.default)("ObjectPattern", parent) ? pattern : e***REMOVED***pression;
      validator(node, "value", node.value);
    };
  }()
});
defineType("RestElement", {
  visitor: ["argument", "typeAnnotation"],
  builder: ["argument"],
  aliases: ["LVal", "PatternLike"],
  deprecatedAlias: "RestProperty",
  fields: Object.assign({}, patternLikeCommon(), {
    argument: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberE***REMOVED***pression", "TSAsE***REMOVED***pression", "TSSatisfiesE***REMOVED***pression", "TSTypeAssertion", "TSNonNullE***REMOVED***pression")
    }
  }),
  validate: process.env.BABEL_TYPES_8_BREAKING ? function (parent, key) {
    const match = /(\w+)\[(\d+)\]/.e***REMOVED***ec(key);
    if (!match) throw new Error("Internal Babel error: malformed key.");
    const [, listKey, inde***REMOVED***] = match;
    if (parent[listKey].length > +inde***REMOVED*** + 1) {
      throw new TypeError(`RestElement must be last element of ${listKey}`);
    }
  } : undefined
});
defineType("ReturnStatement", {
  visitor: ["argument"],
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression"),
      optional: true
    }
  }
});
defineType("SequenceE***REMOVED***pression", {
  visitor: ["e***REMOVED***pressions"],
  fields: {
    e***REMOVED***pressions: (0, _utils.validateArrayOfType)("E***REMOVED***pression")
  },
  aliases: ["E***REMOVED***pression"]
});
defineType("ParenthesizedE***REMOVED***pression", {
  visitor: ["e***REMOVED***pression"],
  aliases: ["E***REMOVED***pression", "E***REMOVED***pressionWrapper"],
  fields: {
    e***REMOVED***pression: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    }
  }
});
defineType("SwitchCase", {
  visitor: ["test", "consequent"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression"),
      optional: true
    },
    consequent: (0, _utils.validateArrayOfType)("Statement")
  }
});
defineType("SwitchStatement", {
  visitor: ["discriminant", "cases"],
  aliases: ["Statement", "BlockParent", "Scopable"],
  fields: {
    discriminant: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    },
    cases: (0, _utils.validateArrayOfType)("SwitchCase")
  }
});
defineType("ThisE***REMOVED***pression", {
  aliases: ["E***REMOVED***pression"]
});
defineType("ThrowStatement", {
  visitor: ["argument"],
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    }
  }
});
defineType("TryStatement", {
  visitor: ["block", "handler", "finalizer"],
  aliases: ["Statement"],
  fields: {
    block: {
      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function (node) {
        if (!node.handler && !node.finalizer) {
          throw new TypeError("TryStatement e***REMOVED***pects either a handler or finalizer, or both");
        }
      }, {
        oneOfNodeTypes: ["BlockStatement"]
      })) : (0, _utils.assertNodeType)("BlockStatement")
    },
    handler: {
      optional: true,
      validate: (0, _utils.assertNodeType)("CatchClause")
    },
    finalizer: {
      optional: true,
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  }
});
defineType("UnaryE***REMOVED***pression", {
  builder: ["operator", "argument", "prefi***REMOVED***"],
  fields: {
    prefi***REMOVED***: {
      default: true
    },
    argument: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    },
    operator: {
      validate: (0, _utils.assertOneOf)(..._inde***REMOVED***.UNARY_OPERATORS)
    }
  },
  visitor: ["argument"],
  aliases: ["UnaryLike", "E***REMOVED***pression"]
});
defineType("UpdateE***REMOVED***pression", {
  builder: ["operator", "argument", "prefi***REMOVED***"],
  fields: {
    prefi***REMOVED***: {
      default: false
    },
    argument: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("E***REMOVED***pression") : (0, _utils.assertNodeType)("Identifier", "MemberE***REMOVED***pression")
    },
    operator: {
      validate: (0, _utils.assertOneOf)(..._inde***REMOVED***.UPDATE_OPERATORS)
    }
  },
  visitor: ["argument"],
  aliases: ["E***REMOVED***pression"]
});
defineType("VariableDeclaration", {
  builder: ["kind", "declarations"],
  visitor: ["declarations"],
  aliases: ["Statement", "Declaration"],
  fields: {
    declare: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    kind: {
      validate: (0, _utils.assertOneOf)("var", "let", "const", "using", "await using")
    },
    declarations: (0, _utils.validateArrayOfType)("VariableDeclarator")
  },
  validate: process.env.BABEL_TYPES_8_BREAKING ? (() => {
    const withoutInit = (0, _utils.assertNodeType)("Identifier");
    return function (parent, key, node) {
      if ((0, _is.default)("ForXStatement", parent, {
        left: node
      })) {
        if (node.declarations.length !== 1) {
          throw new TypeError(`E***REMOVED***actly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
        }
      } else {
        node.declarations.forEach(decl => {
          if (!decl.init) withoutInit(decl, "id", decl.id);
        });
      }
    };
  })() : undefined
});
defineType("VariableDeclarator", {
  visitor: ["id", "init"],
  fields: {
    id: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern")
    },
    definite: {
      optional: true,
      validate: (0, _utils.assertValueType)("boolean")
    },
    init: {
      optional: true,
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    }
  }
});
defineType("WhileStatement", {
  visitor: ["test", "body"],
  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
defineType("WithStatement", {
  visitor: ["object", "body"],
  aliases: ["Statement"],
  fields: {
    object: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
defineType("AssignmentPattern", {
  visitor: ["left", "right", "decorators"],
  builder: ["left", "right"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: Object.assign({}, patternLikeCommon(), {
    left: {
      validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberE***REMOVED***pression", "TSAsE***REMOVED***pression", "TSSatisfiesE***REMOVED***pression", "TSTypeAssertion", "TSNonNullE***REMOVED***pression")
    },
    right: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    },
    decorators: {
      validate: (0, _utils.arrayOfType)("Decorator"),
      optional: true
    }
  })
});
defineType("ArrayPattern", {
  visitor: ["elements", "typeAnnotation"],
  builder: ["elements"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: Object.assign({}, patternLikeCommon(), {
    elements: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike", "LVal")))
    }
  })
});
defineType("ArrowFunctionE***REMOVED***pression", {
  builder: ["params", "body", "async"],
  visitor: ["typeParameters", "params", "returnType", "body"],
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "E***REMOVED***pression", "Pureish"],
  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
    e***REMOVED***pression: {
      validate: (0, _utils.assertValueType)("boolean")
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement", "E***REMOVED***pression")
    },
    predicate: {
      validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
      optional: true
    }
  })
});
defineType("ClassBody", {
  visitor: ["body"],
  fields: {
    body: (0, _utils.validateArrayOfType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSInde***REMOVED***Signature", "StaticBlock")
  }
});
defineType("ClassE***REMOVED***pression", {
  builder: ["id", "superClass", "body", "decorators"],
  visitor: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "mi***REMOVED***ins", "implements", "body"],
  aliases: ["Scopable", "Class", "E***REMOVED***pression"],
  fields: {
    id: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("ClassBody")
    },
    superClass: {
      optional: true,
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    },
    superTypeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
    },
    implements: {
      validate: (0, _utils.arrayOfType)("TSE***REMOVED***pressionWithTypeArguments", "ClassImplements"),
      optional: true
    },
    decorators: {
      validate: (0, _utils.arrayOfType)("Decorator"),
      optional: true
    },
    mi***REMOVED***ins: {
      validate: (0, _utils.assertNodeType)("InterfaceE***REMOVED***tends"),
      optional: true
    }
  }
});
defineType("ClassDeclaration", {
  inherits: "ClassE***REMOVED***pression",
  aliases: ["Scopable", "Class", "Statement", "Declaration"],
  fields: {
    id: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("ClassBody")
    },
    superClass: {
      optional: true,
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    },
    superTypeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
    },
    implements: {
      validate: (0, _utils.arrayOfType)("TSE***REMOVED***pressionWithTypeArguments", "ClassImplements"),
      optional: true
    },
    decorators: {
      validate: (0, _utils.arrayOfType)("Decorator"),
      optional: true
    },
    mi***REMOVED***ins: {
      validate: (0, _utils.assertNodeType)("InterfaceE***REMOVED***tends"),
      optional: true
    },
    declare: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    abstract: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    }
  },
  validate: !process.env.BABEL_TYPES_8_BREAKING ? undefined : function () {
    const identifier = (0, _utils.assertNodeType)("Identifier");
    return function (parent, key, node) {
      if (!(0, _is.default)("E***REMOVED***portDefaultDeclaration", parent)) {
        identifier(node, "id", node.id);
      }
    };
  }()
});
const importAttributes = e***REMOVED***ports.importAttributes = {
  attributes: {
    optional: true,
    validate: (0, _utils.arrayOfType)("ImportAttribute")
  },
  assertions: {
    deprecated: true,
    optional: true,
    validate: (0, _utils.arrayOfType)("ImportAttribute")
  }
};
defineType("E***REMOVED***portAllDeclaration", {
  builder: ["source"],
  visitor: ["source", "attributes", "assertions"],
  aliases: ["Statement", "Declaration", "ImportOrE***REMOVED***portDeclaration", "E***REMOVED***portDeclaration"],
  fields: Object.assign({
    source: {
      validate: (0, _utils.assertNodeType)("StringLiteral")
    },
    e***REMOVED***portKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
  }, importAttributes)
});
defineType("E***REMOVED***portDefaultDeclaration", {
  visitor: ["declaration"],
  aliases: ["Statement", "Declaration", "ImportOrE***REMOVED***portDeclaration", "E***REMOVED***portDeclaration"],
  fields: {
    declaration: (0, _utils.validateType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "E***REMOVED***pression"),
    e***REMOVED***portKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
  }
});
defineType("E***REMOVED***portNamedDeclaration", {
  builder: ["declaration", "specifiers", "source"],
  visitor: process.env ? ["declaration", "specifiers", "source", "attributes"] : ["declaration", "specifiers", "source", "attributes", "assertions"],
  aliases: ["Statement", "Declaration", "ImportOrE***REMOVED***portDeclaration", "E***REMOVED***portDeclaration"],
  fields: Object.assign({
    declaration: {
      optional: true,
      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function (node, key, val) {
        if (val && node.specifiers.length) {
          throw new TypeError("Only declaration or specifiers is allowed on E***REMOVED***portNamedDeclaration");
        }
        if (val && node.source) {
          throw new TypeError("Cannot e***REMOVED***port a declaration from a source");
        }
      }, {
        oneOfNodeTypes: ["Declaration"]
      })) : (0, _utils.assertNodeType)("Declaration")
    }
  }, importAttributes, {
    specifiers: {
      default: [],
      validate: (0, _utils.arrayOf)(function () {
        const sourced = (0, _utils.assertNodeType)("E***REMOVED***portSpecifier", "E***REMOVED***portDefaultSpecifier", "E***REMOVED***portNamespaceSpecifier");
        const sourceless = (0, _utils.assertNodeType)("E***REMOVED***portSpecifier");
        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;
        return Object.assign(function (node, key, val) {
          const validator = node.source ? sourced : sourceless;
          validator(node, key, val);
        }, {
          oneOfNodeTypes: ["E***REMOVED***portSpecifier", "E***REMOVED***portDefaultSpecifier", "E***REMOVED***portNamespaceSpecifier"]
        });
      }())
    },
    source: {
      validate: (0, _utils.assertNodeType)("StringLiteral"),
      optional: true
    },
    e***REMOVED***portKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
  })
});
defineType("E***REMOVED***portSpecifier", {
  visitor: ["local", "e***REMOVED***ported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    e***REMOVED***ported: {
      validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
    },
    e***REMOVED***portKind: {
      validate: (0, _utils.assertOneOf)("type", "value"),
      optional: true
    }
  }
});
defineType("ForOfStatement", {
  visitor: ["left", "right", "body"],
  builder: ["left", "right", "body", "await"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
  fields: {
    left: {
      validate: function () {
        if (!process.env.BABEL_TYPES_8_BREAKING) {
          return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
        }
        const declaration = (0, _utils.assertNodeType)("VariableDeclaration");
        const lval = (0, _utils.assertNodeType)("Identifier", "MemberE***REMOVED***pression", "ArrayPattern", "ObjectPattern", "TSAsE***REMOVED***pression", "TSSatisfiesE***REMOVED***pression", "TSTypeAssertion", "TSNonNullE***REMOVED***pression");
        return Object.assign(function (node, key, val) {
          if ((0, _is.default)("VariableDeclaration", val)) {
            declaration(node, key, val);
          } else {
            lval(node, key, val);
          }
        }, {
          oneOfNodeTypes: ["VariableDeclaration", "Identifier", "MemberE***REMOVED***pression", "ArrayPattern", "ObjectPattern", "TSAsE***REMOVED***pression", "TSSatisfiesE***REMOVED***pression", "TSTypeAssertion", "TSNonNullE***REMOVED***pression"]
        });
      }()
    },
    right: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    },
    await: {
      default: false
    }
  }
});
defineType("ImportDeclaration", {
  builder: ["specifiers", "source"],
  visitor: ["specifiers", "source", "attributes", "assertions"],
  aliases: ["Statement", "Declaration", "ImportOrE***REMOVED***portDeclaration"],
  fields: Object.assign({}, importAttributes, {
    module: {
      optional: true,
      validate: (0, _utils.assertValueType)("boolean")
    },
    phase: {
      default: null,
      validate: (0, _utils.assertOneOf)("source", "defer")
    },
    specifiers: (0, _utils.validateArrayOfType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"),
    source: {
      validate: (0, _utils.assertNodeType)("StringLiteral")
    },
    importKind: {
      validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
      optional: true
    }
  })
});
defineType("ImportDefaultSpecifier", {
  visitor: ["local"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
defineType("ImportNamespaceSpecifier", {
  visitor: ["local"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
defineType("ImportSpecifier", {
  visitor: ["imported", "local"],
  builder: ["local", "imported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    imported: {
      validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
    },
    importKind: {
      validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
      optional: true
    }
  }
});
defineType("ImportE***REMOVED***pression", {
  visitor: ["source", "options"],
  aliases: ["E***REMOVED***pression"],
  fields: {
    phase: {
      default: null,
      validate: (0, _utils.assertOneOf)("source", "defer")
    },
    source: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    },
    options: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression"),
      optional: true
    }
  }
});
defineType("MetaProperty", {
  visitor: ["meta", "property"],
  aliases: ["E***REMOVED***pression"],
  fields: {
    meta: {
      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function (node, key, val) {
        let property;
        switch (val.name) {
          case "function":
            property = "sent";
            break;
          case "new":
            property = "target";
            break;
          case "import":
            property = "meta";
            break;
        }
        if (!(0, _is.default)("Identifier", node.property, {
          name: property
        })) {
          throw new TypeError("Unrecognised MetaProperty");
        }
      }, {
        oneOfNodeTypes: ["Identifier"]
      })) : (0, _utils.assertNodeType)("Identifier")
    },
    property: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
const classMethodOrPropertyCommon = () => ({
  abstract: {
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
  },
  accessibility: {
    validate: (0, _utils.assertOneOf)("public", "private", "protected"),
    optional: true
  },
  static: {
    default: false
  },
  override: {
    default: false
  },
  computed: {
    default: false
  },
  optional: {
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
  },
  key: {
    validate: (0, _utils.chain)(function () {
      const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
      const computed = (0, _utils.assertNodeType)("E***REMOVED***pression");
      return function (node, key, val) {
        const validator = node.computed ? computed : normal;
        validator(node, key, val);
      };
    }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "E***REMOVED***pression"))
  }
});
e***REMOVED***ports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
const classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
  params: (0, _utils.validateArrayOfType)("Identifier", "Pattern", "RestElement", "TSParameterProperty"),
  kind: {
    validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
    default: "method"
  },
  access: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
    optional: true
  },
  decorators: {
    validate: (0, _utils.arrayOfType)("Decorator"),
    optional: true
  }
});
e***REMOVED***ports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
defineType("ClassMethod", {
  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
  builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
  visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
  fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  })
});
defineType("ObjectPattern", {
  visitor: ["properties", "typeAnnotation", "decorators"],
  builder: ["properties"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: Object.assign({}, patternLikeCommon(), {
    properties: (0, _utils.validateArrayOfType)("RestElement", "ObjectProperty")
  })
});
defineType("SpreadElement", {
  visitor: ["argument"],
  aliases: ["UnaryLike"],
  deprecatedAlias: "SpreadProperty",
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    }
  }
});
defineType("Super", {
  aliases: ["E***REMOVED***pression"]
});
defineType("TaggedTemplateE***REMOVED***pression", {
  visitor: ["tag", "typeParameters", "quasi"],
  builder: ["tag", "quasi"],
  aliases: ["E***REMOVED***pression"],
  fields: {
    tag: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    },
    quasi: {
      validate: (0, _utils.assertNodeType)("TemplateLiteral")
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
    }
  }
});
defineType("TemplateElement", {
  builder: ["value", "tail"],
  fields: {
    value: {
      validate: (0, _utils.chain)((0, _utils.assertShape)({
        raw: {
          validate: (0, _utils.assertValueType)("string")
        },
        cooked: {
          validate: (0, _utils.assertValueType)("string"),
          optional: true
        }
      }), function templateElementCookedValidator(node) {
        const raw = node.value.raw;
        let unterminatedCalled = false;
        const error = () => {
          throw new Error("Internal @babel/types error.");
        };
        const {
          str,
          firstInvalidLoc
        } = (0, _helperStringParser.readStringContents)("template", raw, 0, 0, 0, {
          unterminated() {
            unterminatedCalled = true;
          },
          strictNumericEscape: error,
          invalidEscapeSequence: error,
          numericSeparatorInEscapeSequence: error,
          une***REMOVED***pectedNumericSeparator: error,
          invalidDigit: error,
          invalidCodePoint: error
        });
        if (!unterminatedCalled) throw new Error("Invalid raw");
        node.value.cooked = firstInvalidLoc ? null : str;
      })
    },
    tail: {
      default: false
    }
  }
});
defineType("TemplateLiteral", {
  visitor: ["quasis", "e***REMOVED***pressions"],
  aliases: ["E***REMOVED***pression", "Literal"],
  fields: {
    quasis: (0, _utils.validateArrayOfType)("TemplateElement"),
    e***REMOVED***pressions: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("E***REMOVED***pression", "TSType")), function (node, key, val) {
        if (node.quasis.length !== val.length + 1) {
          throw new TypeError(`Number of ${node.type} quasis should be e***REMOVED***actly one more than the number of e***REMOVED***pressions.\nE***REMOVED***pected ${val.length + 1} quasis but got ${node.quasis.length}`);
        }
      })
    }
  }
});
defineType("YieldE***REMOVED***pression", {
  builder: ["argument", "delegate"],
  visitor: ["argument"],
  aliases: ["E***REMOVED***pression", "Terminatorless"],
  fields: {
    delegate: {
      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function (node, key, val) {
        if (val && !node.argument) {
          throw new TypeError("Property delegate of YieldE***REMOVED***pression cannot be true if there is no argument");
        }
      }, {
        type: "boolean"
      })) : (0, _utils.assertValueType)("boolean"),
      default: false
    },
    argument: {
      optional: true,
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    }
  }
});
defineType("AwaitE***REMOVED***pression", {
  builder: ["argument"],
  visitor: ["argument"],
  aliases: ["E***REMOVED***pression", "Terminatorless"],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    }
  }
});
defineType("Import", {
  aliases: ["E***REMOVED***pression"]
});
defineType("BigIntLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  },
  aliases: ["E***REMOVED***pression", "Pureish", "Literal", "Immutable"]
});
defineType("E***REMOVED***portNamespaceSpecifier", {
  visitor: ["e***REMOVED***ported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    e***REMOVED***ported: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
defineType("OptionalMemberE***REMOVED***pression", {
  builder: ["object", "property", "computed", "optional"],
  visitor: ["object", "property"],
  aliases: ["E***REMOVED***pression"],
  fields: {
    object: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    },
    property: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)("Identifier");
        const computed = (0, _utils.assertNodeType)("E***REMOVED***pression");
        const validator = Object.assign(function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        }, {
          oneOfNodeTypes: ["E***REMOVED***pression", "Identifier"]
        });
        return validator;
      }()
    },
    computed: {
      default: false
    },
    optional: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
    }
  }
});
defineType("OptionalCallE***REMOVED***pression", {
  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
  builder: ["callee", "arguments", "optional"],
  aliases: ["E***REMOVED***pression"],
  fields: {
    callee: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression")
    },
    arguments: (0, _utils.validateArrayOfType)("E***REMOVED***pression", "SpreadElement", "ArgumentPlaceholder"),
    optional: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
    },
    typeArguments: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
      optional: true
    }
  }
});
defineType("ClassProperty", {
  visitor: ["decorators", "key", "typeAnnotation", "value"],
  builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
  aliases: ["Property"],
  fields: Object.assign({}, classMethodOrPropertyCommon(), {
    value: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression"),
      optional: true
    },
    definite: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    decorators: {
      validate: (0, _utils.arrayOfType)("Decorator"),
      optional: true
    },
    readonly: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    declare: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    variance: {
      validate: (0, _utils.assertNodeType)("Variance"),
      optional: true
    }
  })
});
defineType("ClassAccessorProperty", {
  visitor: ["decorators", "key", "typeAnnotation", "value"],
  builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
  aliases: ["Property", "Accessor"],
  fields: Object.assign({}, classMethodOrPropertyCommon(), {
    key: {
      validate: (0, _utils.chain)(function () {
        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");
        const computed = (0, _utils.assertNodeType)("E***REMOVED***pression");
        return function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
      }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "E***REMOVED***pression", "PrivateName"))
    },
    value: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression"),
      optional: true
    },
    definite: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    decorators: {
      validate: (0, _utils.arrayOfType)("Decorator"),
      optional: true
    },
    readonly: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    declare: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    variance: {
      validate: (0, _utils.assertNodeType)("Variance"),
      optional: true
    }
  })
});
defineType("ClassPrivateProperty", {
  visitor: ["decorators", "key", "typeAnnotation", "value"],
  builder: ["key", "value", "decorators", "static"],
  aliases: ["Property", "Private"],
  fields: {
    key: {
      validate: (0, _utils.assertNodeType)("PrivateName")
    },
    value: {
      validate: (0, _utils.assertNodeType)("E***REMOVED***pression"),
      optional: true
    },
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    decorators: {
      validate: (0, _utils.arrayOfType)("Decorator"),
      optional: true
    },
    static: {
      validate: (0, _utils.assertValueType)("boolean"),
      default: false
    },
    readonly: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    definite: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    variance: {
      validate: (0, _utils.assertNodeType)("Variance"),
      optional: true
    }
  }
});
defineType("ClassPrivateMethod", {
  builder: ["kind", "key", "params", "body", "static"],
  visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
  fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
    kind: {
      validate: (0, _utils.assertOneOf)("get", "set", "method"),
      default: "method"
    },
    key: {
      validate: (0, _utils.assertNodeType)("PrivateName")
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  })
});
defineType("PrivateName", {
  visitor: ["id"],
  aliases: ["Private"],
  fields: {
    id: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
defineType("StaticBlock", {
  visitor: ["body"],
  fields: {
    body: (0, _utils.validateArrayOfType)("Statement")
  },
  aliases: ["Scopable", "BlockParent", "FunctionParent"]
});

//# sourceMappingURL=core.js.map
