"use strict";

Object.defineProperty(e***REMOVED***ports, "__esModule", {
  value: true
});
e***REMOVED***ports.default = void 0;
var _isValidIdentifier = require("../validators/isValidIdentifier.js");
var _inde***REMOVED*** = require("../builders/generated/inde***REMOVED***.js");
var _default = e***REMOVED***ports.default = valueToNode;
const objectToString = Function.call.bind(Object.prototype.toString);
function isRegE***REMOVED***p(value) {
  return objectToString(value) === "[object RegE***REMOVED***p]";
}
function isPlainObject(value) {
  if (typeof value !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]") {
    return false;
  }
  const proto = Object.getPrototypeOf(value);
  return proto === null || Object.getPrototypeOf(proto) === null;
}
function valueToNode(value) {
  if (value === undefined) {
    return (0, _inde***REMOVED***.identifier)("undefined");
  }
  if (value === true || value === false) {
    return (0, _inde***REMOVED***.booleanLiteral)(value);
  }
  if (value === null) {
    return (0, _inde***REMOVED***.nullLiteral)();
  }
  if (typeof value === "string") {
    return (0, _inde***REMOVED***.stringLiteral)(value);
  }
  if (typeof value === "number") {
    let result;
    if (Number.isFinite(value)) {
      result = (0, _inde***REMOVED***.numericLiteral)(Math.abs(value));
    } else {
      let numerator;
      if (Number.isNaN(value)) {
        numerator = (0, _inde***REMOVED***.numericLiteral)(0);
      } else {
        numerator = (0, _inde***REMOVED***.numericLiteral)(1);
      }
      result = (0, _inde***REMOVED***.binaryE***REMOVED***pression)("/", numerator, (0, _inde***REMOVED***.numericLiteral)(0));
    }
    if (value < 0 || Object.is(value, -0)) {
      result = (0, _inde***REMOVED***.unaryE***REMOVED***pression)("-", result);
    }
    return result;
  }
  if (isRegE***REMOVED***p(value)) {
    const pattern = value.source;
    const flags = /\/([a-z]*)$/.e***REMOVED***ec(value.toString())[1];
    return (0, _inde***REMOVED***.regE***REMOVED***pLiteral)(pattern, flags);
  }
  if (Array.isArray(value)) {
    return (0, _inde***REMOVED***.arrayE***REMOVED***pression)(value.map(valueToNode));
  }
  if (isPlainObject(value)) {
    const props = [];
    for (const key of Object.keys(value)) {
      let nodeKey;
      if ((0, _isValidIdentifier.default)(key)) {
        nodeKey = (0, _inde***REMOVED***.identifier)(key);
      } else {
        nodeKey = (0, _inde***REMOVED***.stringLiteral)(key);
      }
      props.push((0, _inde***REMOVED***.objectProperty)(nodeKey, valueToNode(value[key])));
    }
    return (0, _inde***REMOVED***.objectE***REMOVED***pression)(props);
  }
  throw new Error("don't know how to turn this value into a node");
}

//# sourceMappingURL=valueToNode.js.map
