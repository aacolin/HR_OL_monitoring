"use strict";

Object.defineProperty(e***REMOVED***ports, "__esModule", {
  value: true
});
e***REMOVED***ports.anyTypeAnnotation = anyTypeAnnotation;
e***REMOVED***ports.argumentPlaceholder = argumentPlaceholder;
e***REMOVED***ports.arrayE***REMOVED***pression = arrayE***REMOVED***pression;
e***REMOVED***ports.arrayPattern = arrayPattern;
e***REMOVED***ports.arrayTypeAnnotation = arrayTypeAnnotation;
e***REMOVED***ports.arrowFunctionE***REMOVED***pression = arrowFunctionE***REMOVED***pression;
e***REMOVED***ports.assignmentE***REMOVED***pression = assignmentE***REMOVED***pression;
e***REMOVED***ports.assignmentPattern = assignmentPattern;
e***REMOVED***ports.awaitE***REMOVED***pression = awaitE***REMOVED***pression;
e***REMOVED***ports.bigIntLiteral = bigIntLiteral;
e***REMOVED***ports.binaryE***REMOVED***pression = binaryE***REMOVED***pression;
e***REMOVED***ports.bindE***REMOVED***pression = bindE***REMOVED***pression;
e***REMOVED***ports.blockStatement = blockStatement;
e***REMOVED***ports.booleanLiteral = booleanLiteral;
e***REMOVED***ports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
e***REMOVED***ports.booleanTypeAnnotation = booleanTypeAnnotation;
e***REMOVED***ports.breakStatement = breakStatement;
e***REMOVED***ports.callE***REMOVED***pression = callE***REMOVED***pression;
e***REMOVED***ports.catchClause = catchClause;
e***REMOVED***ports.classAccessorProperty = classAccessorProperty;
e***REMOVED***ports.classBody = classBody;
e***REMOVED***ports.classDeclaration = classDeclaration;
e***REMOVED***ports.classE***REMOVED***pression = classE***REMOVED***pression;
e***REMOVED***ports.classImplements = classImplements;
e***REMOVED***ports.classMethod = classMethod;
e***REMOVED***ports.classPrivateMethod = classPrivateMethod;
e***REMOVED***ports.classPrivateProperty = classPrivateProperty;
e***REMOVED***ports.classProperty = classProperty;
e***REMOVED***ports.conditionalE***REMOVED***pression = conditionalE***REMOVED***pression;
e***REMOVED***ports.continueStatement = continueStatement;
e***REMOVED***ports.debuggerStatement = debuggerStatement;
e***REMOVED***ports.decimalLiteral = decimalLiteral;
e***REMOVED***ports.declareClass = declareClass;
e***REMOVED***ports.declareE***REMOVED***portAllDeclaration = declareE***REMOVED***portAllDeclaration;
e***REMOVED***ports.declareE***REMOVED***portDeclaration = declareE***REMOVED***portDeclaration;
e***REMOVED***ports.declareFunction = declareFunction;
e***REMOVED***ports.declareInterface = declareInterface;
e***REMOVED***ports.declareModule = declareModule;
e***REMOVED***ports.declareModuleE***REMOVED***ports = declareModuleE***REMOVED***ports;
e***REMOVED***ports.declareOpaqueType = declareOpaqueType;
e***REMOVED***ports.declareTypeAlias = declareTypeAlias;
e***REMOVED***ports.declareVariable = declareVariable;
e***REMOVED***ports.declaredPredicate = declaredPredicate;
e***REMOVED***ports.decorator = decorator;
e***REMOVED***ports.directive = directive;
e***REMOVED***ports.directiveLiteral = directiveLiteral;
e***REMOVED***ports.doE***REMOVED***pression = doE***REMOVED***pression;
e***REMOVED***ports.doWhileStatement = doWhileStatement;
e***REMOVED***ports.emptyStatement = emptyStatement;
e***REMOVED***ports.emptyTypeAnnotation = emptyTypeAnnotation;
e***REMOVED***ports.enumBooleanBody = enumBooleanBody;
e***REMOVED***ports.enumBooleanMember = enumBooleanMember;
e***REMOVED***ports.enumDeclaration = enumDeclaration;
e***REMOVED***ports.enumDefaultedMember = enumDefaultedMember;
e***REMOVED***ports.enumNumberBody = enumNumberBody;
e***REMOVED***ports.enumNumberMember = enumNumberMember;
e***REMOVED***ports.enumStringBody = enumStringBody;
e***REMOVED***ports.enumStringMember = enumStringMember;
e***REMOVED***ports.enumSymbolBody = enumSymbolBody;
e***REMOVED***ports.e***REMOVED***istsTypeAnnotation = e***REMOVED***istsTypeAnnotation;
e***REMOVED***ports.e***REMOVED***portAllDeclaration = e***REMOVED***portAllDeclaration;
e***REMOVED***ports.e***REMOVED***portDefaultDeclaration = e***REMOVED***portDefaultDeclaration;
e***REMOVED***ports.e***REMOVED***portDefaultSpecifier = e***REMOVED***portDefaultSpecifier;
e***REMOVED***ports.e***REMOVED***portNamedDeclaration = e***REMOVED***portNamedDeclaration;
e***REMOVED***ports.e***REMOVED***portNamespaceSpecifier = e***REMOVED***portNamespaceSpecifier;
e***REMOVED***ports.e***REMOVED***portSpecifier = e***REMOVED***portSpecifier;
e***REMOVED***ports.e***REMOVED***pressionStatement = e***REMOVED***pressionStatement;
e***REMOVED***ports.file = file;
e***REMOVED***ports.forInStatement = forInStatement;
e***REMOVED***ports.forOfStatement = forOfStatement;
e***REMOVED***ports.forStatement = forStatement;
e***REMOVED***ports.functionDeclaration = functionDeclaration;
e***REMOVED***ports.functionE***REMOVED***pression = functionE***REMOVED***pression;
e***REMOVED***ports.functionTypeAnnotation = functionTypeAnnotation;
e***REMOVED***ports.functionTypeParam = functionTypeParam;
e***REMOVED***ports.genericTypeAnnotation = genericTypeAnnotation;
e***REMOVED***ports.identifier = identifier;
e***REMOVED***ports.ifStatement = ifStatement;
e***REMOVED***ports.import = _import;
e***REMOVED***ports.importAttribute = importAttribute;
e***REMOVED***ports.importDeclaration = importDeclaration;
e***REMOVED***ports.importDefaultSpecifier = importDefaultSpecifier;
e***REMOVED***ports.importE***REMOVED***pression = importE***REMOVED***pression;
e***REMOVED***ports.importNamespaceSpecifier = importNamespaceSpecifier;
e***REMOVED***ports.importSpecifier = importSpecifier;
e***REMOVED***ports.inde***REMOVED***edAccessType = inde***REMOVED***edAccessType;
e***REMOVED***ports.inferredPredicate = inferredPredicate;
e***REMOVED***ports.interfaceDeclaration = interfaceDeclaration;
e***REMOVED***ports.interfaceE***REMOVED***tends = interfaceE***REMOVED***tends;
e***REMOVED***ports.interfaceTypeAnnotation = interfaceTypeAnnotation;
e***REMOVED***ports.interpreterDirective = interpreterDirective;
e***REMOVED***ports.intersectionTypeAnnotation = intersectionTypeAnnotation;
e***REMOVED***ports.jSXAttribute = e***REMOVED***ports.js***REMOVED***Attribute = js***REMOVED***Attribute;
e***REMOVED***ports.jSXClosingElement = e***REMOVED***ports.js***REMOVED***ClosingElement = js***REMOVED***ClosingElement;
e***REMOVED***ports.jSXClosingFragment = e***REMOVED***ports.js***REMOVED***ClosingFragment = js***REMOVED***ClosingFragment;
e***REMOVED***ports.jSXElement = e***REMOVED***ports.js***REMOVED***Element = js***REMOVED***Element;
e***REMOVED***ports.jSXEmptyE***REMOVED***pression = e***REMOVED***ports.js***REMOVED***EmptyE***REMOVED***pression = js***REMOVED***EmptyE***REMOVED***pression;
e***REMOVED***ports.jSXE***REMOVED***pressionContainer = e***REMOVED***ports.js***REMOVED***E***REMOVED***pressionContainer = js***REMOVED***E***REMOVED***pressionContainer;
e***REMOVED***ports.jSXFragment = e***REMOVED***ports.js***REMOVED***Fragment = js***REMOVED***Fragment;
e***REMOVED***ports.jSXIdentifier = e***REMOVED***ports.js***REMOVED***Identifier = js***REMOVED***Identifier;
e***REMOVED***ports.jSXMemberE***REMOVED***pression = e***REMOVED***ports.js***REMOVED***MemberE***REMOVED***pression = js***REMOVED***MemberE***REMOVED***pression;
e***REMOVED***ports.jSXNamespacedName = e***REMOVED***ports.js***REMOVED***NamespacedName = js***REMOVED***NamespacedName;
e***REMOVED***ports.jSXOpeningElement = e***REMOVED***ports.js***REMOVED***OpeningElement = js***REMOVED***OpeningElement;
e***REMOVED***ports.jSXOpeningFragment = e***REMOVED***ports.js***REMOVED***OpeningFragment = js***REMOVED***OpeningFragment;
e***REMOVED***ports.jSXSpreadAttribute = e***REMOVED***ports.js***REMOVED***SpreadAttribute = js***REMOVED***SpreadAttribute;
e***REMOVED***ports.jSXSpreadChild = e***REMOVED***ports.js***REMOVED***SpreadChild = js***REMOVED***SpreadChild;
e***REMOVED***ports.jSXTe***REMOVED***t = e***REMOVED***ports.js***REMOVED***Te***REMOVED***t = js***REMOVED***Te***REMOVED***t;
e***REMOVED***ports.labeledStatement = labeledStatement;
e***REMOVED***ports.logicalE***REMOVED***pression = logicalE***REMOVED***pression;
e***REMOVED***ports.memberE***REMOVED***pression = memberE***REMOVED***pression;
e***REMOVED***ports.metaProperty = metaProperty;
e***REMOVED***ports.mi***REMOVED***edTypeAnnotation = mi***REMOVED***edTypeAnnotation;
e***REMOVED***ports.moduleE***REMOVED***pression = moduleE***REMOVED***pression;
e***REMOVED***ports.newE***REMOVED***pression = newE***REMOVED***pression;
e***REMOVED***ports.noop = noop;
e***REMOVED***ports.nullLiteral = nullLiteral;
e***REMOVED***ports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
e***REMOVED***ports.nullableTypeAnnotation = nullableTypeAnnotation;
e***REMOVED***ports.numberLiteral = NumberLiteral;
e***REMOVED***ports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
e***REMOVED***ports.numberTypeAnnotation = numberTypeAnnotation;
e***REMOVED***ports.numericLiteral = numericLiteral;
e***REMOVED***ports.objectE***REMOVED***pression = objectE***REMOVED***pression;
e***REMOVED***ports.objectMethod = objectMethod;
e***REMOVED***ports.objectPattern = objectPattern;
e***REMOVED***ports.objectProperty = objectProperty;
e***REMOVED***ports.objectTypeAnnotation = objectTypeAnnotation;
e***REMOVED***ports.objectTypeCallProperty = objectTypeCallProperty;
e***REMOVED***ports.objectTypeInde***REMOVED***er = objectTypeInde***REMOVED***er;
e***REMOVED***ports.objectTypeInternalSlot = objectTypeInternalSlot;
e***REMOVED***ports.objectTypeProperty = objectTypeProperty;
e***REMOVED***ports.objectTypeSpreadProperty = objectTypeSpreadProperty;
e***REMOVED***ports.opaqueType = opaqueType;
e***REMOVED***ports.optionalCallE***REMOVED***pression = optionalCallE***REMOVED***pression;
e***REMOVED***ports.optionalInde***REMOVED***edAccessType = optionalInde***REMOVED***edAccessType;
e***REMOVED***ports.optionalMemberE***REMOVED***pression = optionalMemberE***REMOVED***pression;
e***REMOVED***ports.parenthesizedE***REMOVED***pression = parenthesizedE***REMOVED***pression;
e***REMOVED***ports.pipelineBareFunction = pipelineBareFunction;
e***REMOVED***ports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
e***REMOVED***ports.pipelineTopicE***REMOVED***pression = pipelineTopicE***REMOVED***pression;
e***REMOVED***ports.placeholder = placeholder;
e***REMOVED***ports.privateName = privateName;
e***REMOVED***ports.program = program;
e***REMOVED***ports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
e***REMOVED***ports.recordE***REMOVED***pression = recordE***REMOVED***pression;
e***REMOVED***ports.regE***REMOVED***pLiteral = regE***REMOVED***pLiteral;
e***REMOVED***ports.rege***REMOVED***Literal = Rege***REMOVED***Literal;
e***REMOVED***ports.restElement = restElement;
e***REMOVED***ports.restProperty = RestProperty;
e***REMOVED***ports.returnStatement = returnStatement;
e***REMOVED***ports.sequenceE***REMOVED***pression = sequenceE***REMOVED***pression;
e***REMOVED***ports.spreadElement = spreadElement;
e***REMOVED***ports.spreadProperty = SpreadProperty;
e***REMOVED***ports.staticBlock = staticBlock;
e***REMOVED***ports.stringLiteral = stringLiteral;
e***REMOVED***ports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
e***REMOVED***ports.stringTypeAnnotation = stringTypeAnnotation;
e***REMOVED***ports.super = _super;
e***REMOVED***ports.switchCase = switchCase;
e***REMOVED***ports.switchStatement = switchStatement;
e***REMOVED***ports.symbolTypeAnnotation = symbolTypeAnnotation;
e***REMOVED***ports.taggedTemplateE***REMOVED***pression = taggedTemplateE***REMOVED***pression;
e***REMOVED***ports.templateElement = templateElement;
e***REMOVED***ports.templateLiteral = templateLiteral;
e***REMOVED***ports.thisE***REMOVED***pression = thisE***REMOVED***pression;
e***REMOVED***ports.thisTypeAnnotation = thisTypeAnnotation;
e***REMOVED***ports.throwStatement = throwStatement;
e***REMOVED***ports.topicReference = topicReference;
e***REMOVED***ports.tryStatement = tryStatement;
e***REMOVED***ports.tSAnyKeyword = e***REMOVED***ports.tsAnyKeyword = tsAnyKeyword;
e***REMOVED***ports.tSArrayType = e***REMOVED***ports.tsArrayType = tsArrayType;
e***REMOVED***ports.tSAsE***REMOVED***pression = e***REMOVED***ports.tsAsE***REMOVED***pression = tsAsE***REMOVED***pression;
e***REMOVED***ports.tSBigIntKeyword = e***REMOVED***ports.tsBigIntKeyword = tsBigIntKeyword;
e***REMOVED***ports.tSBooleanKeyword = e***REMOVED***ports.tsBooleanKeyword = tsBooleanKeyword;
e***REMOVED***ports.tSCallSignatureDeclaration = e***REMOVED***ports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
e***REMOVED***ports.tSConditionalType = e***REMOVED***ports.tsConditionalType = tsConditionalType;
e***REMOVED***ports.tSConstructSignatureDeclaration = e***REMOVED***ports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
e***REMOVED***ports.tSConstructorType = e***REMOVED***ports.tsConstructorType = tsConstructorType;
e***REMOVED***ports.tSDeclareFunction = e***REMOVED***ports.tsDeclareFunction = tsDeclareFunction;
e***REMOVED***ports.tSDeclareMethod = e***REMOVED***ports.tsDeclareMethod = tsDeclareMethod;
e***REMOVED***ports.tSEnumDeclaration = e***REMOVED***ports.tsEnumDeclaration = tsEnumDeclaration;
e***REMOVED***ports.tSEnumMember = e***REMOVED***ports.tsEnumMember = tsEnumMember;
e***REMOVED***ports.tSE***REMOVED***portAssignment = e***REMOVED***ports.tsE***REMOVED***portAssignment = tsE***REMOVED***portAssignment;
e***REMOVED***ports.tSE***REMOVED***pressionWithTypeArguments = e***REMOVED***ports.tsE***REMOVED***pressionWithTypeArguments = tsE***REMOVED***pressionWithTypeArguments;
e***REMOVED***ports.tSE***REMOVED***ternalModuleReference = e***REMOVED***ports.tsE***REMOVED***ternalModuleReference = tsE***REMOVED***ternalModuleReference;
e***REMOVED***ports.tSFunctionType = e***REMOVED***ports.tsFunctionType = tsFunctionType;
e***REMOVED***ports.tSImportEqualsDeclaration = e***REMOVED***ports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
e***REMOVED***ports.tSImportType = e***REMOVED***ports.tsImportType = tsImportType;
e***REMOVED***ports.tSInde***REMOVED***Signature = e***REMOVED***ports.tsInde***REMOVED***Signature = tsInde***REMOVED***Signature;
e***REMOVED***ports.tSInde***REMOVED***edAccessType = e***REMOVED***ports.tsInde***REMOVED***edAccessType = tsInde***REMOVED***edAccessType;
e***REMOVED***ports.tSInferType = e***REMOVED***ports.tsInferType = tsInferType;
e***REMOVED***ports.tSInstantiationE***REMOVED***pression = e***REMOVED***ports.tsInstantiationE***REMOVED***pression = tsInstantiationE***REMOVED***pression;
e***REMOVED***ports.tSInterfaceBody = e***REMOVED***ports.tsInterfaceBody = tsInterfaceBody;
e***REMOVED***ports.tSInterfaceDeclaration = e***REMOVED***ports.tsInterfaceDeclaration = tsInterfaceDeclaration;
e***REMOVED***ports.tSIntersectionType = e***REMOVED***ports.tsIntersectionType = tsIntersectionType;
e***REMOVED***ports.tSIntrinsicKeyword = e***REMOVED***ports.tsIntrinsicKeyword = tsIntrinsicKeyword;
e***REMOVED***ports.tSLiteralType = e***REMOVED***ports.tsLiteralType = tsLiteralType;
e***REMOVED***ports.tSMappedType = e***REMOVED***ports.tsMappedType = tsMappedType;
e***REMOVED***ports.tSMethodSignature = e***REMOVED***ports.tsMethodSignature = tsMethodSignature;
e***REMOVED***ports.tSModuleBlock = e***REMOVED***ports.tsModuleBlock = tsModuleBlock;
e***REMOVED***ports.tSModuleDeclaration = e***REMOVED***ports.tsModuleDeclaration = tsModuleDeclaration;
e***REMOVED***ports.tSNamedTupleMember = e***REMOVED***ports.tsNamedTupleMember = tsNamedTupleMember;
e***REMOVED***ports.tSNamespaceE***REMOVED***portDeclaration = e***REMOVED***ports.tsNamespaceE***REMOVED***portDeclaration = tsNamespaceE***REMOVED***portDeclaration;
e***REMOVED***ports.tSNeverKeyword = e***REMOVED***ports.tsNeverKeyword = tsNeverKeyword;
e***REMOVED***ports.tSNonNullE***REMOVED***pression = e***REMOVED***ports.tsNonNullE***REMOVED***pression = tsNonNullE***REMOVED***pression;
e***REMOVED***ports.tSNullKeyword = e***REMOVED***ports.tsNullKeyword = tsNullKeyword;
e***REMOVED***ports.tSNumberKeyword = e***REMOVED***ports.tsNumberKeyword = tsNumberKeyword;
e***REMOVED***ports.tSObjectKeyword = e***REMOVED***ports.tsObjectKeyword = tsObjectKeyword;
e***REMOVED***ports.tSOptionalType = e***REMOVED***ports.tsOptionalType = tsOptionalType;
e***REMOVED***ports.tSParameterProperty = e***REMOVED***ports.tsParameterProperty = tsParameterProperty;
e***REMOVED***ports.tSParenthesizedType = e***REMOVED***ports.tsParenthesizedType = tsParenthesizedType;
e***REMOVED***ports.tSPropertySignature = e***REMOVED***ports.tsPropertySignature = tsPropertySignature;
e***REMOVED***ports.tSQualifiedName = e***REMOVED***ports.tsQualifiedName = tsQualifiedName;
e***REMOVED***ports.tSRestType = e***REMOVED***ports.tsRestType = tsRestType;
e***REMOVED***ports.tSSatisfiesE***REMOVED***pression = e***REMOVED***ports.tsSatisfiesE***REMOVED***pression = tsSatisfiesE***REMOVED***pression;
e***REMOVED***ports.tSStringKeyword = e***REMOVED***ports.tsStringKeyword = tsStringKeyword;
e***REMOVED***ports.tSSymbolKeyword = e***REMOVED***ports.tsSymbolKeyword = tsSymbolKeyword;
e***REMOVED***ports.tSThisType = e***REMOVED***ports.tsThisType = tsThisType;
e***REMOVED***ports.tSTupleType = e***REMOVED***ports.tsTupleType = tsTupleType;
e***REMOVED***ports.tSTypeAliasDeclaration = e***REMOVED***ports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
e***REMOVED***ports.tSTypeAnnotation = e***REMOVED***ports.tsTypeAnnotation = tsTypeAnnotation;
e***REMOVED***ports.tSTypeAssertion = e***REMOVED***ports.tsTypeAssertion = tsTypeAssertion;
e***REMOVED***ports.tSTypeLiteral = e***REMOVED***ports.tsTypeLiteral = tsTypeLiteral;
e***REMOVED***ports.tSTypeOperator = e***REMOVED***ports.tsTypeOperator = tsTypeOperator;
e***REMOVED***ports.tSTypeParameter = e***REMOVED***ports.tsTypeParameter = tsTypeParameter;
e***REMOVED***ports.tSTypeParameterDeclaration = e***REMOVED***ports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
e***REMOVED***ports.tSTypeParameterInstantiation = e***REMOVED***ports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
e***REMOVED***ports.tSTypePredicate = e***REMOVED***ports.tsTypePredicate = tsTypePredicate;
e***REMOVED***ports.tSTypeQuery = e***REMOVED***ports.tsTypeQuery = tsTypeQuery;
e***REMOVED***ports.tSTypeReference = e***REMOVED***ports.tsTypeReference = tsTypeReference;
e***REMOVED***ports.tSUndefinedKeyword = e***REMOVED***ports.tsUndefinedKeyword = tsUndefinedKeyword;
e***REMOVED***ports.tSUnionType = e***REMOVED***ports.tsUnionType = tsUnionType;
e***REMOVED***ports.tSUnknownKeyword = e***REMOVED***ports.tsUnknownKeyword = tsUnknownKeyword;
e***REMOVED***ports.tSVoidKeyword = e***REMOVED***ports.tsVoidKeyword = tsVoidKeyword;
e***REMOVED***ports.tupleE***REMOVED***pression = tupleE***REMOVED***pression;
e***REMOVED***ports.tupleTypeAnnotation = tupleTypeAnnotation;
e***REMOVED***ports.typeAlias = typeAlias;
e***REMOVED***ports.typeAnnotation = typeAnnotation;
e***REMOVED***ports.typeCastE***REMOVED***pression = typeCastE***REMOVED***pression;
e***REMOVED***ports.typeParameter = typeParameter;
e***REMOVED***ports.typeParameterDeclaration = typeParameterDeclaration;
e***REMOVED***ports.typeParameterInstantiation = typeParameterInstantiation;
e***REMOVED***ports.typeofTypeAnnotation = typeofTypeAnnotation;
e***REMOVED***ports.unaryE***REMOVED***pression = unaryE***REMOVED***pression;
e***REMOVED***ports.unionTypeAnnotation = unionTypeAnnotation;
e***REMOVED***ports.updateE***REMOVED***pression = updateE***REMOVED***pression;
e***REMOVED***ports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
e***REMOVED***ports.variableDeclaration = variableDeclaration;
e***REMOVED***ports.variableDeclarator = variableDeclarator;
e***REMOVED***ports.variance = variance;
e***REMOVED***ports.voidTypeAnnotation = voidTypeAnnotation;
e***REMOVED***ports.whileStatement = whileStatement;
e***REMOVED***ports.withStatement = withStatement;
e***REMOVED***ports.yieldE***REMOVED***pression = yieldE***REMOVED***pression;
var _validate = require("../../validators/validate.js");
var _deprecationWarning = require("../../utils/deprecationWarning.js");
var utils = require("../../definitions/utils.js");
const {
  validateInternal: validate
} = _validate;
const {
  NODE_FIELDS
} = utils;
function arrayE***REMOVED***pression(elements = []) {
  const node = {
    type: "ArrayE***REMOVED***pression",
    elements
  };
  const defs = NODE_FIELDS.ArrayE***REMOVED***pression;
  validate(defs.elements, node, "elements", elements, 1);
  return node;
}
function assignmentE***REMOVED***pression(operator, left, right) {
  const node = {
    type: "AssignmentE***REMOVED***pression",
    operator,
    left,
    right
  };
  const defs = NODE_FIELDS.AssignmentE***REMOVED***pression;
  validate(defs.operator, node, "operator", operator);
  validate(defs.left, node, "left", left, 1);
  validate(defs.right, node, "right", right, 1);
  return node;
}
function binaryE***REMOVED***pression(operator, left, right) {
  const node = {
    type: "BinaryE***REMOVED***pression",
    operator,
    left,
    right
  };
  const defs = NODE_FIELDS.BinaryE***REMOVED***pression;
  validate(defs.operator, node, "operator", operator);
  validate(defs.left, node, "left", left, 1);
  validate(defs.right, node, "right", right, 1);
  return node;
}
function interpreterDirective(value) {
  const node = {
    type: "InterpreterDirective",
    value
  };
  const defs = NODE_FIELDS.InterpreterDirective;
  validate(defs.value, node, "value", value);
  return node;
}
function directive(value) {
  const node = {
    type: "Directive",
    value
  };
  const defs = NODE_FIELDS.Directive;
  validate(defs.value, node, "value", value, 1);
  return node;
}
function directiveLiteral(value) {
  const node = {
    type: "DirectiveLiteral",
    value
  };
  const defs = NODE_FIELDS.DirectiveLiteral;
  validate(defs.value, node, "value", value);
  return node;
}
function blockStatement(body, directives = []) {
  const node = {
    type: "BlockStatement",
    body,
    directives
  };
  const defs = NODE_FIELDS.BlockStatement;
  validate(defs.body, node, "body", body, 1);
  validate(defs.directives, node, "directives", directives, 1);
  return node;
}
function breakStatement(label = null) {
  const node = {
    type: "BreakStatement",
    label
  };
  const defs = NODE_FIELDS.BreakStatement;
  validate(defs.label, node, "label", label, 1);
  return node;
}
function callE***REMOVED***pression(callee, _arguments) {
  const node = {
    type: "CallE***REMOVED***pression",
    callee,
    arguments: _arguments
  };
  const defs = NODE_FIELDS.CallE***REMOVED***pression;
  validate(defs.callee, node, "callee", callee, 1);
  validate(defs.arguments, node, "arguments", _arguments, 1);
  return node;
}
function catchClause(param = null, body) {
  const node = {
    type: "CatchClause",
    param,
    body
  };
  const defs = NODE_FIELDS.CatchClause;
  validate(defs.param, node, "param", param, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}
function conditionalE***REMOVED***pression(test, consequent, alternate) {
  const node = {
    type: "ConditionalE***REMOVED***pression",
    test,
    consequent,
    alternate
  };
  const defs = NODE_FIELDS.ConditionalE***REMOVED***pression;
  validate(defs.test, node, "test", test, 1);
  validate(defs.consequent, node, "consequent", consequent, 1);
  validate(defs.alternate, node, "alternate", alternate, 1);
  return node;
}
function continueStatement(label = null) {
  const node = {
    type: "ContinueStatement",
    label
  };
  const defs = NODE_FIELDS.ContinueStatement;
  validate(defs.label, node, "label", label, 1);
  return node;
}
function debuggerStatement() {
  return {
    type: "DebuggerStatement"
  };
}
function doWhileStatement(test, body) {
  const node = {
    type: "DoWhileStatement",
    test,
    body
  };
  const defs = NODE_FIELDS.DoWhileStatement;
  validate(defs.test, node, "test", test, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}
function emptyStatement() {
  return {
    type: "EmptyStatement"
  };
}
function e***REMOVED***pressionStatement(e***REMOVED***pression) {
  const node = {
    type: "E***REMOVED***pressionStatement",
    e***REMOVED***pression
  };
  const defs = NODE_FIELDS.E***REMOVED***pressionStatement;
  validate(defs.e***REMOVED***pression, node, "e***REMOVED***pression", e***REMOVED***pression, 1);
  return node;
}
function file(program, comments = null, tokens = null) {
  const node = {
    type: "File",
    program,
    comments,
    tokens
  };
  const defs = NODE_FIELDS.File;
  validate(defs.program, node, "program", program, 1);
  validate(defs.comments, node, "comments", comments, 1);
  validate(defs.tokens, node, "tokens", tokens);
  return node;
}
function forInStatement(left, right, body) {
  const node = {
    type: "ForInStatement",
    left,
    right,
    body
  };
  const defs = NODE_FIELDS.ForInStatement;
  validate(defs.left, node, "left", left, 1);
  validate(defs.right, node, "right", right, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}
function forStatement(init = null, test = null, update = null, body) {
  const node = {
    type: "ForStatement",
    init,
    test,
    update,
    body
  };
  const defs = NODE_FIELDS.ForStatement;
  validate(defs.init, node, "init", init, 1);
  validate(defs.test, node, "test", test, 1);
  validate(defs.update, node, "update", update, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}
function functionDeclaration(id = null, params, body, generator = false, async = false) {
  const node = {
    type: "FunctionDeclaration",
    id,
    params,
    body,
    generator,
    async
  };
  const defs = NODE_FIELDS.FunctionDeclaration;
  validate(defs.id, node, "id", id, 1);
  validate(defs.params, node, "params", params, 1);
  validate(defs.body, node, "body", body, 1);
  validate(defs.generator, node, "generator", generator);
  validate(defs.async, node, "async", async);
  return node;
}
function functionE***REMOVED***pression(id = null, params, body, generator = false, async = false) {
  const node = {
    type: "FunctionE***REMOVED***pression",
    id,
    params,
    body,
    generator,
    async
  };
  const defs = NODE_FIELDS.FunctionE***REMOVED***pression;
  validate(defs.id, node, "id", id, 1);
  validate(defs.params, node, "params", params, 1);
  validate(defs.body, node, "body", body, 1);
  validate(defs.generator, node, "generator", generator);
  validate(defs.async, node, "async", async);
  return node;
}
function identifier(name) {
  const node = {
    type: "Identifier",
    name
  };
  const defs = NODE_FIELDS.Identifier;
  validate(defs.name, node, "name", name);
  return node;
}
function ifStatement(test, consequent, alternate = null) {
  const node = {
    type: "IfStatement",
    test,
    consequent,
    alternate
  };
  const defs = NODE_FIELDS.IfStatement;
  validate(defs.test, node, "test", test, 1);
  validate(defs.consequent, node, "consequent", consequent, 1);
  validate(defs.alternate, node, "alternate", alternate, 1);
  return node;
}
function labeledStatement(label, body) {
  const node = {
    type: "LabeledStatement",
    label,
    body
  };
  const defs = NODE_FIELDS.LabeledStatement;
  validate(defs.label, node, "label", label, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}
function stringLiteral(value) {
  const node = {
    type: "StringLiteral",
    value
  };
  const defs = NODE_FIELDS.StringLiteral;
  validate(defs.value, node, "value", value);
  return node;
}
function numericLiteral(value) {
  const node = {
    type: "NumericLiteral",
    value
  };
  const defs = NODE_FIELDS.NumericLiteral;
  validate(defs.value, node, "value", value);
  return node;
}
function nullLiteral() {
  return {
    type: "NullLiteral"
  };
}
function booleanLiteral(value) {
  const node = {
    type: "BooleanLiteral",
    value
  };
  const defs = NODE_FIELDS.BooleanLiteral;
  validate(defs.value, node, "value", value);
  return node;
}
function regE***REMOVED***pLiteral(pattern, flags = "") {
  const node = {
    type: "RegE***REMOVED***pLiteral",
    pattern,
    flags
  };
  const defs = NODE_FIELDS.RegE***REMOVED***pLiteral;
  validate(defs.pattern, node, "pattern", pattern);
  validate(defs.flags, node, "flags", flags);
  return node;
}
function logicalE***REMOVED***pression(operator, left, right) {
  const node = {
    type: "LogicalE***REMOVED***pression",
    operator,
    left,
    right
  };
  const defs = NODE_FIELDS.LogicalE***REMOVED***pression;
  validate(defs.operator, node, "operator", operator);
  validate(defs.left, node, "left", left, 1);
  validate(defs.right, node, "right", right, 1);
  return node;
}
function memberE***REMOVED***pression(object, property, computed = false, optional = null) {
  const node = {
    type: "MemberE***REMOVED***pression",
    object,
    property,
    computed,
    optional
  };
  const defs = NODE_FIELDS.MemberE***REMOVED***pression;
  validate(defs.object, node, "object", object, 1);
  validate(defs.property, node, "property", property, 1);
  validate(defs.computed, node, "computed", computed);
  validate(defs.optional, node, "optional", optional);
  return node;
}
function newE***REMOVED***pression(callee, _arguments) {
  const node = {
    type: "NewE***REMOVED***pression",
    callee,
    arguments: _arguments
  };
  const defs = NODE_FIELDS.NewE***REMOVED***pression;
  validate(defs.callee, node, "callee", callee, 1);
  validate(defs.arguments, node, "arguments", _arguments, 1);
  return node;
}
function program(body, directives = [], sourceType = "script", interpreter = null) {
  const node = {
    type: "Program",
    body,
    directives,
    sourceType,
    interpreter
  };
  const defs = NODE_FIELDS.Program;
  validate(defs.body, node, "body", body, 1);
  validate(defs.directives, node, "directives", directives, 1);
  validate(defs.sourceType, node, "sourceType", sourceType);
  validate(defs.interpreter, node, "interpreter", interpreter, 1);
  return node;
}
function objectE***REMOVED***pression(properties) {
  const node = {
    type: "ObjectE***REMOVED***pression",
    properties
  };
  const defs = NODE_FIELDS.ObjectE***REMOVED***pression;
  validate(defs.properties, node, "properties", properties, 1);
  return node;
}
function objectMethod(kind = "method", key, params, body, computed = false, generator = false, async = false) {
  const node = {
    type: "ObjectMethod",
    kind,
    key,
    params,
    body,
    computed,
    generator,
    async
  };
  const defs = NODE_FIELDS.ObjectMethod;
  validate(defs.kind, node, "kind", kind);
  validate(defs.key, node, "key", key, 1);
  validate(defs.params, node, "params", params, 1);
  validate(defs.body, node, "body", body, 1);
  validate(defs.computed, node, "computed", computed);
  validate(defs.generator, node, "generator", generator);
  validate(defs.async, node, "async", async);
  return node;
}
function objectProperty(key, value, computed = false, shorthand = false, decorators = null) {
  const node = {
    type: "ObjectProperty",
    key,
    value,
    computed,
    shorthand,
    decorators
  };
  const defs = NODE_FIELDS.ObjectProperty;
  validate(defs.key, node, "key", key, 1);
  validate(defs.value, node, "value", value, 1);
  validate(defs.computed, node, "computed", computed);
  validate(defs.shorthand, node, "shorthand", shorthand);
  validate(defs.decorators, node, "decorators", decorators, 1);
  return node;
}
function restElement(argument) {
  const node = {
    type: "RestElement",
    argument
  };
  const defs = NODE_FIELDS.RestElement;
  validate(defs.argument, node, "argument", argument, 1);
  return node;
}
function returnStatement(argument = null) {
  const node = {
    type: "ReturnStatement",
    argument
  };
  const defs = NODE_FIELDS.ReturnStatement;
  validate(defs.argument, node, "argument", argument, 1);
  return node;
}
function sequenceE***REMOVED***pression(e***REMOVED***pressions) {
  const node = {
    type: "SequenceE***REMOVED***pression",
    e***REMOVED***pressions
  };
  const defs = NODE_FIELDS.SequenceE***REMOVED***pression;
  validate(defs.e***REMOVED***pressions, node, "e***REMOVED***pressions", e***REMOVED***pressions, 1);
  return node;
}
function parenthesizedE***REMOVED***pression(e***REMOVED***pression) {
  const node = {
    type: "ParenthesizedE***REMOVED***pression",
    e***REMOVED***pression
  };
  const defs = NODE_FIELDS.ParenthesizedE***REMOVED***pression;
  validate(defs.e***REMOVED***pression, node, "e***REMOVED***pression", e***REMOVED***pression, 1);
  return node;
}
function switchCase(test = null, consequent) {
  const node = {
    type: "SwitchCase",
    test,
    consequent
  };
  const defs = NODE_FIELDS.SwitchCase;
  validate(defs.test, node, "test", test, 1);
  validate(defs.consequent, node, "consequent", consequent, 1);
  return node;
}
function switchStatement(discriminant, cases) {
  const node = {
    type: "SwitchStatement",
    discriminant,
    cases
  };
  const defs = NODE_FIELDS.SwitchStatement;
  validate(defs.discriminant, node, "discriminant", discriminant, 1);
  validate(defs.cases, node, "cases", cases, 1);
  return node;
}
function thisE***REMOVED***pression() {
  return {
    type: "ThisE***REMOVED***pression"
  };
}
function throwStatement(argument) {
  const node = {
    type: "ThrowStatement",
    argument
  };
  const defs = NODE_FIELDS.ThrowStatement;
  validate(defs.argument, node, "argument", argument, 1);
  return node;
}
function tryStatement(block, handler = null, finalizer = null) {
  const node = {
    type: "TryStatement",
    block,
    handler,
    finalizer
  };
  const defs = NODE_FIELDS.TryStatement;
  validate(defs.block, node, "block", block, 1);
  validate(defs.handler, node, "handler", handler, 1);
  validate(defs.finalizer, node, "finalizer", finalizer, 1);
  return node;
}
function unaryE***REMOVED***pression(operator, argument, prefi***REMOVED*** = true) {
  const node = {
    type: "UnaryE***REMOVED***pression",
    operator,
    argument,
    prefi***REMOVED***
  };
  const defs = NODE_FIELDS.UnaryE***REMOVED***pression;
  validate(defs.operator, node, "operator", operator);
  validate(defs.argument, node, "argument", argument, 1);
  validate(defs.prefi***REMOVED***, node, "prefi***REMOVED***", prefi***REMOVED***);
  return node;
}
function updateE***REMOVED***pression(operator, argument, prefi***REMOVED*** = false) {
  const node = {
    type: "UpdateE***REMOVED***pression",
    operator,
    argument,
    prefi***REMOVED***
  };
  const defs = NODE_FIELDS.UpdateE***REMOVED***pression;
  validate(defs.operator, node, "operator", operator);
  validate(defs.argument, node, "argument", argument, 1);
  validate(defs.prefi***REMOVED***, node, "prefi***REMOVED***", prefi***REMOVED***);
  return node;
}
function variableDeclaration(kind, declarations) {
  const node = {
    type: "VariableDeclaration",
    kind,
    declarations
  };
  const defs = NODE_FIELDS.VariableDeclaration;
  validate(defs.kind, node, "kind", kind);
  validate(defs.declarations, node, "declarations", declarations, 1);
  return node;
}
function variableDeclarator(id, init = null) {
  const node = {
    type: "VariableDeclarator",
    id,
    init
  };
  const defs = NODE_FIELDS.VariableDeclarator;
  validate(defs.id, node, "id", id, 1);
  validate(defs.init, node, "init", init, 1);
  return node;
}
function whileStatement(test, body) {
  const node = {
    type: "WhileStatement",
    test,
    body
  };
  const defs = NODE_FIELDS.WhileStatement;
  validate(defs.test, node, "test", test, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}
function withStatement(object, body) {
  const node = {
    type: "WithStatement",
    object,
    body
  };
  const defs = NODE_FIELDS.WithStatement;
  validate(defs.object, node, "object", object, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}
function assignmentPattern(left, right) {
  const node = {
    type: "AssignmentPattern",
    left,
    right
  };
  const defs = NODE_FIELDS.AssignmentPattern;
  validate(defs.left, node, "left", left, 1);
  validate(defs.right, node, "right", right, 1);
  return node;
}
function arrayPattern(elements) {
  const node = {
    type: "ArrayPattern",
    elements
  };
  const defs = NODE_FIELDS.ArrayPattern;
  validate(defs.elements, node, "elements", elements, 1);
  return node;
}
function arrowFunctionE***REMOVED***pression(params, body, async = false) {
  const node = {
    type: "ArrowFunctionE***REMOVED***pression",
    params,
    body,
    async,
    e***REMOVED***pression: null
  };
  const defs = NODE_FIELDS.ArrowFunctionE***REMOVED***pression;
  validate(defs.params, node, "params", params, 1);
  validate(defs.body, node, "body", body, 1);
  validate(defs.async, node, "async", async);
  return node;
}
function classBody(body) {
  const node = {
    type: "ClassBody",
    body
  };
  const defs = NODE_FIELDS.ClassBody;
  validate(defs.body, node, "body", body, 1);
  return node;
}
function classE***REMOVED***pression(id = null, superClass = null, body, decorators = null) {
  const node = {
    type: "ClassE***REMOVED***pression",
    id,
    superClass,
    body,
    decorators
  };
  const defs = NODE_FIELDS.ClassE***REMOVED***pression;
  validate(defs.id, node, "id", id, 1);
  validate(defs.superClass, node, "superClass", superClass, 1);
  validate(defs.body, node, "body", body, 1);
  validate(defs.decorators, node, "decorators", decorators, 1);
  return node;
}
function classDeclaration(id = null, superClass = null, body, decorators = null) {
  const node = {
    type: "ClassDeclaration",
    id,
    superClass,
    body,
    decorators
  };
  const defs = NODE_FIELDS.ClassDeclaration;
  validate(defs.id, node, "id", id, 1);
  validate(defs.superClass, node, "superClass", superClass, 1);
  validate(defs.body, node, "body", body, 1);
  validate(defs.decorators, node, "decorators", decorators, 1);
  return node;
}
function e***REMOVED***portAllDeclaration(source) {
  const node = {
    type: "E***REMOVED***portAllDeclaration",
    source
  };
  const defs = NODE_FIELDS.E***REMOVED***portAllDeclaration;
  validate(defs.source, node, "source", source, 1);
  return node;
}
function e***REMOVED***portDefaultDeclaration(declaration) {
  const node = {
    type: "E***REMOVED***portDefaultDeclaration",
    declaration
  };
  const defs = NODE_FIELDS.E***REMOVED***portDefaultDeclaration;
  validate(defs.declaration, node, "declaration", declaration, 1);
  return node;
}
function e***REMOVED***portNamedDeclaration(declaration = null, specifiers = [], source = null) {
  const node = {
    type: "E***REMOVED***portNamedDeclaration",
    declaration,
    specifiers,
    source
  };
  const defs = NODE_FIELDS.E***REMOVED***portNamedDeclaration;
  validate(defs.declaration, node, "declaration", declaration, 1);
  validate(defs.specifiers, node, "specifiers", specifiers, 1);
  validate(defs.source, node, "source", source, 1);
  return node;
}
function e***REMOVED***portSpecifier(local, e***REMOVED***ported) {
  const node = {
    type: "E***REMOVED***portSpecifier",
    local,
    e***REMOVED***ported
  };
  const defs = NODE_FIELDS.E***REMOVED***portSpecifier;
  validate(defs.local, node, "local", local, 1);
  validate(defs.e***REMOVED***ported, node, "e***REMOVED***ported", e***REMOVED***ported, 1);
  return node;
}
function forOfStatement(left, right, body, _await = false) {
  const node = {
    type: "ForOfStatement",
    left,
    right,
    body,
    await: _await
  };
  const defs = NODE_FIELDS.ForOfStatement;
  validate(defs.left, node, "left", left, 1);
  validate(defs.right, node, "right", right, 1);
  validate(defs.body, node, "body", body, 1);
  validate(defs.await, node, "await", _await);
  return node;
}
function importDeclaration(specifiers, source) {
  const node = {
    type: "ImportDeclaration",
    specifiers,
    source
  };
  const defs = NODE_FIELDS.ImportDeclaration;
  validate(defs.specifiers, node, "specifiers", specifiers, 1);
  validate(defs.source, node, "source", source, 1);
  return node;
}
function importDefaultSpecifier(local) {
  const node = {
    type: "ImportDefaultSpecifier",
    local
  };
  const defs = NODE_FIELDS.ImportDefaultSpecifier;
  validate(defs.local, node, "local", local, 1);
  return node;
}
function importNamespaceSpecifier(local) {
  const node = {
    type: "ImportNamespaceSpecifier",
    local
  };
  const defs = NODE_FIELDS.ImportNamespaceSpecifier;
  validate(defs.local, node, "local", local, 1);
  return node;
}
function importSpecifier(local, imported) {
  const node = {
    type: "ImportSpecifier",
    local,
    imported
  };
  const defs = NODE_FIELDS.ImportSpecifier;
  validate(defs.local, node, "local", local, 1);
  validate(defs.imported, node, "imported", imported, 1);
  return node;
}
function importE***REMOVED***pression(source, options = null) {
  const node = {
    type: "ImportE***REMOVED***pression",
    source,
    options
  };
  const defs = NODE_FIELDS.ImportE***REMOVED***pression;
  validate(defs.source, node, "source", source, 1);
  validate(defs.options, node, "options", options, 1);
  return node;
}
function metaProperty(meta, property) {
  const node = {
    type: "MetaProperty",
    meta,
    property
  };
  const defs = NODE_FIELDS.MetaProperty;
  validate(defs.meta, node, "meta", meta, 1);
  validate(defs.property, node, "property", property, 1);
  return node;
}
function classMethod(kind = "method", key, params, body, computed = false, _static = false, generator = false, async = false) {
  const node = {
    type: "ClassMethod",
    kind,
    key,
    params,
    body,
    computed,
    static: _static,
    generator,
    async
  };
  const defs = NODE_FIELDS.ClassMethod;
  validate(defs.kind, node, "kind", kind);
  validate(defs.key, node, "key", key, 1);
  validate(defs.params, node, "params", params, 1);
  validate(defs.body, node, "body", body, 1);
  validate(defs.computed, node, "computed", computed);
  validate(defs.static, node, "static", _static);
  validate(defs.generator, node, "generator", generator);
  validate(defs.async, node, "async", async);
  return node;
}
function objectPattern(properties) {
  const node = {
    type: "ObjectPattern",
    properties
  };
  const defs = NODE_FIELDS.ObjectPattern;
  validate(defs.properties, node, "properties", properties, 1);
  return node;
}
function spreadElement(argument) {
  const node = {
    type: "SpreadElement",
    argument
  };
  const defs = NODE_FIELDS.SpreadElement;
  validate(defs.argument, node, "argument", argument, 1);
  return node;
}
function _super() {
  return {
    type: "Super"
  };
}
function taggedTemplateE***REMOVED***pression(tag, quasi) {
  const node = {
    type: "TaggedTemplateE***REMOVED***pression",
    tag,
    quasi
  };
  const defs = NODE_FIELDS.TaggedTemplateE***REMOVED***pression;
  validate(defs.tag, node, "tag", tag, 1);
  validate(defs.quasi, node, "quasi", quasi, 1);
  return node;
}
function templateElement(value, tail = false) {
  const node = {
    type: "TemplateElement",
    value,
    tail
  };
  const defs = NODE_FIELDS.TemplateElement;
  validate(defs.value, node, "value", value);
  validate(defs.tail, node, "tail", tail);
  return node;
}
function templateLiteral(quasis, e***REMOVED***pressions) {
  const node = {
    type: "TemplateLiteral",
    quasis,
    e***REMOVED***pressions
  };
  const defs = NODE_FIELDS.TemplateLiteral;
  validate(defs.quasis, node, "quasis", quasis, 1);
  validate(defs.e***REMOVED***pressions, node, "e***REMOVED***pressions", e***REMOVED***pressions, 1);
  return node;
}
function yieldE***REMOVED***pression(argument = null, delegate = false) {
  const node = {
    type: "YieldE***REMOVED***pression",
    argument,
    delegate
  };
  const defs = NODE_FIELDS.YieldE***REMOVED***pression;
  validate(defs.argument, node, "argument", argument, 1);
  validate(defs.delegate, node, "delegate", delegate);
  return node;
}
function awaitE***REMOVED***pression(argument) {
  const node = {
    type: "AwaitE***REMOVED***pression",
    argument
  };
  const defs = NODE_FIELDS.AwaitE***REMOVED***pression;
  validate(defs.argument, node, "argument", argument, 1);
  return node;
}
function _import() {
  return {
    type: "Import"
  };
}
function bigIntLiteral(value) {
  const node = {
    type: "BigIntLiteral",
    value
  };
  const defs = NODE_FIELDS.BigIntLiteral;
  validate(defs.value, node, "value", value);
  return node;
}
function e***REMOVED***portNamespaceSpecifier(e***REMOVED***ported) {
  const node = {
    type: "E***REMOVED***portNamespaceSpecifier",
    e***REMOVED***ported
  };
  const defs = NODE_FIELDS.E***REMOVED***portNamespaceSpecifier;
  validate(defs.e***REMOVED***ported, node, "e***REMOVED***ported", e***REMOVED***ported, 1);
  return node;
}
function optionalMemberE***REMOVED***pression(object, property, computed = false, optional) {
  const node = {
    type: "OptionalMemberE***REMOVED***pression",
    object,
    property,
    computed,
    optional
  };
  const defs = NODE_FIELDS.OptionalMemberE***REMOVED***pression;
  validate(defs.object, node, "object", object, 1);
  validate(defs.property, node, "property", property, 1);
  validate(defs.computed, node, "computed", computed);
  validate(defs.optional, node, "optional", optional);
  return node;
}
function optionalCallE***REMOVED***pression(callee, _arguments, optional) {
  const node = {
    type: "OptionalCallE***REMOVED***pression",
    callee,
    arguments: _arguments,
    optional
  };
  const defs = NODE_FIELDS.OptionalCallE***REMOVED***pression;
  validate(defs.callee, node, "callee", callee, 1);
  validate(defs.arguments, node, "arguments", _arguments, 1);
  validate(defs.optional, node, "optional", optional);
  return node;
}
function classProperty(key, value = null, typeAnnotation = null, decorators = null, computed = false, _static = false) {
  const node = {
    type: "ClassProperty",
    key,
    value,
    typeAnnotation,
    decorators,
    computed,
    static: _static
  };
  const defs = NODE_FIELDS.ClassProperty;
  validate(defs.key, node, "key", key, 1);
  validate(defs.value, node, "value", value, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  validate(defs.decorators, node, "decorators", decorators, 1);
  validate(defs.computed, node, "computed", computed);
  validate(defs.static, node, "static", _static);
  return node;
}
function classAccessorProperty(key, value = null, typeAnnotation = null, decorators = null, computed = false, _static = false) {
  const node = {
    type: "ClassAccessorProperty",
    key,
    value,
    typeAnnotation,
    decorators,
    computed,
    static: _static
  };
  const defs = NODE_FIELDS.ClassAccessorProperty;
  validate(defs.key, node, "key", key, 1);
  validate(defs.value, node, "value", value, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  validate(defs.decorators, node, "decorators", decorators, 1);
  validate(defs.computed, node, "computed", computed);
  validate(defs.static, node, "static", _static);
  return node;
}
function classPrivateProperty(key, value = null, decorators = null, _static = false) {
  const node = {
    type: "ClassPrivateProperty",
    key,
    value,
    decorators,
    static: _static
  };
  const defs = NODE_FIELDS.ClassPrivateProperty;
  validate(defs.key, node, "key", key, 1);
  validate(defs.value, node, "value", value, 1);
  validate(defs.decorators, node, "decorators", decorators, 1);
  validate(defs.static, node, "static", _static);
  return node;
}
function classPrivateMethod(kind = "method", key, params, body, _static = false) {
  const node = {
    type: "ClassPrivateMethod",
    kind,
    key,
    params,
    body,
    static: _static
  };
  const defs = NODE_FIELDS.ClassPrivateMethod;
  validate(defs.kind, node, "kind", kind);
  validate(defs.key, node, "key", key, 1);
  validate(defs.params, node, "params", params, 1);
  validate(defs.body, node, "body", body, 1);
  validate(defs.static, node, "static", _static);
  return node;
}
function privateName(id) {
  const node = {
    type: "PrivateName",
    id
  };
  const defs = NODE_FIELDS.PrivateName;
  validate(defs.id, node, "id", id, 1);
  return node;
}
function staticBlock(body) {
  const node = {
    type: "StaticBlock",
    body
  };
  const defs = NODE_FIELDS.StaticBlock;
  validate(defs.body, node, "body", body, 1);
  return node;
}
function anyTypeAnnotation() {
  return {
    type: "AnyTypeAnnotation"
  };
}
function arrayTypeAnnotation(elementType) {
  const node = {
    type: "ArrayTypeAnnotation",
    elementType
  };
  const defs = NODE_FIELDS.ArrayTypeAnnotation;
  validate(defs.elementType, node, "elementType", elementType, 1);
  return node;
}
function booleanTypeAnnotation() {
  return {
    type: "BooleanTypeAnnotation"
  };
}
function booleanLiteralTypeAnnotation(value) {
  const node = {
    type: "BooleanLiteralTypeAnnotation",
    value
  };
  const defs = NODE_FIELDS.BooleanLiteralTypeAnnotation;
  validate(defs.value, node, "value", value);
  return node;
}
function nullLiteralTypeAnnotation() {
  return {
    type: "NullLiteralTypeAnnotation"
  };
}
function classImplements(id, typeParameters = null) {
  const node = {
    type: "ClassImplements",
    id,
    typeParameters
  };
  const defs = NODE_FIELDS.ClassImplements;
  validate(defs.id, node, "id", id, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  return node;
}
function declareClass(id, typeParameters = null, _e***REMOVED***tends = null, body) {
  const node = {
    type: "DeclareClass",
    id,
    typeParameters,
    e***REMOVED***tends: _e***REMOVED***tends,
    body
  };
  const defs = NODE_FIELDS.DeclareClass;
  validate(defs.id, node, "id", id, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.e***REMOVED***tends, node, "e***REMOVED***tends", _e***REMOVED***tends, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}
function declareFunction(id) {
  const node = {
    type: "DeclareFunction",
    id
  };
  const defs = NODE_FIELDS.DeclareFunction;
  validate(defs.id, node, "id", id, 1);
  return node;
}
function declareInterface(id, typeParameters = null, _e***REMOVED***tends = null, body) {
  const node = {
    type: "DeclareInterface",
    id,
    typeParameters,
    e***REMOVED***tends: _e***REMOVED***tends,
    body
  };
  const defs = NODE_FIELDS.DeclareInterface;
  validate(defs.id, node, "id", id, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.e***REMOVED***tends, node, "e***REMOVED***tends", _e***REMOVED***tends, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}
function declareModule(id, body, kind = null) {
  const node = {
    type: "DeclareModule",
    id,
    body,
    kind
  };
  const defs = NODE_FIELDS.DeclareModule;
  validate(defs.id, node, "id", id, 1);
  validate(defs.body, node, "body", body, 1);
  validate(defs.kind, node, "kind", kind);
  return node;
}
function declareModuleE***REMOVED***ports(typeAnnotation) {
  const node = {
    type: "DeclareModuleE***REMOVED***ports",
    typeAnnotation
  };
  const defs = NODE_FIELDS.DeclareModuleE***REMOVED***ports;
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}
function declareTypeAlias(id, typeParameters = null, right) {
  const node = {
    type: "DeclareTypeAlias",
    id,
    typeParameters,
    right
  };
  const defs = NODE_FIELDS.DeclareTypeAlias;
  validate(defs.id, node, "id", id, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.right, node, "right", right, 1);
  return node;
}
function declareOpaqueType(id, typeParameters = null, supertype = null) {
  const node = {
    type: "DeclareOpaqueType",
    id,
    typeParameters,
    supertype
  };
  const defs = NODE_FIELDS.DeclareOpaqueType;
  validate(defs.id, node, "id", id, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.supertype, node, "supertype", supertype, 1);
  return node;
}
function declareVariable(id) {
  const node = {
    type: "DeclareVariable",
    id
  };
  const defs = NODE_FIELDS.DeclareVariable;
  validate(defs.id, node, "id", id, 1);
  return node;
}
function declareE***REMOVED***portDeclaration(declaration = null, specifiers = null, source = null, attributes = null) {
  const node = {
    type: "DeclareE***REMOVED***portDeclaration",
    declaration,
    specifiers,
    source,
    attributes
  };
  const defs = NODE_FIELDS.DeclareE***REMOVED***portDeclaration;
  validate(defs.declaration, node, "declaration", declaration, 1);
  validate(defs.specifiers, node, "specifiers", specifiers, 1);
  validate(defs.source, node, "source", source, 1);
  validate(defs.attributes, node, "attributes", attributes, 1);
  return node;
}
function declareE***REMOVED***portAllDeclaration(source, attributes = null) {
  const node = {
    type: "DeclareE***REMOVED***portAllDeclaration",
    source,
    attributes
  };
  const defs = NODE_FIELDS.DeclareE***REMOVED***portAllDeclaration;
  validate(defs.source, node, "source", source, 1);
  validate(defs.attributes, node, "attributes", attributes, 1);
  return node;
}
function declaredPredicate(value) {
  const node = {
    type: "DeclaredPredicate",
    value
  };
  const defs = NODE_FIELDS.DeclaredPredicate;
  validate(defs.value, node, "value", value, 1);
  return node;
}
function e***REMOVED***istsTypeAnnotation() {
  return {
    type: "E***REMOVED***istsTypeAnnotation"
  };
}
function functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {
  const node = {
    type: "FunctionTypeAnnotation",
    typeParameters,
    params,
    rest,
    returnType
  };
  const defs = NODE_FIELDS.FunctionTypeAnnotation;
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.params, node, "params", params, 1);
  validate(defs.rest, node, "rest", rest, 1);
  validate(defs.returnType, node, "returnType", returnType, 1);
  return node;
}
function functionTypeParam(name = null, typeAnnotation) {
  const node = {
    type: "FunctionTypeParam",
    name,
    typeAnnotation
  };
  const defs = NODE_FIELDS.FunctionTypeParam;
  validate(defs.name, node, "name", name, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}
function genericTypeAnnotation(id, typeParameters = null) {
  const node = {
    type: "GenericTypeAnnotation",
    id,
    typeParameters
  };
  const defs = NODE_FIELDS.GenericTypeAnnotation;
  validate(defs.id, node, "id", id, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  return node;
}
function inferredPredicate() {
  return {
    type: "InferredPredicate"
  };
}
function interfaceE***REMOVED***tends(id, typeParameters = null) {
  const node = {
    type: "InterfaceE***REMOVED***tends",
    id,
    typeParameters
  };
  const defs = NODE_FIELDS.InterfaceE***REMOVED***tends;
  validate(defs.id, node, "id", id, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  return node;
}
function interfaceDeclaration(id, typeParameters = null, _e***REMOVED***tends = null, body) {
  const node = {
    type: "InterfaceDeclaration",
    id,
    typeParameters,
    e***REMOVED***tends: _e***REMOVED***tends,
    body
  };
  const defs = NODE_FIELDS.InterfaceDeclaration;
  validate(defs.id, node, "id", id, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.e***REMOVED***tends, node, "e***REMOVED***tends", _e***REMOVED***tends, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}
function interfaceTypeAnnotation(_e***REMOVED***tends = null, body) {
  const node = {
    type: "InterfaceTypeAnnotation",
    e***REMOVED***tends: _e***REMOVED***tends,
    body
  };
  const defs = NODE_FIELDS.InterfaceTypeAnnotation;
  validate(defs.e***REMOVED***tends, node, "e***REMOVED***tends", _e***REMOVED***tends, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}
function intersectionTypeAnnotation(types) {
  const node = {
    type: "IntersectionTypeAnnotation",
    types
  };
  const defs = NODE_FIELDS.IntersectionTypeAnnotation;
  validate(defs.types, node, "types", types, 1);
  return node;
}
function mi***REMOVED***edTypeAnnotation() {
  return {
    type: "Mi***REMOVED***edTypeAnnotation"
  };
}
function emptyTypeAnnotation() {
  return {
    type: "EmptyTypeAnnotation"
  };
}
function nullableTypeAnnotation(typeAnnotation) {
  const node = {
    type: "NullableTypeAnnotation",
    typeAnnotation
  };
  const defs = NODE_FIELDS.NullableTypeAnnotation;
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}
function numberLiteralTypeAnnotation(value) {
  const node = {
    type: "NumberLiteralTypeAnnotation",
    value
  };
  const defs = NODE_FIELDS.NumberLiteralTypeAnnotation;
  validate(defs.value, node, "value", value);
  return node;
}
function numberTypeAnnotation() {
  return {
    type: "NumberTypeAnnotation"
  };
}
function objectTypeAnnotation(properties, inde***REMOVED***ers = [], callProperties = [], internalSlots = [], e***REMOVED***act = false) {
  const node = {
    type: "ObjectTypeAnnotation",
    properties,
    inde***REMOVED***ers,
    callProperties,
    internalSlots,
    e***REMOVED***act
  };
  const defs = NODE_FIELDS.ObjectTypeAnnotation;
  validate(defs.properties, node, "properties", properties, 1);
  validate(defs.inde***REMOVED***ers, node, "inde***REMOVED***ers", inde***REMOVED***ers, 1);
  validate(defs.callProperties, node, "callProperties", callProperties, 1);
  validate(defs.internalSlots, node, "internalSlots", internalSlots, 1);
  validate(defs.e***REMOVED***act, node, "e***REMOVED***act", e***REMOVED***act);
  return node;
}
function objectTypeInternalSlot(id, value, optional, _static, method) {
  const node = {
    type: "ObjectTypeInternalSlot",
    id,
    value,
    optional,
    static: _static,
    method
  };
  const defs = NODE_FIELDS.ObjectTypeInternalSlot;
  validate(defs.id, node, "id", id, 1);
  validate(defs.value, node, "value", value, 1);
  validate(defs.optional, node, "optional", optional);
  validate(defs.static, node, "static", _static);
  validate(defs.method, node, "method", method);
  return node;
}
function objectTypeCallProperty(value) {
  const node = {
    type: "ObjectTypeCallProperty",
    value,
    static: null
  };
  const defs = NODE_FIELDS.ObjectTypeCallProperty;
  validate(defs.value, node, "value", value, 1);
  return node;
}
function objectTypeInde***REMOVED***er(id = null, key, value, variance = null) {
  const node = {
    type: "ObjectTypeInde***REMOVED***er",
    id,
    key,
    value,
    variance,
    static: null
  };
  const defs = NODE_FIELDS.ObjectTypeInde***REMOVED***er;
  validate(defs.id, node, "id", id, 1);
  validate(defs.key, node, "key", key, 1);
  validate(defs.value, node, "value", value, 1);
  validate(defs.variance, node, "variance", variance, 1);
  return node;
}
function objectTypeProperty(key, value, variance = null) {
  const node = {
    type: "ObjectTypeProperty",
    key,
    value,
    variance,
    kind: null,
    method: null,
    optional: null,
    proto: null,
    static: null
  };
  const defs = NODE_FIELDS.ObjectTypeProperty;
  validate(defs.key, node, "key", key, 1);
  validate(defs.value, node, "value", value, 1);
  validate(defs.variance, node, "variance", variance, 1);
  return node;
}
function objectTypeSpreadProperty(argument) {
  const node = {
    type: "ObjectTypeSpreadProperty",
    argument
  };
  const defs = NODE_FIELDS.ObjectTypeSpreadProperty;
  validate(defs.argument, node, "argument", argument, 1);
  return node;
}
function opaqueType(id, typeParameters = null, supertype = null, impltype) {
  const node = {
    type: "OpaqueType",
    id,
    typeParameters,
    supertype,
    impltype
  };
  const defs = NODE_FIELDS.OpaqueType;
  validate(defs.id, node, "id", id, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.supertype, node, "supertype", supertype, 1);
  validate(defs.impltype, node, "impltype", impltype, 1);
  return node;
}
function qualifiedTypeIdentifier(id, qualification) {
  const node = {
    type: "QualifiedTypeIdentifier",
    id,
    qualification
  };
  const defs = NODE_FIELDS.QualifiedTypeIdentifier;
  validate(defs.id, node, "id", id, 1);
  validate(defs.qualification, node, "qualification", qualification, 1);
  return node;
}
function stringLiteralTypeAnnotation(value) {
  const node = {
    type: "StringLiteralTypeAnnotation",
    value
  };
  const defs = NODE_FIELDS.StringLiteralTypeAnnotation;
  validate(defs.value, node, "value", value);
  return node;
}
function stringTypeAnnotation() {
  return {
    type: "StringTypeAnnotation"
  };
}
function symbolTypeAnnotation() {
  return {
    type: "SymbolTypeAnnotation"
  };
}
function thisTypeAnnotation() {
  return {
    type: "ThisTypeAnnotation"
  };
}
function tupleTypeAnnotation(types) {
  const node = {
    type: "TupleTypeAnnotation",
    types
  };
  const defs = NODE_FIELDS.TupleTypeAnnotation;
  validate(defs.types, node, "types", types, 1);
  return node;
}
function typeofTypeAnnotation(argument) {
  const node = {
    type: "TypeofTypeAnnotation",
    argument
  };
  const defs = NODE_FIELDS.TypeofTypeAnnotation;
  validate(defs.argument, node, "argument", argument, 1);
  return node;
}
function typeAlias(id, typeParameters = null, right) {
  const node = {
    type: "TypeAlias",
    id,
    typeParameters,
    right
  };
  const defs = NODE_FIELDS.TypeAlias;
  validate(defs.id, node, "id", id, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.right, node, "right", right, 1);
  return node;
}
function typeAnnotation(typeAnnotation) {
  const node = {
    type: "TypeAnnotation",
    typeAnnotation
  };
  const defs = NODE_FIELDS.TypeAnnotation;
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}
function typeCastE***REMOVED***pression(e***REMOVED***pression, typeAnnotation) {
  const node = {
    type: "TypeCastE***REMOVED***pression",
    e***REMOVED***pression,
    typeAnnotation
  };
  const defs = NODE_FIELDS.TypeCastE***REMOVED***pression;
  validate(defs.e***REMOVED***pression, node, "e***REMOVED***pression", e***REMOVED***pression, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}
function typeParameter(bound = null, _default = null, variance = null) {
  const node = {
    type: "TypeParameter",
    bound,
    default: _default,
    variance,
    name: null
  };
  const defs = NODE_FIELDS.TypeParameter;
  validate(defs.bound, node, "bound", bound, 1);
  validate(defs.default, node, "default", _default, 1);
  validate(defs.variance, node, "variance", variance, 1);
  return node;
}
function typeParameterDeclaration(params) {
  const node = {
    type: "TypeParameterDeclaration",
    params
  };
  const defs = NODE_FIELDS.TypeParameterDeclaration;
  validate(defs.params, node, "params", params, 1);
  return node;
}
function typeParameterInstantiation(params) {
  const node = {
    type: "TypeParameterInstantiation",
    params
  };
  const defs = NODE_FIELDS.TypeParameterInstantiation;
  validate(defs.params, node, "params", params, 1);
  return node;
}
function unionTypeAnnotation(types) {
  const node = {
    type: "UnionTypeAnnotation",
    types
  };
  const defs = NODE_FIELDS.UnionTypeAnnotation;
  validate(defs.types, node, "types", types, 1);
  return node;
}
function variance(kind) {
  const node = {
    type: "Variance",
    kind
  };
  const defs = NODE_FIELDS.Variance;
  validate(defs.kind, node, "kind", kind);
  return node;
}
function voidTypeAnnotation() {
  return {
    type: "VoidTypeAnnotation"
  };
}
function enumDeclaration(id, body) {
  const node = {
    type: "EnumDeclaration",
    id,
    body
  };
  const defs = NODE_FIELDS.EnumDeclaration;
  validate(defs.id, node, "id", id, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}
function enumBooleanBody(members) {
  const node = {
    type: "EnumBooleanBody",
    members,
    e***REMOVED***plicitType: null,
    hasUnknownMembers: null
  };
  const defs = NODE_FIELDS.EnumBooleanBody;
  validate(defs.members, node, "members", members, 1);
  return node;
}
function enumNumberBody(members) {
  const node = {
    type: "EnumNumberBody",
    members,
    e***REMOVED***plicitType: null,
    hasUnknownMembers: null
  };
  const defs = NODE_FIELDS.EnumNumberBody;
  validate(defs.members, node, "members", members, 1);
  return node;
}
function enumStringBody(members) {
  const node = {
    type: "EnumStringBody",
    members,
    e***REMOVED***plicitType: null,
    hasUnknownMembers: null
  };
  const defs = NODE_FIELDS.EnumStringBody;
  validate(defs.members, node, "members", members, 1);
  return node;
}
function enumSymbolBody(members) {
  const node = {
    type: "EnumSymbolBody",
    members,
    hasUnknownMembers: null
  };
  const defs = NODE_FIELDS.EnumSymbolBody;
  validate(defs.members, node, "members", members, 1);
  return node;
}
function enumBooleanMember(id) {
  const node = {
    type: "EnumBooleanMember",
    id,
    init: null
  };
  const defs = NODE_FIELDS.EnumBooleanMember;
  validate(defs.id, node, "id", id, 1);
  return node;
}
function enumNumberMember(id, init) {
  const node = {
    type: "EnumNumberMember",
    id,
    init
  };
  const defs = NODE_FIELDS.EnumNumberMember;
  validate(defs.id, node, "id", id, 1);
  validate(defs.init, node, "init", init, 1);
  return node;
}
function enumStringMember(id, init) {
  const node = {
    type: "EnumStringMember",
    id,
    init
  };
  const defs = NODE_FIELDS.EnumStringMember;
  validate(defs.id, node, "id", id, 1);
  validate(defs.init, node, "init", init, 1);
  return node;
}
function enumDefaultedMember(id) {
  const node = {
    type: "EnumDefaultedMember",
    id
  };
  const defs = NODE_FIELDS.EnumDefaultedMember;
  validate(defs.id, node, "id", id, 1);
  return node;
}
function inde***REMOVED***edAccessType(objectType, inde***REMOVED***Type) {
  const node = {
    type: "Inde***REMOVED***edAccessType",
    objectType,
    inde***REMOVED***Type
  };
  const defs = NODE_FIELDS.Inde***REMOVED***edAccessType;
  validate(defs.objectType, node, "objectType", objectType, 1);
  validate(defs.inde***REMOVED***Type, node, "inde***REMOVED***Type", inde***REMOVED***Type, 1);
  return node;
}
function optionalInde***REMOVED***edAccessType(objectType, inde***REMOVED***Type) {
  const node = {
    type: "OptionalInde***REMOVED***edAccessType",
    objectType,
    inde***REMOVED***Type,
    optional: null
  };
  const defs = NODE_FIELDS.OptionalInde***REMOVED***edAccessType;
  validate(defs.objectType, node, "objectType", objectType, 1);
  validate(defs.inde***REMOVED***Type, node, "inde***REMOVED***Type", inde***REMOVED***Type, 1);
  return node;
}
function js***REMOVED***Attribute(name, value = null) {
  const node = {
    type: "JSXAttribute",
    name,
    value
  };
  const defs = NODE_FIELDS.JSXAttribute;
  validate(defs.name, node, "name", name, 1);
  validate(defs.value, node, "value", value, 1);
  return node;
}
function js***REMOVED***ClosingElement(name) {
  const node = {
    type: "JSXClosingElement",
    name
  };
  const defs = NODE_FIELDS.JSXClosingElement;
  validate(defs.name, node, "name", name, 1);
  return node;
}
function js***REMOVED***Element(openingElement, closingElement = null, children, selfClosing = null) {
  const node = {
    type: "JSXElement",
    openingElement,
    closingElement,
    children,
    selfClosing
  };
  const defs = NODE_FIELDS.JSXElement;
  validate(defs.openingElement, node, "openingElement", openingElement, 1);
  validate(defs.closingElement, node, "closingElement", closingElement, 1);
  validate(defs.children, node, "children", children, 1);
  validate(defs.selfClosing, node, "selfClosing", selfClosing);
  return node;
}
function js***REMOVED***EmptyE***REMOVED***pression() {
  return {
    type: "JSXEmptyE***REMOVED***pression"
  };
}
function js***REMOVED***E***REMOVED***pressionContainer(e***REMOVED***pression) {
  const node = {
    type: "JSXE***REMOVED***pressionContainer",
    e***REMOVED***pression
  };
  const defs = NODE_FIELDS.JSXE***REMOVED***pressionContainer;
  validate(defs.e***REMOVED***pression, node, "e***REMOVED***pression", e***REMOVED***pression, 1);
  return node;
}
function js***REMOVED***SpreadChild(e***REMOVED***pression) {
  const node = {
    type: "JSXSpreadChild",
    e***REMOVED***pression
  };
  const defs = NODE_FIELDS.JSXSpreadChild;
  validate(defs.e***REMOVED***pression, node, "e***REMOVED***pression", e***REMOVED***pression, 1);
  return node;
}
function js***REMOVED***Identifier(name) {
  const node = {
    type: "JSXIdentifier",
    name
  };
  const defs = NODE_FIELDS.JSXIdentifier;
  validate(defs.name, node, "name", name);
  return node;
}
function js***REMOVED***MemberE***REMOVED***pression(object, property) {
  const node = {
    type: "JSXMemberE***REMOVED***pression",
    object,
    property
  };
  const defs = NODE_FIELDS.JSXMemberE***REMOVED***pression;
  validate(defs.object, node, "object", object, 1);
  validate(defs.property, node, "property", property, 1);
  return node;
}
function js***REMOVED***NamespacedName(namespace, name) {
  const node = {
    type: "JSXNamespacedName",
    namespace,
    name
  };
  const defs = NODE_FIELDS.JSXNamespacedName;
  validate(defs.namespace, node, "namespace", namespace, 1);
  validate(defs.name, node, "name", name, 1);
  return node;
}
function js***REMOVED***OpeningElement(name, attributes, selfClosing = false) {
  const node = {
    type: "JSXOpeningElement",
    name,
    attributes,
    selfClosing
  };
  const defs = NODE_FIELDS.JSXOpeningElement;
  validate(defs.name, node, "name", name, 1);
  validate(defs.attributes, node, "attributes", attributes, 1);
  validate(defs.selfClosing, node, "selfClosing", selfClosing);
  return node;
}
function js***REMOVED***SpreadAttribute(argument) {
  const node = {
    type: "JSXSpreadAttribute",
    argument
  };
  const defs = NODE_FIELDS.JSXSpreadAttribute;
  validate(defs.argument, node, "argument", argument, 1);
  return node;
}
function js***REMOVED***Te***REMOVED***t(value) {
  const node = {
    type: "JSXTe***REMOVED***t",
    value
  };
  const defs = NODE_FIELDS.JSXTe***REMOVED***t;
  validate(defs.value, node, "value", value);
  return node;
}
function js***REMOVED***Fragment(openingFragment, closingFragment, children) {
  const node = {
    type: "JSXFragment",
    openingFragment,
    closingFragment,
    children
  };
  const defs = NODE_FIELDS.JSXFragment;
  validate(defs.openingFragment, node, "openingFragment", openingFragment, 1);
  validate(defs.closingFragment, node, "closingFragment", closingFragment, 1);
  validate(defs.children, node, "children", children, 1);
  return node;
}
function js***REMOVED***OpeningFragment() {
  return {
    type: "JSXOpeningFragment"
  };
}
function js***REMOVED***ClosingFragment() {
  return {
    type: "JSXClosingFragment"
  };
}
function noop() {
  return {
    type: "Noop"
  };
}
function placeholder(e***REMOVED***pectedNode, name) {
  const node = {
    type: "Placeholder",
    e***REMOVED***pectedNode,
    name
  };
  const defs = NODE_FIELDS.Placeholder;
  validate(defs.e***REMOVED***pectedNode, node, "e***REMOVED***pectedNode", e***REMOVED***pectedNode);
  validate(defs.name, node, "name", name, 1);
  return node;
}
function v8IntrinsicIdentifier(name) {
  const node = {
    type: "V8IntrinsicIdentifier",
    name
  };
  const defs = NODE_FIELDS.V8IntrinsicIdentifier;
  validate(defs.name, node, "name", name);
  return node;
}
function argumentPlaceholder() {
  return {
    type: "ArgumentPlaceholder"
  };
}
function bindE***REMOVED***pression(object, callee) {
  const node = {
    type: "BindE***REMOVED***pression",
    object,
    callee
  };
  const defs = NODE_FIELDS.BindE***REMOVED***pression;
  validate(defs.object, node, "object", object, 1);
  validate(defs.callee, node, "callee", callee, 1);
  return node;
}
function importAttribute(key, value) {
  const node = {
    type: "ImportAttribute",
    key,
    value
  };
  const defs = NODE_FIELDS.ImportAttribute;
  validate(defs.key, node, "key", key, 1);
  validate(defs.value, node, "value", value, 1);
  return node;
}
function decorator(e***REMOVED***pression) {
  const node = {
    type: "Decorator",
    e***REMOVED***pression
  };
  const defs = NODE_FIELDS.Decorator;
  validate(defs.e***REMOVED***pression, node, "e***REMOVED***pression", e***REMOVED***pression, 1);
  return node;
}
function doE***REMOVED***pression(body, async = false) {
  const node = {
    type: "DoE***REMOVED***pression",
    body,
    async
  };
  const defs = NODE_FIELDS.DoE***REMOVED***pression;
  validate(defs.body, node, "body", body, 1);
  validate(defs.async, node, "async", async);
  return node;
}
function e***REMOVED***portDefaultSpecifier(e***REMOVED***ported) {
  const node = {
    type: "E***REMOVED***portDefaultSpecifier",
    e***REMOVED***ported
  };
  const defs = NODE_FIELDS.E***REMOVED***portDefaultSpecifier;
  validate(defs.e***REMOVED***ported, node, "e***REMOVED***ported", e***REMOVED***ported, 1);
  return node;
}
function recordE***REMOVED***pression(properties) {
  const node = {
    type: "RecordE***REMOVED***pression",
    properties
  };
  const defs = NODE_FIELDS.RecordE***REMOVED***pression;
  validate(defs.properties, node, "properties", properties, 1);
  return node;
}
function tupleE***REMOVED***pression(elements = []) {
  const node = {
    type: "TupleE***REMOVED***pression",
    elements
  };
  const defs = NODE_FIELDS.TupleE***REMOVED***pression;
  validate(defs.elements, node, "elements", elements, 1);
  return node;
}
function decimalLiteral(value) {
  const node = {
    type: "DecimalLiteral",
    value
  };
  const defs = NODE_FIELDS.DecimalLiteral;
  validate(defs.value, node, "value", value);
  return node;
}
function moduleE***REMOVED***pression(body) {
  const node = {
    type: "ModuleE***REMOVED***pression",
    body
  };
  const defs = NODE_FIELDS.ModuleE***REMOVED***pression;
  validate(defs.body, node, "body", body, 1);
  return node;
}
function topicReference() {
  return {
    type: "TopicReference"
  };
}
function pipelineTopicE***REMOVED***pression(e***REMOVED***pression) {
  const node = {
    type: "PipelineTopicE***REMOVED***pression",
    e***REMOVED***pression
  };
  const defs = NODE_FIELDS.PipelineTopicE***REMOVED***pression;
  validate(defs.e***REMOVED***pression, node, "e***REMOVED***pression", e***REMOVED***pression, 1);
  return node;
}
function pipelineBareFunction(callee) {
  const node = {
    type: "PipelineBareFunction",
    callee
  };
  const defs = NODE_FIELDS.PipelineBareFunction;
  validate(defs.callee, node, "callee", callee, 1);
  return node;
}
function pipelinePrimaryTopicReference() {
  return {
    type: "PipelinePrimaryTopicReference"
  };
}
function tsParameterProperty(parameter) {
  const node = {
    type: "TSParameterProperty",
    parameter
  };
  const defs = NODE_FIELDS.TSParameterProperty;
  validate(defs.parameter, node, "parameter", parameter, 1);
  return node;
}
function tsDeclareFunction(id = null, typeParameters = null, params, returnType = null) {
  const node = {
    type: "TSDeclareFunction",
    id,
    typeParameters,
    params,
    returnType
  };
  const defs = NODE_FIELDS.TSDeclareFunction;
  validate(defs.id, node, "id", id, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.params, node, "params", params, 1);
  validate(defs.returnType, node, "returnType", returnType, 1);
  return node;
}
function tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {
  const node = {
    type: "TSDeclareMethod",
    decorators,
    key,
    typeParameters,
    params,
    returnType
  };
  const defs = NODE_FIELDS.TSDeclareMethod;
  validate(defs.decorators, node, "decorators", decorators, 1);
  validate(defs.key, node, "key", key, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.params, node, "params", params, 1);
  validate(defs.returnType, node, "returnType", returnType, 1);
  return node;
}
function tsQualifiedName(left, right) {
  const node = {
    type: "TSQualifiedName",
    left,
    right
  };
  const defs = NODE_FIELDS.TSQualifiedName;
  validate(defs.left, node, "left", left, 1);
  validate(defs.right, node, "right", right, 1);
  return node;
}
function tsCallSignatureDeclaration(typeParameters = null, parameters, typeAnnotation = null) {
  const node = {
    type: "TSCallSignatureDeclaration",
    typeParameters,
    parameters,
    typeAnnotation
  };
  const defs = NODE_FIELDS.TSCallSignatureDeclaration;
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.parameters, node, "parameters", parameters, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}
function tsConstructSignatureDeclaration(typeParameters = null, parameters, typeAnnotation = null) {
  const node = {
    type: "TSConstructSignatureDeclaration",
    typeParameters,
    parameters,
    typeAnnotation
  };
  const defs = NODE_FIELDS.TSConstructSignatureDeclaration;
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.parameters, node, "parameters", parameters, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}
function tsPropertySignature(key, typeAnnotation = null) {
  const node = {
    type: "TSPropertySignature",
    key,
    typeAnnotation,
    kind: null
  };
  const defs = NODE_FIELDS.TSPropertySignature;
  validate(defs.key, node, "key", key, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}
function tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation = null) {
  const node = {
    type: "TSMethodSignature",
    key,
    typeParameters,
    parameters,
    typeAnnotation,
    kind: null
  };
  const defs = NODE_FIELDS.TSMethodSignature;
  validate(defs.key, node, "key", key, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.parameters, node, "parameters", parameters, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}
function tsInde***REMOVED***Signature(parameters, typeAnnotation = null) {
  const node = {
    type: "TSInde***REMOVED***Signature",
    parameters,
    typeAnnotation
  };
  const defs = NODE_FIELDS.TSInde***REMOVED***Signature;
  validate(defs.parameters, node, "parameters", parameters, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}
function tsAnyKeyword() {
  return {
    type: "TSAnyKeyword"
  };
}
function tsBooleanKeyword() {
  return {
    type: "TSBooleanKeyword"
  };
}
function tsBigIntKeyword() {
  return {
    type: "TSBigIntKeyword"
  };
}
function tsIntrinsicKeyword() {
  return {
    type: "TSIntrinsicKeyword"
  };
}
function tsNeverKeyword() {
  return {
    type: "TSNeverKeyword"
  };
}
function tsNullKeyword() {
  return {
    type: "TSNullKeyword"
  };
}
function tsNumberKeyword() {
  return {
    type: "TSNumberKeyword"
  };
}
function tsObjectKeyword() {
  return {
    type: "TSObjectKeyword"
  };
}
function tsStringKeyword() {
  return {
    type: "TSStringKeyword"
  };
}
function tsSymbolKeyword() {
  return {
    type: "TSSymbolKeyword"
  };
}
function tsUndefinedKeyword() {
  return {
    type: "TSUndefinedKeyword"
  };
}
function tsUnknownKeyword() {
  return {
    type: "TSUnknownKeyword"
  };
}
function tsVoidKeyword() {
  return {
    type: "TSVoidKeyword"
  };
}
function tsThisType() {
  return {
    type: "TSThisType"
  };
}
function tsFunctionType(typeParameters = null, parameters, typeAnnotation = null) {
  const node = {
    type: "TSFunctionType",
    typeParameters,
    parameters,
    typeAnnotation
  };
  const defs = NODE_FIELDS.TSFunctionType;
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.parameters, node, "parameters", parameters, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}
function tsConstructorType(typeParameters = null, parameters, typeAnnotation = null) {
  const node = {
    type: "TSConstructorType",
    typeParameters,
    parameters,
    typeAnnotation
  };
  const defs = NODE_FIELDS.TSConstructorType;
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.parameters, node, "parameters", parameters, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}
function tsTypeReference(typeName, typeParameters = null) {
  const node = {
    type: "TSTypeReference",
    typeName,
    typeParameters
  };
  const defs = NODE_FIELDS.TSTypeReference;
  validate(defs.typeName, node, "typeName", typeName, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  return node;
}
function tsTypePredicate(parameterName, typeAnnotation = null, asserts = null) {
  const node = {
    type: "TSTypePredicate",
    parameterName,
    typeAnnotation,
    asserts
  };
  const defs = NODE_FIELDS.TSTypePredicate;
  validate(defs.parameterName, node, "parameterName", parameterName, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  validate(defs.asserts, node, "asserts", asserts);
  return node;
}
function tsTypeQuery(e***REMOVED***prName, typeParameters = null) {
  const node = {
    type: "TSTypeQuery",
    e***REMOVED***prName,
    typeParameters
  };
  const defs = NODE_FIELDS.TSTypeQuery;
  validate(defs.e***REMOVED***prName, node, "e***REMOVED***prName", e***REMOVED***prName, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  return node;
}
function tsTypeLiteral(members) {
  const node = {
    type: "TSTypeLiteral",
    members
  };
  const defs = NODE_FIELDS.TSTypeLiteral;
  validate(defs.members, node, "members", members, 1);
  return node;
}
function tsArrayType(elementType) {
  const node = {
    type: "TSArrayType",
    elementType
  };
  const defs = NODE_FIELDS.TSArrayType;
  validate(defs.elementType, node, "elementType", elementType, 1);
  return node;
}
function tsTupleType(elementTypes) {
  const node = {
    type: "TSTupleType",
    elementTypes
  };
  const defs = NODE_FIELDS.TSTupleType;
  validate(defs.elementTypes, node, "elementTypes", elementTypes, 1);
  return node;
}
function tsOptionalType(typeAnnotation) {
  const node = {
    type: "TSOptionalType",
    typeAnnotation
  };
  const defs = NODE_FIELDS.TSOptionalType;
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}
function tsRestType(typeAnnotation) {
  const node = {
    type: "TSRestType",
    typeAnnotation
  };
  const defs = NODE_FIELDS.TSRestType;
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}
function tsNamedTupleMember(label, elementType, optional = false) {
  const node = {
    type: "TSNamedTupleMember",
    label,
    elementType,
    optional
  };
  const defs = NODE_FIELDS.TSNamedTupleMember;
  validate(defs.label, node, "label", label, 1);
  validate(defs.elementType, node, "elementType", elementType, 1);
  validate(defs.optional, node, "optional", optional);
  return node;
}
function tsUnionType(types) {
  const node = {
    type: "TSUnionType",
    types
  };
  const defs = NODE_FIELDS.TSUnionType;
  validate(defs.types, node, "types", types, 1);
  return node;
}
function tsIntersectionType(types) {
  const node = {
    type: "TSIntersectionType",
    types
  };
  const defs = NODE_FIELDS.TSIntersectionType;
  validate(defs.types, node, "types", types, 1);
  return node;
}
function tsConditionalType(checkType, e***REMOVED***tendsType, trueType, falseType) {
  const node = {
    type: "TSConditionalType",
    checkType,
    e***REMOVED***tendsType,
    trueType,
    falseType
  };
  const defs = NODE_FIELDS.TSConditionalType;
  validate(defs.checkType, node, "checkType", checkType, 1);
  validate(defs.e***REMOVED***tendsType, node, "e***REMOVED***tendsType", e***REMOVED***tendsType, 1);
  validate(defs.trueType, node, "trueType", trueType, 1);
  validate(defs.falseType, node, "falseType", falseType, 1);
  return node;
}
function tsInferType(typeParameter) {
  const node = {
    type: "TSInferType",
    typeParameter
  };
  const defs = NODE_FIELDS.TSInferType;
  validate(defs.typeParameter, node, "typeParameter", typeParameter, 1);
  return node;
}
function tsParenthesizedType(typeAnnotation) {
  const node = {
    type: "TSParenthesizedType",
    typeAnnotation
  };
  const defs = NODE_FIELDS.TSParenthesizedType;
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}
function tsTypeOperator(typeAnnotation) {
  const node = {
    type: "TSTypeOperator",
    typeAnnotation,
    operator: null
  };
  const defs = NODE_FIELDS.TSTypeOperator;
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}
function tsInde***REMOVED***edAccessType(objectType, inde***REMOVED***Type) {
  const node = {
    type: "TSInde***REMOVED***edAccessType",
    objectType,
    inde***REMOVED***Type
  };
  const defs = NODE_FIELDS.TSInde***REMOVED***edAccessType;
  validate(defs.objectType, node, "objectType", objectType, 1);
  validate(defs.inde***REMOVED***Type, node, "inde***REMOVED***Type", inde***REMOVED***Type, 1);
  return node;
}
function tsMappedType(typeParameter, typeAnnotation = null, nameType = null) {
  const node = {
    type: "TSMappedType",
    typeParameter,
    typeAnnotation,
    nameType
  };
  const defs = NODE_FIELDS.TSMappedType;
  validate(defs.typeParameter, node, "typeParameter", typeParameter, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  validate(defs.nameType, node, "nameType", nameType, 1);
  return node;
}
function tsLiteralType(literal) {
  const node = {
    type: "TSLiteralType",
    literal
  };
  const defs = NODE_FIELDS.TSLiteralType;
  validate(defs.literal, node, "literal", literal, 1);
  return node;
}
function tsE***REMOVED***pressionWithTypeArguments(e***REMOVED***pression, typeParameters = null) {
  const node = {
    type: "TSE***REMOVED***pressionWithTypeArguments",
    e***REMOVED***pression,
    typeParameters
  };
  const defs = NODE_FIELDS.TSE***REMOVED***pressionWithTypeArguments;
  validate(defs.e***REMOVED***pression, node, "e***REMOVED***pression", e***REMOVED***pression, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  return node;
}
function tsInterfaceDeclaration(id, typeParameters = null, _e***REMOVED***tends = null, body) {
  const node = {
    type: "TSInterfaceDeclaration",
    id,
    typeParameters,
    e***REMOVED***tends: _e***REMOVED***tends,
    body
  };
  const defs = NODE_FIELDS.TSInterfaceDeclaration;
  validate(defs.id, node, "id", id, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.e***REMOVED***tends, node, "e***REMOVED***tends", _e***REMOVED***tends, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}
function tsInterfaceBody(body) {
  const node = {
    type: "TSInterfaceBody",
    body
  };
  const defs = NODE_FIELDS.TSInterfaceBody;
  validate(defs.body, node, "body", body, 1);
  return node;
}
function tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation) {
  const node = {
    type: "TSTypeAliasDeclaration",
    id,
    typeParameters,
    typeAnnotation
  };
  const defs = NODE_FIELDS.TSTypeAliasDeclaration;
  validate(defs.id, node, "id", id, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}
function tsInstantiationE***REMOVED***pression(e***REMOVED***pression, typeParameters = null) {
  const node = {
    type: "TSInstantiationE***REMOVED***pression",
    e***REMOVED***pression,
    typeParameters
  };
  const defs = NODE_FIELDS.TSInstantiationE***REMOVED***pression;
  validate(defs.e***REMOVED***pression, node, "e***REMOVED***pression", e***REMOVED***pression, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  return node;
}
function tsAsE***REMOVED***pression(e***REMOVED***pression, typeAnnotation) {
  const node = {
    type: "TSAsE***REMOVED***pression",
    e***REMOVED***pression,
    typeAnnotation
  };
  const defs = NODE_FIELDS.TSAsE***REMOVED***pression;
  validate(defs.e***REMOVED***pression, node, "e***REMOVED***pression", e***REMOVED***pression, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}
function tsSatisfiesE***REMOVED***pression(e***REMOVED***pression, typeAnnotation) {
  const node = {
    type: "TSSatisfiesE***REMOVED***pression",
    e***REMOVED***pression,
    typeAnnotation
  };
  const defs = NODE_FIELDS.TSSatisfiesE***REMOVED***pression;
  validate(defs.e***REMOVED***pression, node, "e***REMOVED***pression", e***REMOVED***pression, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}
function tsTypeAssertion(typeAnnotation, e***REMOVED***pression) {
  const node = {
    type: "TSTypeAssertion",
    typeAnnotation,
    e***REMOVED***pression
  };
  const defs = NODE_FIELDS.TSTypeAssertion;
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  validate(defs.e***REMOVED***pression, node, "e***REMOVED***pression", e***REMOVED***pression, 1);
  return node;
}
function tsEnumDeclaration(id, members) {
  const node = {
    type: "TSEnumDeclaration",
    id,
    members
  };
  const defs = NODE_FIELDS.TSEnumDeclaration;
  validate(defs.id, node, "id", id, 1);
  validate(defs.members, node, "members", members, 1);
  return node;
}
function tsEnumMember(id, initializer = null) {
  const node = {
    type: "TSEnumMember",
    id,
    initializer
  };
  const defs = NODE_FIELDS.TSEnumMember;
  validate(defs.id, node, "id", id, 1);
  validate(defs.initializer, node, "initializer", initializer, 1);
  return node;
}
function tsModuleDeclaration(id, body) {
  const node = {
    type: "TSModuleDeclaration",
    id,
    body,
    kind: null
  };
  const defs = NODE_FIELDS.TSModuleDeclaration;
  validate(defs.id, node, "id", id, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}
function tsModuleBlock(body) {
  const node = {
    type: "TSModuleBlock",
    body
  };
  const defs = NODE_FIELDS.TSModuleBlock;
  validate(defs.body, node, "body", body, 1);
  return node;
}
function tsImportType(argument, qualifier = null, typeParameters = null) {
  const node = {
    type: "TSImportType",
    argument,
    qualifier,
    typeParameters
  };
  const defs = NODE_FIELDS.TSImportType;
  validate(defs.argument, node, "argument", argument, 1);
  validate(defs.qualifier, node, "qualifier", qualifier, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  return node;
}
function tsImportEqualsDeclaration(id, moduleReference) {
  const node = {
    type: "TSImportEqualsDeclaration",
    id,
    moduleReference,
    isE***REMOVED***port: null
  };
  const defs = NODE_FIELDS.TSImportEqualsDeclaration;
  validate(defs.id, node, "id", id, 1);
  validate(defs.moduleReference, node, "moduleReference", moduleReference, 1);
  return node;
}
function tsE***REMOVED***ternalModuleReference(e***REMOVED***pression) {
  const node = {
    type: "TSE***REMOVED***ternalModuleReference",
    e***REMOVED***pression
  };
  const defs = NODE_FIELDS.TSE***REMOVED***ternalModuleReference;
  validate(defs.e***REMOVED***pression, node, "e***REMOVED***pression", e***REMOVED***pression, 1);
  return node;
}
function tsNonNullE***REMOVED***pression(e***REMOVED***pression) {
  const node = {
    type: "TSNonNullE***REMOVED***pression",
    e***REMOVED***pression
  };
  const defs = NODE_FIELDS.TSNonNullE***REMOVED***pression;
  validate(defs.e***REMOVED***pression, node, "e***REMOVED***pression", e***REMOVED***pression, 1);
  return node;
}
function tsE***REMOVED***portAssignment(e***REMOVED***pression) {
  const node = {
    type: "TSE***REMOVED***portAssignment",
    e***REMOVED***pression
  };
  const defs = NODE_FIELDS.TSE***REMOVED***portAssignment;
  validate(defs.e***REMOVED***pression, node, "e***REMOVED***pression", e***REMOVED***pression, 1);
  return node;
}
function tsNamespaceE***REMOVED***portDeclaration(id) {
  const node = {
    type: "TSNamespaceE***REMOVED***portDeclaration",
    id
  };
  const defs = NODE_FIELDS.TSNamespaceE***REMOVED***portDeclaration;
  validate(defs.id, node, "id", id, 1);
  return node;
}
function tsTypeAnnotation(typeAnnotation) {
  const node = {
    type: "TSTypeAnnotation",
    typeAnnotation
  };
  const defs = NODE_FIELDS.TSTypeAnnotation;
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}
function tsTypeParameterInstantiation(params) {
  const node = {
    type: "TSTypeParameterInstantiation",
    params
  };
  const defs = NODE_FIELDS.TSTypeParameterInstantiation;
  validate(defs.params, node, "params", params, 1);
  return node;
}
function tsTypeParameterDeclaration(params) {
  const node = {
    type: "TSTypeParameterDeclaration",
    params
  };
  const defs = NODE_FIELDS.TSTypeParameterDeclaration;
  validate(defs.params, node, "params", params, 1);
  return node;
}
function tsTypeParameter(constraint = null, _default = null, name) {
  const node = {
    type: "TSTypeParameter",
    constraint,
    default: _default,
    name
  };
  const defs = NODE_FIELDS.TSTypeParameter;
  validate(defs.constraint, node, "constraint", constraint, 1);
  validate(defs.default, node, "default", _default, 1);
  validate(defs.name, node, "name", name);
  return node;
}
function NumberLiteral(value) {
  (0, _deprecationWarning.default)("NumberLiteral", "NumericLiteral", "The node type ");
  return numericLiteral(value);
}
function Rege***REMOVED***Literal(pattern, flags = "") {
  (0, _deprecationWarning.default)("Rege***REMOVED***Literal", "RegE***REMOVED***pLiteral", "The node type ");
  return regE***REMOVED***pLiteral(pattern, flags);
}
function RestProperty(argument) {
  (0, _deprecationWarning.default)("RestProperty", "RestElement", "The node type ");
  return restElement(argument);
}
function SpreadProperty(argument) {
  (0, _deprecationWarning.default)("SpreadProperty", "SpreadElement", "The node type ");
  return spreadElement(argument);
}

//# sourceMappingURL=inde***REMOVED***.js.map
