import isFunction from '../utils/is-function';
import e***REMOVED***tend from '../utils/e***REMOVED***tend';
import isObject from '../utils/is-object';
import hasOwnProp from '../utils/has-own-prop';

e***REMOVED***port function set(config) {
    var prop, i;
    for (i in config) {
        if (hasOwnProp(config, i)) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in ne***REMOVED***t major release.
    this._dayOfMonthOrdinalParseLenient = new RegE***REMOVED***p(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
            '|' +
            /\d{1,2}/.source
    );
}

e***REMOVED***port function mergeConfigs(parentConfig, childConfig) {
    var res = e***REMOVED***tend({}, parentConfig),
        prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                e***REMOVED***tend(res[prop], parentConfig[prop]);
                e***REMOVED***tend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (
            hasOwnProp(parentConfig, prop) &&
            !hasOwnProp(childConfig, prop) &&
            isObject(parentConfig[prop])
        ) {
            // make sure changes to properties don't modify parent config
            res[prop] = e***REMOVED***tend({}, res[prop]);
        }
    }
    return res;
}
