var debug = require('debug')('nodemon');
var fs = require('fs');
var path = require('path');
var e***REMOVED***ists = fs.e***REMOVED***ists || path.e***REMOVED***ists;
var utils = require('../utils');
var rules = require('../rules');
var parse = require('../rules/parse');
var e***REMOVED***ec = require('./e***REMOVED***ec');
var defaults = require('./defaults');

module.e***REMOVED***ports = load;
module.e***REMOVED***ports.mutateE***REMOVED***ecOptions = mutateE***REMOVED***ecOptions;

var e***REMOVED***istsSync = fs.e***REMOVED***istsSync || path.e***REMOVED***istsSync;

function findAppScript() {
  // nodemon has been run alone, so try to read the package file
  // or try to read the inde***REMOVED***.js file

  var pkg =
    e***REMOVED***istsSync(path.join(process.cwd(), 'package.json')) &&
    require(path.join(process.cwd(), 'package.json'));
  if ((!pkg || pkg.main == undefined) && e***REMOVED***istsSync('./inde***REMOVED***.js')) {
    return 'inde***REMOVED***.js';
  }
}

/**
 * Load the nodemon config, first reading the global root/nodemon.json, then
 * the local nodemon.json to the e***REMOVED***ec and then overwriting using any user
 * specified settings (i.e. from the cli)
 *
 * @param  {Object} settings user defined settings
 * @param  {Function} ready    callback that receives complete config
 */
function load(settings, options, config, callback) {
  config.loaded = [];
  // first load the root nodemon.json
  loadFile(options, config, utils.home, function (options) {
    // then load the user's local configuration file
    if (settings.configFile) {
      options.configFile = path.resolve(settings.configFile);
    }
    loadFile(options, config, process.cwd(), function (options) {
      // Then merge over with the user settings (parsed from the cli).
      // Note that merge protects and favours e***REMOVED***isting values over new values,
      // and thus command line arguments get priority
      options = utils.merge(settings, options);

      // legacy support
      if (!Array.isArray(options.ignore)) {
        options.ignore = [options.ignore];
      }

      if (!options.ignoreRoot) {
        options.ignoreRoot = defaults.ignoreRoot;
      }

      // blend the user ignore and the default ignore together
      if (options.ignoreRoot && options.ignore) {
        if (!Array.isArray(options.ignoreRoot)) {
          options.ignoreRoot = [options.ignoreRoot];
        }
        options.ignore = options.ignoreRoot.concat(options.ignore);
      } else {
        options.ignore = defaults.ignore.concat(options.ignore);
      }

      // add in any missing defaults
      options = utils.merge(options, defaults);

      if (!options.script && !options.e***REMOVED***ec) {
        var found = findAppScript();
        if (found) {
          if (!options.args) {
            options.args = [];
          }
          // if the script is found as a result of not being on the command
          // line, then we move any of the pre double-dash args in e***REMOVED***ecArgs
          const n =
            options.scriptPosition === null
              ? options.args.length
              : options.scriptPosition;

          options.e***REMOVED***ecArgs = (options.e***REMOVED***ecArgs || []).concat(
            options.args.splice(0, n)
          );
          options.scriptPosition = null;

          options.script = found;
        }
      }

      mutateE***REMOVED***ecOptions(options);

      if (options.quiet) {
        utils.quiet();
      }

      if (options.verbose) {
        utils.debug = true;
      }

      // simplify the ready callback to be called after the rules are normalised
      // from strings to rege***REMOVED***p through the rules lib. Note that this gets
      // created *after* options is overwritten twice in the lines above.
      var ready = function (options) {
        normaliseRules(options, callback);
      };

      ready(options);
    });
  });
}

function normaliseRules(options, ready) {
  // convert ignore and watch options to rules/rege***REMOVED***p
  rules.watch.add(options.watch);
  rules.ignore.add(options.ignore);

  // normalise the watch and ignore arrays
  options.watch = options.watch === false ? false : rules.rules.watch;
  options.ignore = rules.rules.ignore;

  ready(options);
}

/**
 * Looks for a config in the current working directory, and a config in the
 * user's home directory, merging the two together, giving priority to local
 * config. This can then be overwritten later by command line arguments
 *
 * @param  {Function} ready callback to pass loaded settings to
 */
function loadFile(options, config, dir, ready) {
  if (!ready) {
    ready = function () {};
  }

  var callback = function (settings) {
    // prefer the local nodemon.json and fill in missing items using
    // the global options
    ready(utils.merge(settings, options));
  };

  if (!dir) {
    return callback({});
  }

  var filename = options.configFile || path.join(dir, 'nodemon.json');

  if (config.loaded.inde***REMOVED***Of(filename) !== -1) {
    // don't bother re-parsing the same config file
    return callback({});
  }

  fs.readFile(filename, 'utf8', function (err, data) {
    if (err) {
      if (err.code === 'ENOENT') {
        if (!options.configFile && dir !== utils.home) {
          // if no specified local config file and local nodemon.json
          // doesn't e***REMOVED***ist, try the package.json
          return loadPackageJSON(config, callback);
        }
      }
      return callback({});
    }

    var settings = {};

    try {
      settings = JSON.parse(data.toString('utf8').replace(/^\uFEFF/, ''));
      if (!filename.endsWith('package.json') || settings.nodemonConfig) {
        config.loaded.push(filename);
      }
    } catch (e) {
      utils.log.fail('Failed to parse config ' + filename);
      console.error(e);
      process.e***REMOVED***it(1);
    }

    // options values will overwrite settings
    callback(settings);
  });
}

function loadPackageJSON(config, ready) {
  if (!ready) {
    ready = () => {};
  }

  const dir = process.cwd();
  const filename = path.join(dir, 'package.json');
  const packageLoadOptions = { configFile: filename };
  return loadFile(packageLoadOptions, config, dir, (settings) => {
    ready(settings.nodemonConfig || {});
  });
}

function mutateE***REMOVED***ecOptions(options) {
  // work out the e***REMOVED***ecOptions based on the final config we have
  options.e***REMOVED***ecOptions = e***REMOVED***ec(
    {
      script: options.script,
      e***REMOVED***ec: options.e***REMOVED***ec,
      args: options.args,
      scriptPosition: options.scriptPosition,
      nodeArgs: options.nodeArgs,
      e***REMOVED***ecArgs: options.e***REMOVED***ecArgs,
      e***REMOVED***t: options.e***REMOVED***t,
      env: options.env,
    },
    options.e***REMOVED***ecMap
  );

  // clean up values that we don't need at the top level
  delete options.scriptPosition;
  delete options.script;
  delete options.args;
  delete options.e***REMOVED***t;

  return options;
}
