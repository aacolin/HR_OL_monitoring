const path = require('path');
const fs = require('fs');
const e***REMOVED***istsSync = fs.e***REMOVED***istsSync;
const utils = require('../utils');

module.e***REMOVED***ports = e***REMOVED***ec;
module.e***REMOVED***ports.e***REMOVED***pandScript = e***REMOVED***pandScript;

/**
 * Reads the cwd/package.json file and looks to see if it can load a script
 * and possibly an e***REMOVED***ec first from package.main, then package.start.
 *
 * @return {Object} e***REMOVED***ec & script if found
 */
function e***REMOVED***ecFromPackage() {
  // doing a try/catch because we can't use the path.e***REMOVED***ist callback pattern
  // or we could, but the code would get messy, so this will do e***REMOVED***actly
  // what we're after - if the file doesn't e***REMOVED***ist, it'll throw.
  try {
    // note: this isn't nodemon's package, it's the user's cwd package
    var pkg = require(path.join(process.cwd(), 'package.json'));
    if (pkg.main !== undefined) {
      // no app found to run - so give them a tip and get the feck out
      return { e***REMOVED***ec: null, script: pkg.main };
    }

    if (pkg.scripts && pkg.scripts.start) {
      return { e***REMOVED***ec: pkg.scripts.start };
    }
  } catch (e) {}

  return null;
}

function replace(map, str) {
  var re = new RegE***REMOVED***p('{{(' + Object.keys(map).join('|') + ')}}', 'g');
  return str.replace(re, function (all, m) {
    return map[m] || all || '';
  });
}

function e***REMOVED***pandScript(script, e***REMOVED***t) {
  if (!e***REMOVED***t) {
    e***REMOVED***t = '.js';
  }
  if (script.inde***REMOVED***Of(e***REMOVED***t) !== -1) {
    return script;
  }

  if (e***REMOVED***istsSync(path.resolve(script))) {
    return script;
  }

  if (e***REMOVED***istsSync(path.resolve(script + e***REMOVED***t))) {
    return script + e***REMOVED***t;
  }

  return script;
}

/**
 * Discovers all the options required to run the script
 * and if a custom e***REMOVED***ec has been passed in, then it will
 * also try to work out what e***REMOVED***tensions to monitor and
 * whether there's a special way of running that script.
 *
 * @param  {Object} nodemonOptions
 * @param  {Object} e***REMOVED***ecMap
 * @return {Object} new and updated version of nodemonOptions
 */
function e***REMOVED***ec(nodemonOptions, e***REMOVED***ecMap) {
  if (!e***REMOVED***ecMap) {
    e***REMOVED***ecMap = {};
  }

  var options = utils.clone(nodemonOptions || {});
  var script;

  // if there's no script passed, try to get it from the first argument
  if (!options.script && (options.args || []).length) {
    script = e***REMOVED***pandScript(
      options.args[0],
      options.e***REMOVED***t && '.' + (options.e***REMOVED***t || 'js').split(',')[0]
    );

    // if the script was found, shift it off our args
    if (script !== options.args[0]) {
      options.script = script;
      options.args.shift();
    }
  }

  // if there's no e***REMOVED***ec found yet, then try to read it from the local
  // package.json this logic used to sit in the cli/parse, but actually the cli
  // should be parsed first, then the user options (via nodemon.json) then
  // finally default down to pot shots at the directory via package.json
  if (!options.e***REMOVED***ec && !options.script) {
    var found = e***REMOVED***ecFromPackage();
    if (found !== null) {
      if (found.e***REMOVED***ec) {
        options.e***REMOVED***ec = found.e***REMOVED***ec;
      }
      if (!options.script) {
        options.script = found.script;
      }
      if (Array.isArray(options.args) && options.scriptPosition === null) {
        options.scriptPosition = options.args.length;
      }
    }
  }

  // var options = utils.clone(nodemonOptions || {});
  script = path.basename(options.script || '');

  var scriptE***REMOVED***t = path.e***REMOVED***tname(script).slice(1);

  var e***REMOVED***tension = options.e***REMOVED***t;
  if (e***REMOVED***tension === undefined) {
    var isJS = scriptE***REMOVED***t === 'js' || scriptE***REMOVED***t === 'mjs' || scriptE***REMOVED***t === 'cjs';
    e***REMOVED***tension = isJS || !scriptE***REMOVED***t ? 'js,mjs,cjs' : scriptE***REMOVED***t;
    e***REMOVED***tension += ',json'; // Always watch JSON files
  }

  var e***REMOVED***ecDefined = !!options.e***REMOVED***ec;

  // allows the user to simplify cli usage:
  // https://github.com/remy/nodemon/issues/195
  // but always give preference to the user defined argument
  if (!options.e***REMOVED***ec && e***REMOVED***ecMap[scriptE***REMOVED***t] !== undefined) {
    options.e***REMOVED***ec = e***REMOVED***ecMap[scriptE***REMOVED***t];
    e***REMOVED***ecDefined = true;
  }

  options.e***REMOVED***ecArgs = nodemonOptions.e***REMOVED***ecArgs || [];

  if (Array.isArray(options.e***REMOVED***ec)) {
    options.e***REMOVED***ecArgs = options.e***REMOVED***ec;
    options.e***REMOVED***ec = options.e***REMOVED***ecArgs.shift();
  }

  if (options.e***REMOVED***ec === undefined) {
    options.e***REMOVED***ec = 'node';
  } else {
    // allow variable substitution for {{filename}} and {{pwd}}
    var substitution = replace.bind(null, {
      filename: options.script,
      pwd: process.cwd(),
    });

    var newE***REMOVED***ec = substitution(options.e***REMOVED***ec);
    if (
      newE***REMOVED***ec !== options.e***REMOVED***ec &&
      options.e***REMOVED***ec.inde***REMOVED***Of('{{filename}}') !== -1
    ) {
      options.script = null;
    }
    options.e***REMOVED***ec = newE***REMOVED***ec;

    var newE***REMOVED***ecArgs = options.e***REMOVED***ecArgs.map(substitution);
    if (newE***REMOVED***ecArgs.join('') !== options.e***REMOVED***ecArgs.join('')) {
      options.e***REMOVED***ecArgs = newE***REMOVED***ecArgs;
      delete options.script;
    }
  }

  if (options.e***REMOVED***ec === 'node' && options.nodeArgs && options.nodeArgs.length) {
    options.e***REMOVED***ecArgs = options.e***REMOVED***ecArgs.concat(options.nodeArgs);
  }

  // note: inde***REMOVED***Of('coffee') handles both .coffee and .litcoffee
  if (
    !e***REMOVED***ecDefined &&
    options.e***REMOVED***ec === 'node' &&
    scriptE***REMOVED***t.inde***REMOVED***Of('coffee') !== -1
  ) {
    options.e***REMOVED***ec = 'coffee';

    // we need to get e***REMOVED***ecArgs set before the script
    // for e***REMOVED***ample, in `nodemon --debug my-script.coffee --my-flag`, debug is an
    // e***REMOVED***ecArg, while my-flag is a script arg
    var leadingArgs = (options.args || []).splice(0, options.scriptPosition);
    options.e***REMOVED***ecArgs = options.e***REMOVED***ecArgs.concat(leadingArgs);
    options.scriptPosition = 0;

    if (options.e***REMOVED***ecArgs.length > 0) {
      // because this is the coffee e***REMOVED***ecutable, we need to combine the e***REMOVED***ec args
      // into a single argument after the nodejs flag
      options.e***REMOVED***ecArgs = ['--nodejs', options.e***REMOVED***ecArgs.join(' ')];
    }
  }

  if (options.e***REMOVED***ec === 'coffee') {
    // don't override user specified e***REMOVED***tension tracking
    if (options.e***REMOVED***t === undefined) {
      if (e***REMOVED***tension) {
        e***REMOVED***tension += ',';
      }
      e***REMOVED***tension += 'coffee,litcoffee';
    }

    // because windows can't find 'coffee', it needs the real file 'coffee.cmd'
    if (utils.isWindows) {
      options.e***REMOVED***ec += '.cmd';
    }
  }

  // allow users to make a mistake on the e***REMOVED***tension to monitor
  // converts .js, pug => js,pug
  // BIG NOTE: user can't do this: nodemon -e *.js
  // because the terminal will automatically e***REMOVED***pand the glob against
  // the file system :(
  e***REMOVED***tension = (e***REMOVED***tension.match(/[^,*\s]+/g) || [])
    .map((e***REMOVED***t) => e***REMOVED***t.replace(/^\./, ''))
    .join(',');

  options.e***REMOVED***t = e***REMOVED***tension;

  if (options.script) {
    options.script = e***REMOVED***pandScript(
      options.script,
      e***REMOVED***tension && '.' + e***REMOVED***tension.split(',')[0]
    );
  }

  options.env = {};
  // make sure it's an object (and since we don't have )
  if ({}.toString.apply(nodemonOptions.env) === '[object Object]') {
    options.env = utils.clone(nodemonOptions.env);
  } else if (nodemonOptions.env !== undefined) {
    throw new Error('nodemon env values must be an object: { PORT: 8000 }');
  }

  return options;
}
