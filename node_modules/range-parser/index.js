/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict'

/**
 * Module e***REMOVED***ports.
 * @public
 */

module.e***REMOVED***ports = rangeParser

/**
 * Parse "Range" header `str` relative to the given file `size`.
 *
 * @param {Number} size
 * @param {String} str
 * @param {Object} [options]
 * @return {Array}
 * @public
 */

function rangeParser (size, str, options) {
  if (typeof str !== 'string') {
    throw new TypeError('argument str must be a string')
  }

  var inde***REMOVED*** = str.inde***REMOVED***Of('=')

  if (inde***REMOVED*** === -1) {
    return -2
  }

  // split the range string
  var arr = str.slice(inde***REMOVED*** + 1).split(',')
  var ranges = []

  // add ranges type
  ranges.type = str.slice(0, inde***REMOVED***)

  // parse all ranges
  for (var i = 0; i < arr.length; i++) {
    var range = arr[i].split('-')
    var start = parseInt(range[0], 10)
    var end = parseInt(range[1], 10)

    // -nnn
    if (isNaN(start)) {
      start = size - end
      end = size - 1
    // nnn-
    } else if (isNaN(end)) {
      end = size - 1
    }

    // limit last-byte-pos to current length
    if (end > size - 1) {
      end = size - 1
    }

    // invalid or unsatisifiable
    if (isNaN(start) || isNaN(end) || start > end || start < 0) {
      continue
    }

    // add range
    ranges.push({
      start: start,
      end: end
    })
  }

  if (ranges.length < 1) {
    // unsatisifiable
    return -1
  }

  return options && options.combine
    ? combineRanges(ranges)
    : ranges
}

/**
 * Combine overlapping & adjacent ranges.
 * @private
 */

function combineRanges (ranges) {
  var ordered = ranges.map(mapWithInde***REMOVED***).sort(sortByRangeStart)

  for (var j = 0, i = 1; i < ordered.length; i++) {
    var range = ordered[i]
    var current = ordered[j]

    if (range.start > current.end + 1) {
      // ne***REMOVED***t range
      ordered[++j] = range
    } else if (range.end > current.end) {
      // e***REMOVED***tend range
      current.end = range.end
      current.inde***REMOVED*** = Math.min(current.inde***REMOVED***, range.inde***REMOVED***)
    }
  }

  // trim ordered array
  ordered.length = j + 1

  // generate combined range
  var combined = ordered.sort(sortByRangeInde***REMOVED***).map(mapWithoutInde***REMOVED***)

  // copy ranges type
  combined.type = ranges.type

  return combined
}

/**
 * Map function to add inde***REMOVED*** value to ranges.
 * @private
 */

function mapWithInde***REMOVED*** (range, inde***REMOVED***) {
  return {
    start: range.start,
    end: range.end,
    inde***REMOVED***: inde***REMOVED***
  }
}

/**
 * Map function to remove inde***REMOVED*** value from ranges.
 * @private
 */

function mapWithoutInde***REMOVED*** (range) {
  return {
    start: range.start,
    end: range.end
  }
}

/**
 * Sort function to sort ranges by inde***REMOVED***.
 * @private
 */

function sortByRangeInde***REMOVED*** (a, b) {
  return a.inde***REMOVED*** - b.inde***REMOVED***
}

/**
 * Sort function to sort ranges by start position.
 * @private
 */

function sortByRangeStart (a, b) {
  return a.start - b.start
}
