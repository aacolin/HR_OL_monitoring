'use strict';

/**
 * @param typeMap [Object] Map of MIME type -> Array[e***REMOVED***tensions]
 * @param ...
 */
function Mime() {
  this._types = Object.create(null);
  this._e***REMOVED***tensions = Object.create(null);

  for (let i = 0; i < arguments.length; i++) {
    this.define(arguments[i]);
  }

  this.define = this.define.bind(this);
  this.getType = this.getType.bind(this);
  this.getE***REMOVED***tension = this.getE***REMOVED***tension.bind(this);
}

/**
 * Define mimetype -> e***REMOVED***tension mappings.  Each key is a mime-type that maps
 * to an array of e***REMOVED***tensions associated with the type.  The first e***REMOVED***tension is
 * used as the default e***REMOVED***tension for the type.
 *
 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'sp***REMOVED***']});
 *
 * If a type declares an e***REMOVED***tension that has already been defined, an error will
 * be thrown.  To suppress this error and force the e***REMOVED***tension to be associated
 * with the new type, pass `force`=true.  Alternatively, you may prefi***REMOVED*** the
 * e***REMOVED***tension with "*" to map the type to e***REMOVED***tension, without mapping the
 * e***REMOVED***tension to the type.
 *
 * e.g. mime.define({'audio/wav', ['wav']}, {'audio/***REMOVED***-wav', ['*wav']});
 *
 *
 * @param map (Object) type definitions
 * @param force (Boolean) if true, force overriding of e***REMOVED***isting definitions
 */
Mime.prototype.define = function(typeMap, force) {
  for (let type in typeMap) {
    let e***REMOVED***tensions = typeMap[type].map(function(t) {
      return t.toLowerCase();
    });
    type = type.toLowerCase();

    for (let i = 0; i < e***REMOVED***tensions.length; i++) {
      const e***REMOVED***t = e***REMOVED***tensions[i];

      // '*' prefi***REMOVED*** = not the preferred type for this e***REMOVED***tension.  So fi***REMOVED***up the
      // e***REMOVED***tension, and skip it.
      if (e***REMOVED***t[0] === '*') {
        continue;
      }

      if (!force && (e***REMOVED***t in this._types)) {
        throw new Error(
          'Attempt to change mapping for "' + e***REMOVED***t +
          '" e***REMOVED***tension from "' + this._types[e***REMOVED***t] + '" to "' + type +
          '". Pass `force=true` to allow this, otherwise remove "' + e***REMOVED***t +
          '" from the list of e***REMOVED***tensions for "' + type + '".'
        );
      }

      this._types[e***REMOVED***t] = type;
    }

    // Use first e***REMOVED***tension as default
    if (force || !this._e***REMOVED***tensions[type]) {
      const e***REMOVED***t = e***REMOVED***tensions[0];
      this._e***REMOVED***tensions[type] = (e***REMOVED***t[0] !== '*') ? e***REMOVED***t : e***REMOVED***t.substr(1);
    }
  }
};

/**
 * Lookup a mime type based on e***REMOVED***tension
 */
Mime.prototype.getType = function(path) {
  path = String(path);
  let last = path.replace(/^.*[/\\]/, '').toLowerCase();
  let e***REMOVED***t = last.replace(/^.*\./, '').toLowerCase();

  let hasPath = last.length < path.length;
  let hasDot = e***REMOVED***t.length < last.length - 1;

  return (hasDot || !hasPath) && this._types[e***REMOVED***t] || null;
};

/**
 * Return file e***REMOVED***tension associated with a mime type
 */
Mime.prototype.getE***REMOVED***tension = function(type) {
  type = /^\s*([^;\s]*)/.test(type) && RegE***REMOVED***p.$1;
  return type && this._e***REMOVED***tensions[type.toLowerCase()] || null;
};

module.e***REMOVED***ports = Mime;
