/*!
 * media-typer
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * RegE***REMOVED***p to match *( ";" parameter ) in RFC 2616 sec 3.7
 *
 * parameter     = token "=" ( token | quoted-string )
 * token         = 1*<any CHAR e***REMOVED***cept CTLs or separators>
 * separators    = "(" | ")" | "<" | ">" | "@"
 *               | "," | ";" | ":" | "\" | <">
 *               | "/" | "[" | "]" | "?" | "="
 *               | "{" | "}" | SP | HT
 * quoted-string = ( <"> *(qdte***REMOVED***t | quoted-pair ) <"> )
 * qdte***REMOVED***t        = <any TEXT e***REMOVED***cept <">>
 * quoted-pair   = "\" CHAR
 * CHAR          = <any US-ASCII character (octets 0 - 127)>
 * TEXT          = <any OCTET e***REMOVED***cept CTLs, but including LWS>
 * LWS           = [CRLF] 1*( SP | HT )
 * CRLF          = CR LF
 * CR            = <US-ASCII CR, carriage return (13)>
 * LF            = <US-ASCII LF, linefeed (10)>
 * SP            = <US-ASCII SP, space (32)>
 * SHT           = <US-ASCII HT, horizontal-tab (9)>
 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
 * OCTET         = <any 8-bit sequence of data>
 */
var paramRegE***REMOVED***p = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
var te***REMOVED***tRegE***REMOVED***p = /^[\u0020-\u007e\u0080-\u00ff]+$/
var tokenRegE***REMOVED***p = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/

/**
 * RegE***REMOVED***p to match quoted-pair in RFC 2616
 *
 * quoted-pair = "\" CHAR
 * CHAR        = <any US-ASCII character (octets 0 - 127)>
 */
var qescRegE***REMOVED***p = /\\([\u0000-\u007f])/g;

/**
 * RegE***REMOVED***p to match chars that must be quoted-pair in RFC 2616
 */
var quoteRegE***REMOVED***p = /([\\"])/g;

/**
 * RegE***REMOVED***p to match type in RFC 6838
 *
 * type-name = restricted-name
 * subtype-name = restricted-name
 * restricted-name = restricted-name-first *126restricted-name-chars
 * restricted-name-first  = ALPHA / DIGIT
 * restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
 *                          "$" / "&" / "-" / "^" / "_"
 * restricted-name-chars =/ "." ; Characters before first dot always
 *                              ; specify a facet name
 * restricted-name-chars =/ "+" ; Characters after last plus always
 *                              ; specify a structured synta***REMOVED*** suffi***REMOVED***
 * ALPHA =  %***REMOVED***41-5A / %***REMOVED***61-7A   ; A-Z / a-z
 * DIGIT =  %***REMOVED***30-39             ; 0-9
 */
var subtypeNameRegE***REMOVED***p = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/
var typeNameRegE***REMOVED***p = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/
var typeRegE***REMOVED***p = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;

/**
 * Module e***REMOVED***ports.
 */

e***REMOVED***ports.format = format
e***REMOVED***ports.parse = parse

/**
 * Format object to media type.
 *
 * @param {object} obj
 * @return {string}
 * @api public
 */

function format(obj) {
  if (!obj || typeof obj !== 'object') {
    throw new TypeError('argument obj is required')
  }

  var parameters = obj.parameters
  var subtype = obj.subtype
  var suffi***REMOVED*** = obj.suffi***REMOVED***
  var type = obj.type

  if (!type || !typeNameRegE***REMOVED***p.test(type)) {
    throw new TypeError('invalid type')
  }

  if (!subtype || !subtypeNameRegE***REMOVED***p.test(subtype)) {
    throw new TypeError('invalid subtype')
  }

  // format as type/subtype
  var string = type + '/' + subtype

  // append +suffi***REMOVED***
  if (suffi***REMOVED***) {
    if (!typeNameRegE***REMOVED***p.test(suffi***REMOVED***)) {
      throw new TypeError('invalid suffi***REMOVED***')
    }

    string += '+' + suffi***REMOVED***
  }

  // append parameters
  if (parameters && typeof parameters === 'object') {
    var param
    var params = Object.keys(parameters).sort()

    for (var i = 0; i < params.length; i++) {
      param = params[i]

      if (!tokenRegE***REMOVED***p.test(param)) {
        throw new TypeError('invalid parameter name')
      }

      string += '; ' + param + '=' + qstring(parameters[param])
    }
  }

  return string
}

/**
 * Parse media type to object.
 *
 * @param {string|object} string
 * @return {Object}
 * @api public
 */

function parse(string) {
  if (!string) {
    throw new TypeError('argument string is required')
  }

  // support req/res-like objects as argument
  if (typeof string === 'object') {
    string = getcontenttype(string)
  }

  if (typeof string !== 'string') {
    throw new TypeError('argument string is required to be a string')
  }

  var inde***REMOVED*** = string.inde***REMOVED***Of(';')
  var type = inde***REMOVED*** !== -1
    ? string.substr(0, inde***REMOVED***)
    : string

  var key
  var match
  var obj = splitType(type)
  var params = {}
  var value

  paramRegE***REMOVED***p.lastInde***REMOVED*** = inde***REMOVED***

  while (match = paramRegE***REMOVED***p.e***REMOVED***ec(string)) {
    if (match.inde***REMOVED*** !== inde***REMOVED***) {
      throw new TypeError('invalid parameter format')
    }

    inde***REMOVED*** += match[0].length
    key = match[1].toLowerCase()
    value = match[2]

    if (value[0] === '"') {
      // remove quotes and escapes
      value = value
        .substr(1, value.length - 2)
        .replace(qescRegE***REMOVED***p, '$1')
    }

    params[key] = value
  }

  if (inde***REMOVED*** !== -1 && inde***REMOVED*** !== string.length) {
    throw new TypeError('invalid parameter format')
  }

  obj.parameters = params

  return obj
}

/**
 * Get content-type from req/res objects.
 *
 * @param {object}
 * @return {Object}
 * @api private
 */

function getcontenttype(obj) {
  if (typeof obj.getHeader === 'function') {
    // res-like
    return obj.getHeader('content-type')
  }

  if (typeof obj.headers === 'object') {
    // req-like
    return obj.headers && obj.headers['content-type']
  }
}

/**
 * Quote a string if necessary.
 *
 * @param {string} val
 * @return {string}
 * @api private
 */

function qstring(val) {
  var str = String(val)

  // no need to quote tokens
  if (tokenRegE***REMOVED***p.test(str)) {
    return str
  }

  if (str.length > 0 && !te***REMOVED***tRegE***REMOVED***p.test(str)) {
    throw new TypeError('invalid parameter value')
  }

  return '"' + str.replace(quoteRegE***REMOVED***p, '\\$1') + '"'
}

/**
 * Simply "type/subtype+siff***REMOVED***" into parts.
 *
 * @param {string} string
 * @return {Object}
 * @api private
 */

function splitType(string) {
  var match = typeRegE***REMOVED***p.e***REMOVED***ec(string.toLowerCase())

  if (!match) {
    throw new TypeError('invalid media type')
  }

  var type = match[1]
  var subtype = match[2]
  var suffi***REMOVED***

  // suffi***REMOVED*** after last +
  var inde***REMOVED*** = subtype.lastInde***REMOVED***Of('+')
  if (inde***REMOVED*** !== -1) {
    suffi***REMOVED*** = subtype.substr(inde***REMOVED*** + 1)
    subtype = subtype.substr(0, inde***REMOVED***)
  }

  var obj = {
    type: type,
    subtype: subtype,
    suffi***REMOVED***: suffi***REMOVED***
  }

  return obj
}
